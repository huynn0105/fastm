import 'dart:convert';

import 'package:collection/collection.dart';
import 'package:flutter_module/app_data.dart';
import 'package:flutter_module/common/enum/chat/quoted_message_type.dart';
import 'package:flutter_module/common/extension/list_extension.dart';
import 'package:flutter_module/features/chat/hive_database/entities/message/message_entity.dart';
import 'package:flutter_module/models/chat/file/media_model.dart';
import 'package:flutter_module/models/chat/message/author_model.dart';
import 'package:flutter_module/models/chat/message/reaction_model.dart';
import 'package:flutter_module/services/firebase/firebase_database/firebase_database_util.dart';

import '../../../common/enum/chat/thread_message_type.dart';
import '../location_model.dart';

class MessageModel {
  MessageModel({
    this.uid,
    this.threadID,
    this.text,
    this.type,
    this.author,
    this.location,
    this.createTime,
    this.updateTime,
    this.isEdited,
    this.isRecalled,
    this.medias,
    this.typeCreateTime,
    this.mediaWidth,
    this.mediaHeight,
    this.htmlText,
    this.reaction,
    this.quotedMessage,
    this.quotedType,
    this.isDeletedBy,
  });

  String? uid;
  String? threadID;
  String? type;
  String? text;
  int? createTime;
  int? updateTime;
  AuthorModel? author;
  LocationModel? location;
  bool? isEdited;
  bool? isRecalled;
  List<MediaModel>? medias;
  String? typeCreateTime;
  int? mediaWidth;
  int? mediaHeight;
  String? htmlText;
  Map<String, String>? reaction;
  MessageModel? quotedMessage;
  String? quotedType;
  Map<String, bool>? isDeletedBy;

  factory MessageModel.fromEntity(MessageEntity entity) {
    return MessageModel(
      uid: entity.uid,
      author: entity.author != null ? AuthorModel.fromEntity(entity.author!) : null,
      createTime: entity.createTime,
      htmlText: entity.htmlText,
      isDeletedBy: entity.isDeletedBy,
      isEdited: entity.isEdited,
      isRecalled: entity.isRecalled,
      location: entity.location != null ? LocationModel.fromEntity(entity.location!) : null,
      mediaHeight: entity.mediaHeight,
      mediaWidth: entity.mediaWidth,
      medias: entity.medias != null ? entity.medias!.map((e) => MediaModel.fromEntity(e)).toList() : null,
      quotedMessage: entity.quotedMessage != null ? MessageModel.fromEntity(entity.quotedMessage!) : null,
      quotedType: entity.quotedType,
      reaction: entity.reaction,
      text: entity.text,
      threadID: entity.threadID,
      type: entity.type,
      typeCreateTime: entity.typeCreateTime,
      updateTime: entity.updateTime,
    );
  }

  MessageModel.fromJson(dynamic json) {
    uid = json['uid'];
    threadID = json['threadID'];
    text = json['text'];
    createTime = json['createTime'];
    updateTime = json['updateTime'];
    author = AuthorModel.fromJson(json);
    location = json['location'] == null ? null : LocationModel.fromJson(json['location']);
    isEdited = json['isEdited'];
    isRecalled = json['isRecalled'];
    type = json['type'];
    mediaWidth = json['width'];
    mediaHeight = json['height'];
    htmlText = json['htmlText'];

    if (json['imageURLs'] != null) {
      List<MediaModel>? data = [];
      Map<String, dynamic> images = FirebaseDatabaseUtil.convertObjectToMap(json['imageURLs']);
      for (var e in images.values) {
        data.add(MediaModel.fromJson(FirebaseDatabaseUtil.convertObjectToMap(e)));
      }
      medias = data;
    }

    reaction = json['reaction'] == null ? null : Map<String, String>.from(json['reaction']);
    quotedMessage = json['quotedMessage'] == null ? null : MessageModel.fromQuotedJson(json['quotedMessage']);
    quotedType = json['quotedType'];
    isDeletedBy = json['isDeletedBy'] == null ? null : Map<String, bool>.from(json['isDeletedBy']);
  }

  MessageModel.fromQuotedJson(dynamic json) {
    uid = json['uid'];
    type = json['type'];
    text = json['text'];
    isEdited = json['isEdited'];
    isRecalled = json['isRecalled'];
    htmlText = json['htmlText'];
    author = AuthorModel.fromJson(json);
    if (json['imageURLs'] != null) {
      List<MediaModel>? data = [];
      Map<String, dynamic> images = FirebaseDatabaseUtil.convertObjectToMap(json['imageURLs']);
      for (var e in images.values) {
        data.add(MediaModel.fromJson(FirebaseDatabaseUtil.convertObjectToMap(e)));
      }
      medias = data;
    }
    quotedType = json['quotedType'];
  }

  Map<String, dynamic> toFirebaseJson() {
    final map = <String, dynamic>{};
    map['uid'] = uid;
    map['threadID'] = threadID;
    map['text'] = text;
    map['createTime'] = createTime;
    map['updateTime'] = updateTime;
    if (author != null) {
      map.addAll(author!.toJson());
    }
    if (location != null) {
      map['location'] = location!.toJson();
    }
    if (medias != null) {
      final json = <String, dynamic>{};
      medias?.forEach((e) {
        json['${e.id}'] = e.toFirebaseJson();
      });
      map['imageURLs'] = json;
    }
    map['type'] = type;
    map['isEdited'] = isEdited;
    map['isRecalled'] = isRecalled;
    map['typeCreateTime'] = typeCreateTime;
    map['width'] = mediaWidth;
    map['height'] = mediaHeight;
    map['htmlText'] = htmlText;
    if (reaction != null) {
      map['reaction'] = reaction;
    }
    if (quotedMessage != null) {
      map['quotedMessage'] = quotedMessage!.toQuotedJson();
    }
    map['quotedType'] = quotedType;
    if (isDeletedBy != null) {
      map['isDeletedBy'] = isDeletedBy;
    }
    return map;
  }

  Map<String, dynamic> toQuotedJson() {
    final map = <String, dynamic>{};
    map['uid'] = uid;
    map['type'] = type;
    map['text'] = text;
    map['htmlText'] = htmlText;
    if (author != null) {
      map.addAll(author!.toJson());
    }
    if (medias != null) {
      final json = <String, dynamic>{};
      medias?.forEach((e) {
        json['${e.id}'] = e.toFirebaseJson();
        if (json.isNotEmpty) {
          return;
        }
      });
      map['imageURLs'] = json;
    }
    map['quotedType'] = quotedType;
    return map;
  }

  MessageModel copyWith({
    String? uid,
    String? threadID,
    String? type,
    String? text,
    int? createTime,
    int? updateTime,
    AuthorModel? author,
    LocationModel? location,
    bool? isEdited,
    bool? isRecalled,
    List<MediaModel>? medias,
    String? typeCreateTime,
    int? mediaWidth,
    int? mediaHeight,
    String? htmlText,
    Map<String, String>? reaction,
    MessageModel? quotedMessage,
    String? quotedType,
    Map<String, bool>? isDeletedBy,
    String? userID,
    List<MediaModel>? data,
    Map<String, dynamic>? images,
  }) {
    return MessageModel(
      uid: uid ?? this.uid,
      threadID: threadID ?? this.threadID,
      type: type ?? this.type,
      text: text ?? this.text,
      createTime: createTime ?? this.createTime,
      updateTime: updateTime ?? this.updateTime,
      author: author ?? this.author,
      location: location ?? this.location,
      isEdited: isEdited ?? this.isEdited,
      isRecalled: isRecalled ?? this.isRecalled,
      medias: medias ?? this.medias,
      typeCreateTime: typeCreateTime ?? this.typeCreateTime,
      mediaWidth: mediaWidth ?? this.mediaWidth,
      mediaHeight: mediaHeight ?? this.mediaHeight,
      htmlText: htmlText ?? this.htmlText,
      reaction: reaction ?? this.reaction,
      quotedMessage: quotedMessage ?? this.quotedMessage,
      quotedType: quotedType ?? this.quotedType,
      isDeletedBy: isDeletedBy ?? this.isDeletedBy,
    );
  }

  @override
  String toString() {
    return jsonEncode(toFirebaseJson());
  }

  ThreadMessageType getMessageType() {
    final result = ThreadMessageType.values.firstWhereOrNull((e) => e.name == type);
    return result ?? ThreadMessageType.text;
  }

  QuotedMessageType? getQuotedType() {
    final result = QuotedMessageType.values.firstWhereOrNull((e) => e.name == quotedType);
    return result;
  }

  bool isMe() {
    return author?.id == AppData.instance.userID;
  }

  DateTime? getCreatedTime() {
    if (createTime == null) {
      return null;
    }
    return DateTime.fromMillisecondsSinceEpoch(createTime!, isUtc: true);
  }

  DateTime? getUpdatedTime() {
    if (updateTime == null) {
      return null;
    }
    return DateTime.fromMillisecondsSinceEpoch(updateTime!, isUtc: true);
  }

  String? getMyReaction() {
    String userID = FirebaseDatabaseUtil.getFirebaseUserID();
    return reaction?[userID];
  }

  List<ReactionModel> getReactions() {
    final reaction = this.reaction ?? <String, String>{};
    final distinct = reaction.values.toSet();
    final result = <ReactionModel>[];

    for (String code in distinct) {
      final data = groupBy(reaction.entries, (e) => e.value);
      final item = data[code] ?? [];
      final userIDs = item.map((e) => e.key).toList();
      result.add(
        ReactionModel(
          code: code,
          userIDs: userIDs,
        ),
      );
    }

    return result;
  }

  List<MediaModel> getMedias() {
    return medias ?? [];
  }

  bool isDeletedByMe() {
    final userID = FirebaseDatabaseUtil.getFirebaseUserID();
    return isDeletedBy?[userID] == true;
  }

  String getLocationTitle() {
    if (isMe()) {
      return 'Vị trí của bạn';
    }
    return 'Vị trí của ${author?.fullName ?? '---'}';
  }

  MessageModel toNewMessage() {
    switch (getMessageType()) {
      case ThreadMessageType.images:
        return MessageModel.newImageMessage(medias: medias);
      case ThreadMessageType.videos:
        return MessageModel.newVideoMessage(medias: medias);
      case ThreadMessageType.audios:
        return MessageModel.newAudioMessage(media: medias?.getFirst());
      case ThreadMessageType.location:
        return MessageModel.newLocationMessage(location: location);
      case ThreadMessageType.sticker:
        return MessageModel.newStickerMessage(sticker: htmlText);
      case ThreadMessageType.mention:
        return MessageModel.newMentionMessage(text: text, htmlText: htmlText);
      case ThreadMessageType.text:
      default:
        return MessageModel.newTextMessage(text: text);
    }
  }

  static MessageModel newTextMessage({
    required String? text,
  }) {
    return MessageModel(
      text: text,
      type: ThreadMessageType.text.name,
      author: AppData.instance.author,
    );
  }

  static MessageModel newMentionMessage({
    required String? text,
    required String? htmlText,
  }) {
    return MessageModel(
      text: text,
      htmlText: '<span>$htmlText</span>',
      type: ThreadMessageType.mention.name,
      author: AppData.instance.author,
    );
  }

  static MessageModel newImageMessage({
    required List<MediaModel>? medias,
  }) {
    return MessageModel(
      medias: medias,
      text: 'Vừa chia sẻ hình ảnh',
      type: ThreadMessageType.images.name,
      author: AppData.instance.author,
      mediaWidth: medias.getFirst()?.width,
      mediaHeight: medias.getFirst()?.height,
    );
  }

  static MessageModel newVideoMessage({
    required List<MediaModel>? medias,
  }) {
    return MessageModel(
      medias: medias,
      text: 'Vừa chia sẻ video',
      type: ThreadMessageType.videos.name,
      author: AppData.instance.author,
      mediaWidth: medias.getFirst()?.width,
      mediaHeight: medias.getFirst()?.height,
    );
  }

  static MessageModel newStickerMessage({
    required String? sticker,
  }) {
    return MessageModel(
      htmlText: sticker,
      text: 'Vừa chia sẻ sticker',
      type: ThreadMessageType.sticker.name,
      author: AppData.instance.author,
    );
  }

  static MessageModel newLocationMessage({
    required LocationModel? location,
  }) {
    return MessageModel(
      location: location,
      text: 'Vừa chia sẻ vị trí',
      type: ThreadMessageType.location.name,
      author: AppData.instance.author,
    );
  }

  static MessageModel newAudioMessage({
    required MediaModel? media,
  }) {
    return MessageModel(
      medias: media == null ? [] : [media],
      text: 'Vừa chia sẻ tin nhắn thoại',
      type: ThreadMessageType.audios.name,
      author: AppData.instance.author,
      mediaWidth: media?.width,
      mediaHeight: media?.height,
    );
  }

  static MessageModel newNoticeMessage({
    required String text,
    required String htmlText,
  }) {
    return MessageModel(
      text: text,
      htmlText: htmlText,
      type: ThreadMessageType.notice.name,
      author: AppData.instance.author,
    );
  }
}
