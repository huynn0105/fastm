import 'package:bloc/bloc.dart';
import 'package:ekyc/common/bloc_status.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter_module/common/constants.dart';
import 'package:flutter_module/features/mfast/repository/mfast_repository.dart';
import 'package:flutter_module/models/mfast/user_meta_data/mfast_user_meta_data_model.dart';

part 'mfast_contract_collaborator_state.dart';

class MFastContractCollaboratorCubit extends Cubit<MFastContractCollaboratorState> {
  MFastContractCollaboratorCubit() : super(const MFastContractCollaboratorState());

  final MFastRepository _repository = MFastRepository();

  togglePolicy() {
    final value = !state.acceptedPolicy;
    emit(state.copyWith(
      acceptedPolicy: value,
    ));
    if (value) {
      _validateErrorFields(json: _validatePolicyField());
    }
  }

  _validatePolicyField() {
    final errorFields = {...state.errorFields};

    if (!state.acceptedPolicy) {
      errorFields[AppConstants.contractPolicyKey] = "Bạn có đồng ý với điều khoản trên?";
    } else {
      errorFields.remove(AppConstants.contractPolicyKey);
    }

    return errorFields;
  }

  bool _validateErrorFields({Map<String, String>? json}) {
    final errorFields = {...(json ?? state.errorFields)};
    final enabledSubmit = errorFields.isEmpty;
    emit(state.copyWith(
      errorFields: errorFields,
      enabledSubmit: enabledSubmit,
    ));
    return enabledSubmit;
  }

  bool _validate() {
    Map<String, String> errorFields = {...state.errorFields};

    errorFields.addAll(_validatePolicyField());

    return _validateErrorFields(json: errorFields);
  }

  bool enabledSubmit() {
    return _validate();
  }

  submit({
    MFastUserMetaDataModel? userMetaData,
  }) async {
    if (!_validate()) {
      return;
    }

    emit(state.copyWith(
      submitStatus: BlocStatus.loading,
    ));

    final result = await _repository.updateUserMetaData(
      payload: MFastUserMetaDataModel(
        ctvAgreement: true,
      ),
    );

    if (result.status) {
      emit(state.copyWith(
        submitStatus: BlocStatus.success,
        userMetaData: result.data,
      ));
    } else {
      emit(state.copyWith(
        submitStatus: BlocStatus.failure,
        errorMessage: result.errorMessage,
      ));
    }

    await Future.delayed(const Duration(seconds: 3));

    emit(state.copyWith(
      submitStatus: BlocStatus.success,
    ));
  }
}
