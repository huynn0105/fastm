import 'package:equatable/equatable.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:flutter_module/common/bloc_status.dart';
import 'package:flutter_module/common/extension/datetime_extension.dart';
import 'package:flutter_module/common/utils/datetime_util.dart';
import 'package:flutter_module/features/mfast/repository/mfast_repository.dart';
import 'package:flutter_module/models/mfast/time_checking/time_checking_info_model.dart';
import 'package:flutter_module/services/api/mfast/payload/time_checking_history_payload.dart';

part 'time_checking_history_state.dart';

class TimeCheckingHistoryCubit extends Cubit<TimeCheckingHistoryState> {
  final MFastRepository _repository = MFastRepository();

  TimeCheckingHistoryCubit()
      : super(
          TimeCheckingHistoryState(
            dateTime: DateTime.now(),
          ),
        );

  onNextMonth() {
    final newMonth = state.dateTime.addMonth(1);
    emit(state.copyWith(dateTime: newMonth));
    getTimeCheckingInMonth(newMonth);
  }

  onPrevMonth() {
    final newMonth = state.dateTime.addMonth(-1);
    emit(state.copyWith(dateTime: newMonth));
    getTimeCheckingInMonth(newMonth);
  }

  onSelectedDay(DateTime selectedDay,{bool isCalendarClick = false}) {
    emit(state.copyWith(
      selectedDay: selectedDay,
      dateTime: selectedDay,
      isCalendarClick: isCalendarClick,
    ));
    getTimeCheckingInDay(selectedDay);
  }


  Future<void> getTimeCheckingInMonth(DateTime date) async {
    final result = await _repository.getTimeCheckingHistory(TimeCheckingHistoryPayload(
      year: date.year,
      month: date.month,
    ));

    if (result.status) {
      final entries = result.data?.dataInMonth!.map(
        (e) => MapEntry(
          DateTimeUtil.getDate(e.date ?? '', format: DateTimeFormat.yyyy_MM_dd)!,
          e.successHistory ?? [],
        ),
      );
      final eventsList = Map<DateTime, List<String>>.fromEntries(entries ?? []);
      emit(state.copyWith(
        status: BlocStatus.success,
        eventsList: eventsList,
      ));
    } else {
      emit(state.copyWith(
        status: BlocStatus.failure,
        errorMessage: result.errorMessage,
      ));
    }
  }

  Future<void> getTimeCheckingInDay(DateTime date) async {
    emit(state.copyWith(
      status: BlocStatus.loading,
    ));

    final result = await _repository.getTimeCheckingHistory(TimeCheckingHistoryPayload(
      year: date.year,
      month: date.month,
      day: date.day,
    ));

    if (result.status) {
      emit(state.copyWith(
        status: BlocStatus.success,
        dataInDay: result.data?.dataInDay,
        selectedDay: date,
      ));
    } else {
      emit(state.copyWith(
        status: BlocStatus.failure,
        errorMessage: result.errorMessage,
        selectedDay: date,
      ));
    }
  }
}