import 'dart:io';

import 'package:bloc/bloc.dart';
import 'package:ekyc/common/enum/document.dart';
import 'package:ekyc/models/blue_info/document/blue_back_document_model.dart';
import 'package:ekyc/models/blue_info/document/blue_front_document_model.dart';
import 'package:ekyc/models/fpt/document/fpt_back_document_model.dart';
import 'package:ekyc/models/fpt/document/fpt_front_document_model.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter_module/app_data.dart';
import 'package:flutter_module/common/bloc_status.dart';
import 'package:flutter_module/common/enum/mfast/liveness_support_status.dart';
import 'package:flutter_module/common/extension/list_extension.dart';
import 'package:flutter_module/common/utils/base64_util.dart';
import 'package:flutter_module/common/utils/text_util.dart';
import 'package:flutter_module/features/mfast/repository/mfast_repository.dart';
import 'package:flutter_module/models/mfast/user_meta_data/mfast_user_meta_data_model.dart';
import 'package:ekyc/common/constants.dart' as ekyc;

part 'identity_card_state.dart';

class IdentityCardCubit extends Cubit<IdentityCardState> {
  IdentityCardCubit() : super(const IdentityCardState());

  final MFastRepository _repository = MFastRepository();

  int? docClass;

  initData({
    MFastUserMetaDataModel? userMetaData,
  }) {
    emit(state.copyWith(
      userMetaData: userMetaData,
    ));
  }

  Future<String> uploadImage(
    String imageBase64, {
    DocumentSide? documentSide,
  }) async {
    File? file = await Base64Util.convertBase64ToFile(imageBase64);
    if (file == null) return '';

    emit(state.copyWith(
      uploadStatus: BlocStatus.loading,
    ));

    final result = await _repository.uploadImage(file: file);

    if (result.status) {
      final MFastUserMetaDataModel userMetaData = state.userMetaData ?? MFastUserMetaDataModel();

      if (documentSide?.isFront == true) {
        emit(state.copyWith(
          uploadStatus: BlocStatus.success,
          userMetaData: userMetaData.copyWith(
            countryIdPhotoFront: result.data,
          ),
        ));
      } else if (documentSide?.isBack == true) {
        emit(state.copyWith(
          uploadStatus: BlocStatus.success,
          userMetaData: userMetaData.copyWith(
            countryIdPhotoBack: result.data,
          ),
        ));
      } else {
        emit(state.copyWith(
          uploadStatus: BlocStatus.success,
          userMetaData: userMetaData.copyWith(
            selfiePhoto: result.data,
          ),
        ));
      }
    } else {
      emit(state.copyWith(
        uploadStatus: BlocStatus.failure,
      ));
    }
    return result.data ?? '';
  }

  updateInfoOCR({
    BlueFrontDocumentModel? blueFrontDocument,
    BlueBackDocumentModel? blueBackDocument,
    FPTFrontDocumentModel? fptFrontDocument,
    FPTBackDocumentModel? fptBackDocument,
  }) {
    final MFastUserMetaDataModel userMetaData = state.userMetaData ?? MFastUserMetaDataModel();
    final String? qrCodeData = blueFrontDocument?.qrCode;
    String? countryOldIdNumber;
    if (TextUtils.isNotEmpty(qrCodeData)) {
      countryOldIdNumber = qrCodeData?.split("|").valueAt(1);
    }

    emit(state.copyWith(
      userMetaData: userMetaData.copyWith(
        //FRONT
        countryIdNumber: blueFrontDocument?.infors?.idNumber ?? fptFrontDocument?.id,
        countryOldIdNumber: countryOldIdNumber,
        countryIdName: blueFrontDocument?.infors?.fullname ?? fptFrontDocument?.name,
        countryIdDateOfBirth: blueFrontDocument?.infors?.dob ?? fptFrontDocument?.dob,
        countryIdAddress: blueFrontDocument?.infors?.habitualAddress ?? fptFrontDocument?.address,
        countryIdHomeAddress: blueFrontDocument?.infors?.hometown ?? fptFrontDocument?.home,
        gender: blueFrontDocument?.infors?.gender ?? fptFrontDocument?.sex,
        //BACK
        countryIdIssuedBy: blueBackDocument?.infors?.issuedPlace ?? fptBackDocument?.issueBy,
        countryIdIssuedDate: blueBackDocument?.infors?.issuedDate ?? fptBackDocument?.issueDate,
      ),
    ));

    if (blueFrontDocument != null) {
      docClass = blueFrontDocument.docClass;
      emit(state.copyWith(
        frontCardMessage: _checkBlueInfoLegalityFront(value: blueFrontDocument)
            ? ''
            : 'Hình chụp mặt trước CMND/CCCD có dấu hiệu gian lận',
      ));
    }
    if (fptFrontDocument != null) {
      emit(state.copyWith(
        frontCardMessage:
            _checkFPTLegalityFront(value: fptFrontDocument) ? '' : 'Hình chụp mặt trước CMND/CCCD có dấu hiệu gian lận',
      ));
    }
    if (blueBackDocument != null) {
      emit(state.copyWith(
        backCardMessage: _checkBlueInfoLegalityBack(value: blueBackDocument)
            ? ''
            : 'Hình chụp mặt sau CMND/CCCD có dấu hiệu gian lận',
      ));
    }
    if (fptBackDocument != null) {
      emit(state.copyWith(
        backCardMessage:
            _checkFPTLegalityBack(value: fptBackDocument) ? '' : 'Hình chụp mặt sau CMND/CCCD có dấu hiệu gian lận',
      ));
    }
  }

  removeImage({
    DocumentSide? documentSide,
  }) {
    final MFastUserMetaDataModel userMetaData = state.userMetaData ?? MFastUserMetaDataModel();
    if (documentSide?.isFront == true) {
      emit(state.copyWith(
        userMetaData: userMetaData.copyWith(
          countryIdPhotoFront: '',
          countryIdPhotoBack: '',
          selfiePhoto: '',
        ),
        isFaceMatch: false,
        faceMatchMessage: '',
        frontCardMessage: '',
        updateErrorMessage: '',
      ));
    } else if (documentSide?.isBack == true) {
      emit(state.copyWith(
        userMetaData: userMetaData.copyWith(
          countryIdPhotoBack: '',
        ),
        backCardMessage: '',
        updateErrorMessage: '',
      ));
    } else {
      emit(state.copyWith(
        userMetaData: userMetaData.copyWith(
          selfiePhoto: '',
        ),
        isFaceMatch: false,
        faceMatchMessage: '',
        updateErrorMessage: '',
      ));
    }
  }

  handleFaceMatch({required bool isFaceMatch, String? message}) {
    int countFaceMatchFailed = state.countFaceMatchFailed;
    if (isFaceMatch) {
      countFaceMatchFailed = 0;
    } else {
      countFaceMatchFailed++;
    }

    emit(state.copyWith(
      isFaceMatch: isFaceMatch,
      faceMatchMessage: message ?? '',
      countFaceMatchFailed: countFaceMatchFailed,
    ));
  }

  lockEkyc() async {
    if (state.userMetaData == null) return;
    final MFastUserMetaDataModel? userMetaData = state.userMetaData;
    final MFastUserMetaDataModel payload = MFastUserMetaDataModel(
      countryIdNumber: userMetaData?.countryIdNumber,
      countryOldIdNumber: userMetaData?.countryOldIdNumber,
      countryIdName: userMetaData?.countryIdName,
      countryIdDateOfBirth: userMetaData?.countryIdDateOfBirth,
      countryIdAddress: userMetaData?.countryIdAddress,
      countryIdHomeAddress: userMetaData?.countryIdHomeAddress,
      gender: userMetaData?.gender,
      countryIdIssuedBy: userMetaData?.countryIdIssuedBy,
      countryIdIssuedDate: userMetaData?.countryIdIssuedDate,
      // for support
      isLockedKyc: true,
      livenessWithIdNumberPending: userMetaData?.selfiePhoto,
      livenessDocFrontUrl: userMetaData?.countryIdPhotoFront,
      livenessDocBackUrl: userMetaData?.countryIdPhotoBack,
      livenessCountryIdNumber: userMetaData?.countryIdNumber,
      livenessCountryIdName: userMetaData?.countryIdName,
      livenessGender: userMetaData?.gender,
      livenessCountryIdDateOfBirth: userMetaData?.countryIdDateOfBirth,
      livenessCountryIdIssuedDate: userMetaData?.countryIdIssuedDate,
      livenessCountryIdIssuedBy: userMetaData?.countryIdIssuedBy,
      livenessCountryIdAddress: userMetaData?.countryIdAddress,
      livenessCountryIdHomeAddress: userMetaData?.countryIdHomeAddress,
    );

    emit(state.copyWith(
      lockStatus: BlocStatus.loading,
    ));

    final result = await _repository.updateUserMetaData(payload: payload);

    if (result.status) {
      emit(state.copyWith(
        lockStatus: BlocStatus.success,
        userMetaData: result.data,
      ));
    } else {
      emit(state.copyWith(
        lockStatus: BlocStatus.failure,
        updateErrorMessage: result.errorMessage,
      ));
    }
  }

  sendSupport({required String note}) async {
    if (state.userMetaData == null) return;
    final MFastUserMetaDataModel payload = MFastUserMetaDataModel(
      isLockedKyc: true,
      livenessWithIdNumberStatus: LivenessSupportStatus.pending.name,
      livenessWithIdNumberNote: note,
      selfiePhoto: state.userMetaData?.selfieImage(),
    );

    emit(state.copyWith(
      lockStatus: BlocStatus.loading,
    ));

    final result = await _repository.updateUserMetaData(payload: payload);

    if (result.status) {
      emit(state.copyWith(
        lockStatus: BlocStatus.success,
        userMetaData: result.data,
      ));
    } else {
      emit(state.copyWith(
        lockStatus: BlocStatus.failure,
        updateErrorMessage: result.errorMessage,
      ));
    }
  }

  submitOCR() async {
    if (state.userMetaData == null) return;
    final MFastUserMetaDataModel? userMetaData = state.userMetaData;
    final MFastUserMetaDataModel payload = MFastUserMetaDataModel(
      countryIdStatus: LivenessSupportStatus.success.name,
      countryIdNumber: userMetaData?.countryIdNumber,
      countryOldIdNumber: userMetaData?.countryOldIdNumber,
      countryIdName: userMetaData?.countryIdName,
      countryIdDateOfBirth: userMetaData?.countryIdDateOfBirth,
      countryIdAddress: userMetaData?.countryIdAddress,
      countryIdHomeAddress: userMetaData?.countryIdHomeAddress,
      gender: userMetaData?.gender,
      countryIdIssuedBy: userMetaData?.countryIdIssuedBy,
      countryIdIssuedDate: userMetaData?.countryIdIssuedDate,
      countryIdPhotoFront: userMetaData?.frontCardImage(),
      countryIdPhotoBack: userMetaData?.backCardImage(),
      selfiePhoto: userMetaData?.selfieImage(),
      livenessWithIdNumberStatus: '',
    );

    emit(state.copyWith(
      submitStatus: BlocStatus.loading,
    ));

    final result = await _repository.updateUserMetaData(payload: payload);

    if (result.status) {
      emit(state.copyWith(
        submitStatus: BlocStatus.success,
        userMetaData: result.data,
      ));
    } else {
      emit(state.copyWith(
        submitStatus: BlocStatus.failure,
        updateErrorMessage: result.errorMessage,
      ));
    }
  }

  saveLogOCR({Map? data}) async {
    final result = await _repository.saveLogOCR(data: data);
  }

  bool _checkBlueInfoLegalityFront({BlueFrontDocumentModel? value}) {
    final double ekycValidCore = AppData.instance.appInfo.ekycValidScore ?? ekyc.AppConstants.validEkycCore;
    final double idProb = value?.probInfors?.idNumber ?? 0;
    final bool validId = idProb > ekycValidCore;
    final double nameProb = value?.probInfors?.fullname ?? 0;
    final bool validName = nameProb > ekycValidCore;
    final double dobProb = value?.probInfors?.dob ?? 0;
    final bool validDob = dobProb > ekycValidCore;

    bool validSex = true;
    bool validNationality = true;
    if ((value?.infors?.idNumber?.length ?? 0) > 9) {
      final double sexProb = value?.probInfors?.gender ?? 0;
      validSex = sexProb > ekycValidCore;
      final double nationalityProb = value?.probInfors?.nationality ?? 0;
      validNationality = nationalityProb > ekycValidCore;
    }
    final double homeProb = value?.probInfors?.hometown ?? 0;
    final bool validHome = homeProb > ekycValidCore;
    final double addressProb = value?.probInfors?.habitualAddress ?? 0;
    final bool validAddress = addressProb > ekycValidCore;
    final bool isRecapture = value?.fraudDetect?.recapture == true;
    final bool isCornerCut = value?.fraudDetect?.cornerCut == true;
    final bool isBlur = value?.fraudDetect?.checkBlur == true;
    final bool isCopied = value?.fraudDetect?.checkCopied == true;
    final bool isFaceSwapping = value?.fraudDetect?.faceSwapping == true;
    final bool unmatchIdAdd = value?.fraudDetect?.unmatchIdAdd == 'true';

    return validId &&
        validName &&
        validDob &&
        validSex &&
        validNationality &&
        validHome &&
        validAddress &&
        !isCornerCut &&
        !isRecapture &&
        !isBlur &&
        !isCopied &&
        !isFaceSwapping &&
        !unmatchIdAdd;
  }

  bool _checkFPTLegalityFront({FPTFrontDocumentModel? value}) {
    final double ekycValidCore = AppData.instance.appInfo.ekycValidScore ?? ekyc.AppConstants.validEkycCore;
    final double idProb = double.tryParse(value?.idProb ?? '') ?? 0;
    final bool validId = idProb > ekycValidCore;
    final double nameProb = double.tryParse(value?.nameProb ?? '') ?? 0;
    final bool validName = nameProb > ekycValidCore;
    final double dobProb = double.tryParse(value?.dobProb ?? '') ?? 0;
    final bool validDob = dobProb > ekycValidCore;
    final double sexProb = double.tryParse(value?.sexProb ?? '') ?? 0;
    final bool validSex = sexProb > ekycValidCore;
    final double nationalityProb = double.tryParse(value?.nationalityProb ?? '') ?? 0;
    final bool validNationality = nationalityProb > ekycValidCore;
    final double homeProb = double.tryParse(value?.homeProb ?? '') ?? 0;
    final bool validHome = homeProb > ekycValidCore;
    final double addressProb = double.tryParse(value?.addressProb ?? '') ?? 0;
    final bool validAddress = addressProb > ekycValidCore;
    final double doeProb = double.tryParse(value?.doeProb ?? '') ?? 0;
    final bool validDoe = doeProb > ekycValidCore;
    final bool isRecapture = value?.checkingResult?.recapturedResult == '1';
    final bool isCornerCut = value?.checkingResult?.cornerCutResult == '1';
    final bool isPhoto = value?.checkingResult?.checkPhotocopiedResult == '1';
    final bool isEdited = value?.checkingResult?.editedResult == '1';

    return validId &&
        validName &&
        validDob &&
        validSex &&
        validNationality &&
        validHome &&
        validAddress &&
        validDoe &&
        !isRecapture &&
        !isCornerCut &&
        !isPhoto &&
        !isEdited;
  }

  bool _checkBlueInfoLegalityBack({BlueBackDocumentModel? value}) {
    final double ekycValidCore = AppData.instance.appInfo.ekycValidScore ?? ekyc.AppConstants.validEkycCore;
    final double issuedPlace = value?.probInfors?.issuedPlace ?? 0;
    final bool validIssuedPlace = issuedPlace > ekycValidCore;
    final double issuedDate = value?.probInfors?.issuedDate ?? 0;
    final bool validIssuedDate = issuedDate > ekycValidCore;
    final bool validDocClass =
        value?.docClass == docClass || (value?.docClass == DocClass.cmnd12.value && docClass == DocClass.cccd12.value);

    return validIssuedPlace && validIssuedDate && validDocClass;
  }

  bool _checkFPTLegalityBack({FPTBackDocumentModel? value}) {
    final double ekycValidCore = AppData.instance.appInfo.ekycValidScore ?? ekyc.AppConstants.validEkycCore;
    final String issueDateValue = value?.issueDateProb ?? '';
    final double issueDateProb = double.tryParse(issueDateValue) ?? 0;
    final bool isRecapture = value?.checkingResult?.recapturedResult == '1';
    final bool isCornerCut = value?.checkingResult?.cornerCutResult == '1';
    final bool isPhoto = value?.checkingResult?.checkPhotocopiedResult == '1';
    final bool isEdited = value?.checkingResult?.editedResult == '1';
    return issueDateProb > ekycValidCore && !isRecapture && !isCornerCut && !isPhoto && !isEdited;
  }
}
