import 'dart:io';

import 'package:bloc/bloc.dart';
import 'package:camera/camera.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter_module/common/bloc_status.dart';
import 'package:flutter_module/common/utils/location_util.dart';
import 'package:flutter_module/features/mfast/repository/mfast_repository.dart';
import 'package:flutter_module/models/base_model.dart';
import 'package:flutter_module/models/mfast/time_checking/time_checking_submit_payload_model.dart';
import 'package:geolocator/geolocator.dart';
import 'package:image/image.dart' as img;

part 'time_checking_submit_cubit_state.dart';

class TimeCheckingSubmitCubit extends Cubit<TimeCheckingSubmitState> {
  final MFastRepository _repository = MFastRepository();
  TimeCheckingSubmitCubit() : super(const TimeCheckingSubmitState());

  void takePicture(Future<XFile?> Function() takePick) async {
    emit(state.copyWith(
      takePictureStatus: BlocStatus.loading,
    ));
    try {
      final xfile = await takePick();
      if (xfile == null) {
        emit(state.copyWith(
          takePictureStatus: BlocStatus.initial,
        ));
        return;
      }

      final imageBytes = await xfile.readAsBytes();

      img.Image? originalImage = img.decodeImage(imageBytes);
      img.Image fixedImage = img.flipHorizontal(originalImage!);

      File file = File(xfile.path);
      final image = await file.writeAsBytes(
        img.encodeJpg(fixedImage),
        flush: true,
      );

      emit(state.copyWith(
        takePictureStatus: BlocStatus.success,
        fileImage: File(image.path),
      ));
    } catch (e) {
      emit(state.copyWith(
        takePictureStatus: BlocStatus.initial,
      ));
    }
  }

  void clearPicture() {
    emit(state.copyWith(
      takePictureStatus: BlocStatus.initial,
      isClearPicture: true,
    ));
  }

  Future<void> timeCheckingSubmit(String type) async {
    emit(state.copyWith(
      status: BlocStatus.loading,
    ));

    BaseModel<String> imageResult = await _repository.uploadImageFromFile(state.fileImage);

    if (imageResult.data?.isNotEmpty == true) {
      Position? position = await LocationUtil.instance.getCurrentLocation();
      TimeCheckingSubmitPayload payload = TimeCheckingSubmitPayload.fromJson(
        lat: '${position?.latitude ?? 0}',
        lon: '${position?.longitude ?? 0}',
        type: type,
        image: imageResult.data,
      );

      final timeCheckingResult = await _repository.timeCheckingSubmit(payload);

      if (timeCheckingResult.status) {
        emit(state.copyWith(
          status: BlocStatus.success,
        ));
      } else {
        emit(state.copyWith(
          status: BlocStatus.failure,
          statusCode: timeCheckingResult.errorCode,
          errorMessage: timeCheckingResult.errorMessage,
        ));
      }
    } else {
      emit(state.copyWith(
        status: BlocStatus.failure,
      ));
    }
  }
}
