import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter/cupertino.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:flutter_module/common/bloc_status.dart';
import 'package:flutter_module/common/enum/shipper/delivery_status.dart';
import 'package:flutter_module/common/event_bus/event_bus.dart';
import 'package:flutter_module/common/utils/text_util.dart';
import 'package:flutter_module/features/shipper/repository/shipper_repository.dart';
import 'package:flutter_module/models/shipper/order/order_detail.dart';
import 'package:flutter_module/general_config.dart';
import 'package:flutter_module/models/shipper/order/shipper_detail_order_model.dart';
import 'package:flutter_module/models/shipper/payment_method/payment_method_model.dart';
import 'package:flutter_module/services/api/shipper/payload/shipper_detail_order_payload.dart';
import 'package:flutter_module/services/api/shipper/payload/warning_payment_payload.dart';
import 'package:geolocator/geolocator.dart';

import '../../../../common/colors.dart';
import '../../../../common/constants.dart';
import '../../../../common/dialogs/dialog_provider.dart';
import '../../../../common/utils/location_util.dart';
import '../../../../services/api/shipper/payload/update_shipper_order_status_payload.dart';
import 'package:permission_handler/permission_handler.dart';

part 'shipper_bill_lading_detail_state.dart';

class ShipperBillLadingDetailCubit extends Cubit<ShipperBillLadingDetailState> {
  ShipperBillLadingDetailCubit() : super(const ShipperBillLadingDetailState());

  final ShipperRepository _repository = ShipperRepository();
  final reportPaymentMethodController = TextEditingController();

  fetchData(String? orderCode, Function(OrderDetail?) onSuccess) async {
    emit(state.copyWith(status: BlocStatus.loading, forceCleanData: true));

    final List results = await Future.wait([
      _repository.getDetailDelivery(DeliveryPayload(orderCode: orderCode)),
      _repository.getPaymentMethods(),
    ]);

    if (results.first.status) {
      onSuccess.call(results.first.data.orderDetail);
      DeliveryModel? deliveryModel = results.first.data;
      List<PaymentMethodModel> paymentMethods = results.last.data ?? [];
      String? errorGatewayCode = deliveryModel?.orderDetail?.errorGatewayCode?.toUpperCase();
      int? selectPaymentMethodIndex;
      if (TextUtils.isNotEmpty(errorGatewayCode)) {
        selectPaymentMethodIndex = paymentMethods.indexWhere((element) => element.alias?.toUpperCase() == errorGatewayCode);
        if (selectPaymentMethodIndex >= 0) {
          reportPaymentMethodController.text = paymentMethods[selectPaymentMethodIndex].title ?? '';
        }
      }
      emit(state.copyWith(
        status: BlocStatus.success,
        data: deliveryModel,
        paymentMethods: paymentMethods,
        selectPaymentMethodIndex: selectPaymentMethodIndex,
      ));
    } else {
      emit(state.copyWith(
        status: BlocStatus.failure,
      ));
    }
  }

  updateOrder({
    required BuildContext context,
    String? orderCode,
    String? statusCode,
    String? note,
    String? reasonCode,
  }) async {
    emit(state.copyWith(completedStatus: BlocStatus.loading));
    bool permission = await LocationUtil.instance.requestPermission(context: context);
    if (permission == false && context.mounted) {
      DialogProvider.instance.showMTradeDialog(
        context: context,
        asset: "ic_mtrade_mascot_error",
        title: "Cập nhật trạng thái thất bại",
        message: "Vui lòng cho phép quyền truy cập vị trí",
        titleColor: UIColors.red,
        messageAlign: TextAlign.start,
        positiveTitle: "Cho phép truy cập",
        positiveCallback: () {
          openAppSettings();
        },
      );
      emit(state.copyWith(status: BlocStatus.failure));
      return;
    }
    Position? position = await LocationUtil.instance.getCurrentLocation();
    final result = await _repository.updateDeliveryStatus(UpdateDeliveryStatusPayload(
      orderCode: orderCode,
      statusCode: statusCode,
      note: note,
      reasonCode: reasonCode,
      longitude: '${position?.longitude}',
      latitude: '${position?.latitude}',
      notUpdatePaid: statusCode?.isEmpty,
    ));

    if (result.status) {
      eventBus.fire(const ShipperRefreshAfterUpdateOrderStatusEventBus());
      emit(state.copyWith(
        completedStatus: BlocStatus.success,
      ));
    } else {
      emit(state.copyWith(
        status: BlocStatus.failure,
      ));
    }
  }

  selectReasonDelay(String? reasonCode) {
    Map<String, String> errorFields = Map<String, String>.from(state.errorFields);
    errorFields.removeWhere((key, value) => key == AppConstants.reasonDelayKey);
    emit(state.copyWith(reasonDelayCode: reasonCode, errorFields: errorFields));
  }

  selectReasonFailure(String? reasonCode) {
    Map<String, String> errorFields = Map<String, String>.from(state.errorFields);
    errorFields.removeWhere((key, value) => key == AppConstants.reasonFailureKey);
    emit(state.copyWith(reasonFailureCode: reasonCode, errorFields: errorFields));
  }

  changeNextStep(DeliveryStatus nextStep) {
    Map<String, String> errorFields = Map<String, String>.from(state.errorFields);
    if (nextStep != DeliveryStatus.DELAY) {
      errorFields.removeWhere((key, value) => key == AppConstants.reasonDelayKey);
    }
    if (nextStep != DeliveryStatus.DELIVERY_FAILURE) {
      errorFields.removeWhere((key, value) => key == AppConstants.reasonFailureKey);
    }
    emit(state.copyWith(selectedNextStep: nextStep, errorFields: errorFields));
  }

  bool validate() {
    Map<String, String> errorFields = Map<String, String>.from(state.errorFields);
    if (TextUtils.isEmpty(state.reasonDelayCode) && state.selectedNextStep == DeliveryStatus.DELAY) {
      errorFields[AppConstants.reasonDelayKey] = 'Lí do là bắt buộc';
    }
    if (TextUtils.isEmpty(state.reasonFailureCode) && state.selectedNextStep == DeliveryStatus.DELIVERY_FAILURE) {
      errorFields[AppConstants.reasonFailureKey] = 'Lí do là bắt buộc';
    }
    emit(state.copyWith(errorFields: errorFields));
    return state.errorFields.isNotEmpty;
  }

  extendPaymentLink(String orderCode) async {
    _repository.extendLinkPayment(orderCode);
  }

  reportIssue({String? orderCode, String? gateway, bool? hasInvoiceImage}) async {
    if (TextUtils.isEmpty(gateway)) {
      Map<String, String> errorFields = Map<String, String>.from(state.errorFields);
      errorFields[AppConstants.paymentMethodKey] = 'Thông tin này là bắt buộc';
      emit(state.copyWith(errorFields: errorFields));
    }
    if (hasInvoiceImage == false || TextUtils.isEmpty(gateway)) {
      return;
    }
    emit(state.copyWith(reportStatus: BlocStatus.loading));
    final result = await _repository.warningPayment(
      WarningPaymentPayload(orderCode: orderCode, gateway: gateway, systemNotUpdatePaid: true),
    );
    if (result.status) {
      emit(state.copyWith(
        reportStatus: BlocStatus.success,
      ));
    } else {
      emit(state.copyWith(
        reportStatus: BlocStatus.failure,
        errMsg: result.errorMessage,
      ));
    }
  }

  selectReportPaymentMethod(int index) {
    Map<String, String> errorFields = Map<String, String>.from(state.errorFields);
    errorFields.removeWhere((key, value) => key == AppConstants.paymentMethodKey);
    reportPaymentMethodController.text = state.paymentMethods[index].title ?? '';
    emit(state.copyWith(selectPaymentMethodIndex: index, errorFields: errorFields));
  }

  @override
  Future<void> close() {
    reportPaymentMethodController.dispose();
    return super.close();
  }
}
