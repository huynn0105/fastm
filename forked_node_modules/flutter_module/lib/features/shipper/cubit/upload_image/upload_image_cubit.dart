import 'dart:async';
import 'dart:io';

import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter/cupertino.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:flutter_module/common/enum/mtrade/payment_type.dart';
import 'package:flutter_module/common/enum/shipper/delivery_image_type.dart';
import 'package:flutter_module/common/enum/shipper/upload_invoice_process.dart';
import 'package:flutter_module/common/utils/location_util.dart';
import 'package:flutter_module/models/base_model.dart';
import 'package:flutter_module/models/shipper/document/photo_preview_model.dart';
import 'package:flutter_module/models/shipper/order/payment_status_model.dart';
import 'package:geolocator/geolocator.dart';
import 'package:permission_handler/permission_handler.dart';

import '../../../../common/bloc_status.dart';
import '../../../../common/colors.dart';
import '../../../../common/constants.dart';
import '../../../../common/dialogs/dialog_provider.dart';
import '../../../../models/shipper/document/update_document_model.dart';
import '../../../../models/shipper/order/order_detail.dart';
import '../../../../services/api/shipper/payload/update_document_payload.dart';
import '../../repository/shipper_repository.dart';

part 'upload_image_state.dart';

class UploadImageCubit extends Cubit<UploadImageState> {
  UploadImageCubit() : super(const UploadImageState());

  final ShipperRepository _repository = ShipperRepository();
  Timer? _timer;

  setupImages(OrderDetail? order) {
    Map<String, Document> homeAddressImages = {};
    order?.getImageDocuments(DeliveryImageType.ADDRESS_ORDER_DELIVERY).forEach((element) {
      String key = element.id ?? '';
      homeAddressImages[key] = Document(
        id: key,
        action: '',
        latitude: element.latitude,
        longitude: element.longitude,
        typeCode: element.masterDocumentType?.code,
        url: element.mediaUrl,
      );
    });
    Map<String, Document> portraitImages = {};
    order?.getImageDocuments(DeliveryImageType.AVATAR_ORDER_DELIVERY).forEach((element) {
      String key = element.id ?? '';
      portraitImages[key] = Document(
        id: key,
        action: '',
        latitude: element.latitude,
        longitude: element.longitude,
        typeCode: element.masterDocumentType?.code,
        url: element.mediaUrl,
      );
    });
    Map<String, Document> documentImages = {};
    order?.getImageDocuments(DeliveryImageType.EXHIBIT_ORDER_DELIVERY).forEach((element) {
      String key = element.id ?? '';
      documentImages[key] = Document(
        id: key,
        action: '',
        latitude: element.latitude,
        longitude: element.longitude,
        typeCode: element.masterDocumentType?.code,
        url: element.mediaUrl,
      );
    });
    Map<String, Document> productImages = {};
    order?.getImageDocuments(DeliveryImageType.PRODUCT_ORDER_DELIVERY).forEach((element) {
      String key = element.id ?? '';
      productImages[key] = Document(
        id: key,
        action: '',
        latitude: element.latitude,
        longitude: element.longitude,
        typeCode: element.masterDocumentType?.code,
        url: element.mediaUrl,
      );
    });
    Map<String, Document> setupImages = {};
    order?.getImageDocuments(DeliveryImageType.INSTALL_ORDER_DELIVERY).forEach((element) {
      String key = element.id ?? '';
      setupImages[key] = Document(
        id: key,
        action: '',
        latitude: element.latitude,
        longitude: element.longitude,
        typeCode: element.masterDocumentType?.code,
        url: element.mediaUrl,
      );
    });
    Map<String, Document> otherImages = {};
    order?.getImageDocuments(DeliveryImageType.OTHER_ORDER_DELIVERY).forEach((element) {
      String key = element.id ?? '';
      otherImages[key] = Document(
        id: key,
        action: '',
        latitude: element.latitude,
        longitude: element.longitude,
        typeCode: element.masterDocumentType?.code,
        url: element.mediaUrl,
      );
    });
    Map<String, Document> invoiceImages = {};
    order?.getImageDocuments(DeliveryImageType.PICTURE_CUSTOMER_PAYMENT_POD).forEach((element) {
      String key = element.id ?? '';
      invoiceImages[key] = Document(
        id: key,
        action: '',
        latitude: element.latitude,
        longitude: element.longitude,
        typeCode: element.masterDocumentType?.code,
        url: element.mediaUrl,
      );
    });
    emit(state.copyWith(
      homeAddressImages: homeAddressImages,
      portraitImages: portraitImages,
      documentImages: documentImages,
      productImages: productImages,
      setupImages: setupImages,
      otherImages: otherImages,
      invoiceImages: invoiceImages,
      invoiceCheckBox: invoiceImages.isNotEmpty,
      uploadInvoiceProcess: invoiceImages.isNotEmpty ? UploadInvoiceProcess.upload : UploadInvoiceProcess.init,
    ));
  }

  uploadImage({
    required BuildContext context,
    required String key,
    required File image,
    required DeliveryImageType imageType,
    required String? orderCode,
    bool needLocation = true,
  }) async {
    if (needLocation) {
      bool permission = await LocationUtil.instance.requestPermission(context: context);
      if (permission == false && context.mounted) {
        DialogProvider.instance.showMTradeDialog(
          context: context,
          asset: "ic_mtrade_mascot_error",
          title: "Cập nhật trạng thái thất bại",
          message: "Vui lòng cho phép quyền truy cập vị trí",
          titleColor: UIColors.red,
          messageAlign: TextAlign.start,
          positiveTitle: "Cho phép truy cập",
          positiveCallback: () {
            openAppSettings();
          },
        );
        emit(state.copyWith(status: BlocStatus.failure));
        return;
      }
    }
    Map<String, Document?> initImages = _copyMap(imageType);
    List<Document?> documents = [];

    initImages[key] = null; //null -> show loading
    _emitImages(imageType, initImages); //-> show loading

    BaseModel<String> result = await _repository.uploadImageFromFile(image);
    Document? document;
    if (result.data?.isNotEmpty == true) {
      Position? position = needLocation ? await LocationUtil.instance.getCurrentLocation() : null;
      document = Document(
        action: "add",
        latitude: '${position?.latitude ?? 0}',
        longitude: '${position?.longitude ?? 0}',
        typeCode: imageType.name,
        url: result.data,
      );
      documents.add(document);
      BaseModel<List<UpdateDocumentModel>> updateDocumentResult = await _syncImagesToServer(orderCode, documents);
      if (!updateDocumentResult.status) {
        document.url = '';
      } else {
        UpdateDocumentModel? media =
            updateDocumentResult.data?.firstWhere((element) => element.mediaUrl == result.data);
        document.id = media?.id;
      }
    }
    Map<String, Document?> images = _copyMap(imageType);

    images[key] = document;
    _emitImages(imageType, images);
  }

  removeImage({required String orderCode, required String key, required DeliveryImageType imageType}) async {
    Map<String, Document?> images = _copyMap(imageType);

    images[key]?.action = "remove";

    List<Document?> documents = [images[key]];

    _syncImagesToServer(orderCode, documents);

    images.removeWhere((k, v) => k == key);

    _emitImages(imageType, images);
  }

  List<PhotoPreviewModel> convertPhotoPreview() {
    final homeAddressImages = _convertPhotoPreview(state.homeAddressImages);
    final portraitImages = _convertPhotoPreview(state.portraitImages);
    final documentImages = _convertPhotoPreview(state.documentImages);
    final productImages = _convertPhotoPreview(state.productImages);
    final setupImages = _convertPhotoPreview(state.setupImages);
    final otherImages = _convertPhotoPreview(state.otherImages);

    return [
      ...homeAddressImages,
      ...portraitImages,
      ...documentImages,
      ...productImages,
      ...setupImages,
      ...otherImages,
    ];
  }

  List<PhotoPreviewModel> _convertPhotoPreview(Map<String, Document?> data) {
    return data.entries.map((e) {
      return PhotoPreviewModel(
        key: e.value?.typeCode,
        url: e.value?.url,
      );
    }).toList();
  }

  Map<String, Document?> _copyMap(DeliveryImageType imageType) {
    if (imageType == DeliveryImageType.PICTURE_CUSTOMER_PAYMENT_POD) {
      return Map<String, Document?>.from(state.invoiceImages);
    }
    if (imageType == DeliveryImageType.ADDRESS_ORDER_DELIVERY) {
      return Map<String, Document?>.from(state.homeAddressImages);
    }
    if (imageType == DeliveryImageType.AVATAR_ORDER_DELIVERY) {
      return Map<String, Document?>.from(state.portraitImages);
    }
    if (imageType == DeliveryImageType.EXHIBIT_ORDER_DELIVERY) {
      return Map<String, Document?>.from(state.documentImages);
    }
    if (imageType == DeliveryImageType.PRODUCT_ORDER_DELIVERY) {
      return Map<String, Document?>.from(state.productImages);
    }
    if (imageType == DeliveryImageType.INSTALL_ORDER_DELIVERY) {
      return Map<String, Document?>.from(state.setupImages);
    }
    return Map<String, Document?>.from(state.otherImages);
  }

  void _emitImages(DeliveryImageType imageType, Map<String, Document?> images) {
    Map<String, String> errorFields = Map<String, String>.from(state.errorFields);
    if (imageType == DeliveryImageType.PICTURE_CUSTOMER_PAYMENT_POD) {
      errorFields.removeWhere((key, value) => key == AppConstants.invoiceImageKey);
      return emit(state.copyWith(invoiceImages: images, errorFields: errorFields));
    }
    if (imageType == DeliveryImageType.ADDRESS_ORDER_DELIVERY) {
      errorFields.removeWhere((key, value) => key == AppConstants.addressImageKey);
      return emit(state.copyWith(homeAddressImages: images, errorFields: errorFields));
    }
    if (imageType == DeliveryImageType.AVATAR_ORDER_DELIVERY) {
      errorFields.removeWhere((key, value) => key == AppConstants.portraitImageKey);
      return emit(state.copyWith(portraitImages: images, errorFields: errorFields));
    }
    if (imageType == DeliveryImageType.EXHIBIT_ORDER_DELIVERY) {
      errorFields.removeWhere((key, value) => key == AppConstants.documentImageKey);
      return emit(state.copyWith(documentImages: images, errorFields: errorFields));
    }
    if (imageType == DeliveryImageType.PRODUCT_ORDER_DELIVERY) {
      errorFields.removeWhere((key, value) => key == AppConstants.productImageKey);
      return emit(state.copyWith(productImages: images, errorFields: errorFields));
    }
    if (imageType == DeliveryImageType.INSTALL_ORDER_DELIVERY) {
      errorFields.removeWhere((key, value) => key == AppConstants.setupImageKey);
      return emit(state.copyWith(setupImages: images, errorFields: errorFields));
    }
    errorFields.removeWhere((key, value) => key == AppConstants.otherImageKey);
    return emit(state.copyWith(otherImages: images, errorFields: errorFields));
  }

  bool checkMissingImages(String paymentTypeCode, bool isPaid) {
    Map<String, String> errorFields = Map<String, String>.from(state.errorFields);
    if (!state.invoiceCheckBox && !isPaid) {
      errorFields[AppConstants.invoiceImageCheckBoxKey] = 'Hình ảnh hóa đơn là bắt buộc';
    }
    if (state.invoiceCheckBox && state.invoiceImages.isEmpty) {
      errorFields[AppConstants.invoiceImageKey] = 'Hình ảnh hóa đơn là bắt buộc';
    }
    if (state.homeAddressImages.isEmpty && paymentTypeCode == MTradePaymentType.later.code) {
      errorFields[AppConstants.addressImageKey] = 'Hình địa chỉ nhà là bắt buộc';
    }
    if (state.portraitImages.isEmpty && paymentTypeCode == MTradePaymentType.later.code) {
      errorFields[AppConstants.portraitImageKey] = 'Hình chân dung là bắt buộc';
    }
    if (state.documentImages.isEmpty) {
      errorFields[AppConstants.documentImageKey] = 'Hình giấy tờ là bắt buộc';
    }
    if (state.productImages.isEmpty) {
      errorFields[AppConstants.productImageKey] = 'Hình sản phẩm là bắt buộc';
    }
    if (state.setupImages.isEmpty && paymentTypeCode == MTradePaymentType.later.code) {
      errorFields[AppConstants.setupImageKey] = 'Hình lắp đặt là bắt buộc';
    }
    emit(state.copyWith(errorFields: errorFields));
    return state.errorFields.isNotEmpty;
  }

  Future<BaseModel<List<UpdateDocumentModel>>> _syncImagesToServer(String? orderCode, List<Document?> documents) async {
    return await _repository.updateDocument(
      UpdateDocumentPayload(
        orderCode: orderCode,
        document: documents,
      ),
    );
  }

  toggleInvoiceCheckBox() {
    Map<String, String> errorFields = Map<String, String>.from(state.errorFields);
    errorFields.removeWhere((key, value) => key == AppConstants.invoiceImageCheckBoxKey);
    errorFields.removeWhere((key, value) => key == AppConstants.invoiceImageKey);
    emit(state.copyWith(invoiceCheckBox: !state.invoiceCheckBox, errorFields: errorFields));
  }

  requestCheckInvoice(String? paymentTransactionId, Function()? onPaid) async {
    emit(state.copyWith(checkPaymentStatus: BlocStatus.loading));
    BaseModel<PaymentStatusModel> result = await _repository.getPaymentStatus(paymentTransactionId ?? '');
    if (result.status) {
      if (result.data?.status == true) {
        onPaid?.call();
      } else {
        int countdown = result.data?.recheckTime ?? 0;
        if (countdown > 0) {
          emit(state.copyWith(uploadInvoiceProcess: UploadInvoiceProcess.waiting, countDown: countdown));
          _startTimer();
        } else {
          emit(state.copyWith(uploadInvoiceProcess: UploadInvoiceProcess.upload));
        }
      }
    } else {
      emit(state.copyWith(
        checkPaymentStatus: BlocStatus.failure,
        errTitle: result.errorTitle,
        errMsg: result.errorMessage,
      ));
    }
  }

  Future<bool> requestOnlyCheckInvoice(String? paymentTransactionId) async {
    BaseModel<PaymentStatusModel> result = await _repository.getPaymentStatus(paymentTransactionId ?? '');
    if (result.status) {
      if (result.data?.status == true) {
        return true;
      }
    }
    return false;
  }

  _startTimer() {
    if (_timer != null) {
      return;
    }
    _timer = Timer.periodic(const Duration(seconds: 1), (Timer t) {
      if (state.countDown == 0) {
        t.cancel();
        _timer?.cancel();
        _timer = null;
        return;
      }
      emit(state.copyWith(countDown: state.countDown - 1));
    });
  }

  @override
  Future<void> close() {
    _timer?.cancel();
    return super.close();
  }
}
