import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter/widgets.dart';
import 'package:flutter_module/common/bloc_status.dart';
import 'package:flutter_module/common/enum/income/export_statement_type.dart';
import 'package:flutter_module/common/extension/datetime_extension.dart';
import 'package:flutter_module/common/utils/datetime_util.dart';
import 'package:flutter_module/common/utils/text_util.dart';

part 'export_statement_state.dart';

class ExportStatementCubit extends Cubit<ExportStatementState> {
  ExportStatementCubit() : super(const ExportStatementState());

  final TextEditingController fromDateController = TextEditingController();
  final TextEditingController toDateController = TextEditingController();

  initData({
    String? email,
  }) {
    emit(state.copyWith(
      email: email,
    ));
  }

  onTypeChanged(ExportStatementType type) {
    emit(state.copyWith(
      type: type,
    ));
    _validateErrorFields(fields: _validateDateFields());
  }

  onFromDateChanged(DateTime? dt) {
    if (dt == null) {
      return;
    }
    fromDateController.text = DateTimeUtil.getString(
      dt,
      format: DateTimeFormat.dd__MM__yyyy,
    );
    emit(state.copyWith(
      fromDate: dt.dateOnly(),
    ));
    _validateErrorFields(fields: _validateDateFields());
  }

  onToDateChanged(DateTime? dt) {
    if (dt == null) {
      return;
    }
    toDateController.text = DateTimeUtil.getString(
      dt,
      format: DateTimeFormat.dd__MM__yyyy,
    );
    emit(state.copyWith(
      toDate: dt.dateOnly(),
    ));
    _validateErrorFields(fields: _validateDateFields());
  }

  _validateDateFields({bool forceCheckFromAndToDate = false}) {
    final errorFields = {...state.errorFields};
    final key = ExportStatementFields.date.name;

    if (state.type == null) {
      errorFields[key] = 'Thông tin này không được bỏ trống';
    } else if (state.type?.isCustom == true && forceCheckFromAndToDate) {
      final fromDate = state.fromDate;
      final toDate = state.toDate;
      if (fromDate == null || toDate == null) {
        errorFields[key] = 'Thông tin này không được bỏ trống';
      } else {
        final isAfter = !fromDate.isBefore(toDate);
        if (isAfter) {
          errorFields[key] = 'Thời gian bắt đầu phải nhỏ hơn thời gian kết thúc';
        }
      }
    } else {
      errorFields.removeWhere((k, v) => k == key);
    }

    return errorFields;
  }

  _validateEmailFields() {
    final errorFields = {...state.errorFields};
    final key = ExportStatementFields.email.name;

    if (TextUtils.isEmpty(state.email)) {
      errorFields[key] = 'Thông tin này không được bỏ trống';
    } else {
      errorFields.removeWhere((k, v) => k == key);
    }

    return errorFields;
  }

  _validateErrorFields({Map<String, String>? fields}) {
    final errorFields = fields ?? {...state.errorFields};
    final enabledNextStep = errorFields.isEmpty;
    emit(state.copyWith(
      enabledNextStep: enabledNextStep,
      errorFields: errorFields,
    ));
    return enabledNextStep;
  }

  _validateAll() {
    final errorFields = {...state.errorFields};

    errorFields.addAll(_validateDateFields(forceCheckFromAndToDate: true));
    errorFields.addAll(_validateEmailFields());

    return _validateErrorFields(fields: errorFields);
  }

  void submit({
    Function()? onSuccess,
  }) {
    if (!_validateAll()) {
      return;
    }
    onSuccess?.call();
  }

  @override
  Future<void> close() {
    fromDateController.dispose();
    toDateController.dispose();
    return super.close();
  }
}
