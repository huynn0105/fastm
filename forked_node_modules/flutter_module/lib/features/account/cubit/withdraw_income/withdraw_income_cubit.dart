import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter/material.dart';
import 'package:flutter_module/common/bloc_status.dart';
import 'package:flutter_module/common/utils/format_util.dart';
import 'package:flutter_module/common/utils/text_util.dart';
import 'package:flutter_module/features/account/repository/income_repository.dart';
import 'package:flutter_module/models/income/bank_model.dart';
import 'package:flutter_module/models/income/check_withdraw_info_model.dart';
import 'package:flutter_module/models/income/withdraw_info_model.dart';
import 'package:flutter_module/services/api/income/payload/get_withdraw_fee_payload.dart';

part 'withdraw_income_state.dart';

class WithdrawIncomeCubit extends Cubit<WithdrawIncomeState> {
  WithdrawIncomeCubit() : super(const WithdrawIncomeState());

  final _repository = IncomeRepository();

  final TextEditingController moneyController = TextEditingController();

  fetchData() async {
    getWithdrawInfo();
    checkWithdrawInfo();
  }

  getWithdrawInfo() async {
    emit(state.copyWith(
      status: BlocStatus.loading,
    ));

    final result = await _repository.getWithdrawInfo();

    if (result.status) {
      emit(state.copyWith(
        status: BlocStatus.success,
        withdrawInfo: result.data,
        enabledNextStep: result.data?.bankingPicked?.isNotEmpty == true,
      ));
    } else {
      emit(state.copyWith(
        status: BlocStatus.failure,
      ));
    }
  }

  checkWithdrawInfo() async {
    emit(state.copyWith(
      checkStatus: BlocStatus.loading,
    ));

    final result = await _repository.checkWithdrawInfo();

    if (result.status) {
      emit(state.copyWith(
        checkStatus: BlocStatus.success,
        checkWithdrawInfo: result.data,
      ));
    } else {
      emit(state.copyWith(
        checkStatus: BlocStatus.failure,
        errorMessage: result.errorMessage,
      ));
    }
  }

  getWithdrawFee() async {
    if (state.transactionMoney == null || state.transactionBankID == null) {
      return;
    }
    emit(state.copyWith(
      feeStatus: BlocStatus.loading,
    ));

    final result = await _repository.getWithdrawFee(
      GetWithdrawFeePayload(
        amount: state.transactionMoney?.toInt().toString(),
      ),
    );

    if (result.status) {
      emit(state.copyWith(
        feeStatus: BlocStatus.success,
        transactionFee: result.data?.withdrawalFee,
      ));
    } else {
      emit(state.copyWith(
        feeStatus: BlocStatus.failure,
        errorMessage: result.errorMessage,
      ));
    }
  }

  changeTransactionMoney(String? value) {
    emit(state.copyWith(
      transactionMoney: TextUtils.parseDouble(value) ?? 0,
    ));
    final result = _validateErrorFields(fields: _validateMoneyField());
    if (result == true) {
      getWithdrawFee();
    }
  }

  selecteTransactionMoney(double? value) {
    emit(state.copyWith(
      transactionMoney: value,
    ));
    final result = _validateErrorFields(fields: _validateMoneyField());
    if (result == true) {
      getWithdrawFee();
    }
  }

  selectTransactionBank(BankModel bank) {
    if (bank.id == state.transactionBankID) {
      return;
    }
    emit(state.copyWith(
      transactionBankID: bank.id,
    ));
    final result = _validateErrorFields(fields: _validateBankField());
    if (result == true) {
      getWithdrawFee();
    }
  }

  _validateMoneyField() {
    final errorFields = {...state.errorFields};
    final key = WithdrawIncomeFields.money.name;

    final availableBalance = state.withdrawInfo?.availabilityMoney ?? 0;
    final transactionMoney = state.transactionMoney ?? 0;
    final minTransactionMoney = state.minTransactionMoney;

    if (state.transactionMoney == null) {
      errorFields[key] = 'Thông tin này không được bỏ trống';
    } else if (transactionMoney < minTransactionMoney) {
      errorFields[key] = 'Số tiền rút tối thiểu là ${FormatUtil.currencyDoubleFormat(minTransactionMoney)}';
    } else if (transactionMoney > availableBalance) {
      errorFields[key] = 'Số tiền rút không được vượt quá số dư khả dụng';
    } else {
      errorFields.removeWhere((k, v) => k == key);
    }

    return errorFields;
  }

  _validateBankField() {
    final errorFields = {...state.errorFields};
    final key = WithdrawIncomeFields.bank.name;

    if (state.transactionBankID == null) {
      errorFields[key] = 'Vui lòng chọn tài khoản ngân hàng';
    } else {
      errorFields.removeWhere((k, v) => k == key);
    }

    return errorFields;
  }

  bool _validateErrorFields({Map<String, String>? fields}) {
    final errorFields = fields ?? {...state.errorFields};
    final enabledNextStep = errorFields.isEmpty;

    ///
    emit(state.copyWith(
      enabledNextStep: enabledNextStep,
      errorFields: errorFields,
    ));
    return enabledNextStep;
  }

  bool validateAll() {
    final errorFields = {...state.errorFields};

    errorFields.addAll(_validateMoneyField());
    errorFields.addAll(_validateBankField());

    return _validateErrorFields(fields: errorFields);
  }

  resetSelection() {
    moneyController.clear();
    emit(state.copyWith(
      clear: true,
      enabledNextStep: false,
    ));
  }

  @override
  Future<void> close() {
    moneyController.dispose();
    return super.close();
  }
}
