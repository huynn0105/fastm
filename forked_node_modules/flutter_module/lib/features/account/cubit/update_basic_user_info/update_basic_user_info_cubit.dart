import 'package:bloc/bloc.dart';
import 'package:flutter_module/common/bloc_status.dart';
import 'package:flutter_module/common/bottom_sheet/wrapper/data_wrapper.dart';
import 'package:flutter_module/common/utils/validation_util.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter/cupertino.dart';
import 'package:flutter_module/common/enum/mfast/gender_type.dart';
import 'package:flutter_module/di/get_it.dart';
import 'package:flutter_module/features/account/cubit/user/user_cubit.dart';
import 'package:flutter_module/features/account/repository/user_repository.dart';
import 'package:flutter_module/features/mfast/repository/mfast_repository.dart';
import 'package:flutter_module/models/user/user_meta_data_model.dart';
import 'package:flutter_module/services/api/user/payload/check_duplicate_email_payload.dart';
import 'package:flutter_module/services/api/user/payload/update_user_meta_data_payload.dart';

part 'update_basic_user_info_state.dart';

class UpdateBasicUserInfoCubit extends Cubit<UpdateBasicUserInfoState> {
  UpdateBasicUserInfoCubit() : super(const UpdateBasicUserInfoState());

  final _repository = UserRepository();
  final _mfastRepository = MFastRepository();

  final TextEditingController emailController = TextEditingController();
  final TextEditingController contactAddressController = TextEditingController();
  final TextEditingController districtAddressController = TextEditingController();

  onInit({UserMetaDataModel? userMetaData}) async {
    if (userMetaData == null) {
      return;
    }

    fetchLocation();

    final gender = userMetaData.getGenderType();
    emailController.text = userMetaData.emailAddress ?? '';
    contactAddressController.text = userMetaData.addressCurrent ?? '';
    districtAddressController.text = userMetaData.addressCurrentDistrict ?? '';

    emit(state.copyWith(
      gender: gender,
    ));
  }

  fetchLocation() async {
    final result = await _mfastRepository.getDistricts();
    emit(state.copyWith(
      districtAddresses: result.data,
    ));
  }

  onChangedGender(GenderType gender) {
    emit(state.copyWith(
      gender: gender,
    ));
  }

  onEmailChanged(String value) {
    _validateErrorFields(fields: _validateEmailField());
  }

  onContactAddressChanged(String value) {
    _validateErrorFields(fields: _validateContactAddress());
  }

  onDistrictAddressChanged(DataWrapper location) {
    districtAddressController.text = location.value ?? '';
    _validateErrorFields(fields: _validateDistrictAddressField());
  }

  _validateEmailField({
    String? Function()? otherError,
  }) {
    final errorFields = {...state.errorFields};
    final key = UpdateUserInfoField.email.name;
    final text = emailController.text.trim();

    if (text.isEmpty) {
      errorFields[key] = 'Thông tin này là bắt buộc.';
    } else if (EmailInputValidation.dirty(value: text).isNotValid) {
      errorFields[key] = 'Email không hợp lệ.';
    } else if (otherError != null) {
      final error = otherError();
      if (error != null) {
        errorFields[key] = error;
      } else {
        errorFields.removeWhere((k, v) => k == key);
      }
    } else {
      errorFields.removeWhere((k, v) => k == key);
    }

    return errorFields;
  }

  _validateContactAddress() {
    final errorFields = {...state.errorFields};
    final key = UpdateUserInfoField.contactAddress.name;
    final text = contactAddressController.text.trim();

    if (text.isEmpty) {
      errorFields[key] = 'Thông tin này là bắt buộc.';
    } else {
      errorFields.removeWhere((k, v) => k == key);
    }

    return errorFields;
  }

  _validateDistrictAddressField() {
    final errorFields = {...state.errorFields};
    final key = UpdateUserInfoField.districtAddress.name;
    final text = districtAddressController.text.trim();

    if (text.isEmpty) {
      errorFields[key] = 'Thông tin này là bắt buộc.';
    } else {
      errorFields.removeWhere((k, v) => k == key);
    }

    return errorFields;
  }

  _validateErrorFields({required Map<String, String>? fields}) {
    final errorFields = {...(fields ?? state.errorFields)};
    final enabledNextStep = errorFields.isEmpty;
    emit(state.copyWith(
      errorFields: errorFields,
      enabledNextStep: enabledNextStep,
    ));
    return enabledNextStep;
  }

  validateAll() {
    final errorFields = {...state.errorFields};

    errorFields.addAll(_validateEmailField());
    errorFields.addAll(_validateDistrictAddressField());

    return _validateErrorFields(fields: errorFields);
  }

  Future<bool> checkDupEmail() async {
    emit(state.copyWith(
      checkDupEmailStatus: BlocStatus.loading,
    ));

    final result = await _repository.checkDuplicateEmail(
      payload: CheckDuplicateEmailPayload(
        email: emailController.text,
      ),
    );

    _validateErrorFields(
      fields: _validateEmailField(
        otherError: () {
          String? error;
          if (!result.status) {
            error = 'Email này đã tồn tại trên hệ thống, vui lòng kiểm tra lại hoặc sử dụng địa chỉ email khác';
          }
          return error;
        },
      ),
    );

    if (result.status) {
      emit(state.copyWith(
        checkDupEmailStatus: BlocStatus.success,
      ));
    } else {
      emit(state.copyWith(
        checkDupEmailStatus: BlocStatus.failure,
        errorMessage: result.errorMessage,
      ));
    }

    return result.status;
  }

  submit({
    bool? isEmailUpdated,
  }) async {
    if (!validateAll()) {
      return;
    }

    emit(state.copyWith(
      submitStatus: BlocStatus.loading,
    ));

    final updateResult = await _repository.updateUserMetaData(
      payload: UpdateUserMetaDataPayload(
        user: UserMetaDataModel(
          gender: state.gender?.id,
          emailAddress: isEmailUpdated == true ? emailController.text : null,
          addressCurrent: contactAddressController.text,
          addressCurrentDistrict: districtAddressController.text,
        ),
      ),
    );

    if (updateResult.status) {
      getItInstance.get<UserCubit>().setUserMetaData(updateResult.data);
      emit(state.copyWith(
        submitStatus: BlocStatus.success,
        isEmailUpdated: isEmailUpdated,
      ));
    } else {
      emit(state.copyWith(
        submitStatus: BlocStatus.failure,
        errorMessage: updateResult.errorMessage,
      ));
    }
  }

  @override
  Future<void> close() {
    contactAddressController.dispose();
    emailController.dispose();
    districtAddressController.dispose();
    return super.close();
  }
}
