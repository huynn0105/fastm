import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter_module/features/account/repository/income_repository.dart';
import 'package:flutter_module/models/authentication/otp_model.dart';
import 'package:flutter_module/services/api/income/payload/send_withdraw_otp_payload.dart';
import 'package:flutter_module/services/api/income/payload/submit_withdraw_payload.dart';

import '../../../../common/bloc_status.dart';
import '../../../../common/constants.dart';
import '../../../../common/enum/error_code_type.dart';

part 'withdraw_income_otp_state.dart';

class WithdrawIncomeOTPCubit extends Cubit<WithdrawIncomeOTPState> {
  WithdrawIncomeOTPCubit() : super(WithdrawIncomeOTPState());

  final _repository = IncomeRepository();

  requestOtp({
    required String phoneNumber,
    bool isRetry = false,
    String type = 'voice',
  }) async {
    state.errorFields.removeWhere((key, value) => key == AppConstants.otpKey);
    emit(state.copyWith(
      requestedOtp: true,
    ));
    final result = await _repository.sendWithdrawOTP(SendWithdrawOTPPayload(
      mobilePhone: phoneNumber,
      isRetry: isRetry,
      type: type,
    ));
    emit(state.copyWith(
      otpModel: result.data,
    ));
  }

  otpChange(String text) {
    state.errorFields.removeWhere((key, value) => key == AppConstants.otpKey);
    validateData();
  }

  validateData() {
    emit(state.copyWith(completeStatus: BlocStatus.initial));
  }

  verifyOtp({
    required String mobilePhone,
    required String otpCode,
    required String transactionBankID,
    required String transactionMoney,
    required double? latitude,
    required double? longitude,
  }) async {
    emit(state.copyWith(
      completeStatus: BlocStatus.loading,
    ));
    final result = await _repository.submitWithdraw(
      SubmitWithdrawPayload(
        mobilePhone: mobilePhone,
        otpCode: otpCode,
        bankingId: transactionBankID,
        amount: transactionMoney,
        location: LocationTrackingModel(
          key: 'LOCATION_KEY',
          location: LocationModel(
            latitude: latitude,
            longitude: longitude,
          ),
        ),
      ),
    );
    if (result.status) {
      emit(state.copyWith(
        completeStatus: BlocStatus.success,
        errorMsg: result.errorMessage,
      ));
    } else {
      handleError(
        result.errorCode,
        result.errorMessage,
      );
    }
  }

  handleError(String? errorCode, String? errorMessage) async {
    if (errorCode == ErrorCodeType.wrongOtp.value) {
      state.errorFields[AppConstants.otpKey] = errorMessage ?? '';
      emit(state.copyWith(
        completeStatus: BlocStatus.failure,
      ));
    }
    if (errorCode == ErrorCodeType.userNotExist.value) {
      emit(state.copyWith(
        isRegister: true,
      ));
    } else {
      emit(state.copyWith(
        completeStatus: BlocStatus.failure,
        errorMsg: errorMessage,
      ));
    }
  }
}
