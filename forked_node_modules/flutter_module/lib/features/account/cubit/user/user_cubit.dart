import 'dart:io';

import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter_module/app_data.dart';
import 'package:flutter_module/common/bloc_status.dart';
import 'package:flutter_module/common/extension/list_extension.dart';
import 'package:flutter_module/common/utils/image_util.dart';
import 'package:flutter_module/common/utils/text_util.dart';
import 'package:flutter_module/features/account/repository/user_repository.dart';
import 'package:flutter_module/features/chat/repository/chat_repository.dart';
import 'package:flutter_module/models/chat/message/author_model.dart';
import 'package:flutter_module/models/personal_setting/personal_setting_model.dart';
import 'package:flutter_module/models/user/user_delete_model.dart';
import 'package:flutter_module/models/user/user_info_model.dart';
import 'package:flutter_module/models/user/user_meta_data_model.dart';
import 'package:flutter_module/services/api/chat/payload/file_upload_payload.dart';
import 'package:flutter_module/services/api/user/payload/update_user_meta_data_payload.dart';
import 'package:flutter_module/services/api/user/payload/update_user_payload.dart';
import 'package:flutter_module/services/local/local_data_helper.dart';

import '../../../../models/user/referral_info_model.dart';

part 'user_state.dart';

class UserCubit extends Cubit<UserState> {
  UserCubit() : super(const UserState());

  final _repository = UserRepository();

  Future fetchData() async {
    await Future.wait([
      getUserInfo(),
      getRefLink(),
      getUserMetaData(),
      getUserSetting(),
    ]);
    getUserDelete();
  }

  Future<void> getUserSetting() async {
    emit(state.copyWith(
      status: BlocStatus.loading,
    ));
    final result = await _repository.getPersonalSetting();

    if (result.status) {
      emit(state.copyWith(
        status: BlocStatus.success,
        userSettingData: result.data,
      ));
    } else {
      emit(state.copyWith(
        status: BlocStatus.failure,
      ));
    }
  }

  Future getUserInfo() async {
    emit(state.copyWith(
      status: BlocStatus.loading,
    ));

    final result = await _repository.getUserInfo();

    if (result.status) {
      final user = result.data;
      await AppData.instance.loginFirebaseToken(result.data?.firebaseToken ?? '');
      AppData.instance.author = user == null
          ? null
          : AppData.instance.author == null
              ? AuthorModel(
                  id: user.id,
                  fullName: user.fullName,
                  avatar: user.avatarImage,
                )
              : AppData.instance.author?.copyWith(
                  id: user.id,
                  avatar: user.avatarImage,
                );
      if (user != null) {
        _repository.updateFirebaseUser(
          userID: user.id ?? '',
          user: user,
        );
      }
      emit(state.copyWith(
        status: BlocStatus.success,
        userInfo: result.data,
      ));
    } else {
      emit(state.copyWith(
        status: BlocStatus.failure,
      ));
    }
  }

  Future getRefLink() async {
    final result = await _repository.getReferralInfo();
    emit(state.copyWith(
      referral: result.data,
    ));
  }

  Future getUserMetaData() async {
    emit(state.copyWith(
      status: BlocStatus.loading,
    ));

    final result = await _repository.getUserMetaData();

    if (result.status) {
      final user = result.data;
      AppData.instance.saleName = user?.countryIdName;
      AppData.instance.saleEmail = user?.emailAddress;
      AppData.instance.salePhoneNumber = user?.mobilePhone;
      AppData.instance.author = AppData.instance.author == null
          ? AuthorModel(
              fullName: user?.fullName,
            )
          : AppData.instance.author?.copyWith(
              fullName: user?.fullName,
            );
      emit(state.copyWith(
        status: BlocStatus.success,
        userMetaData: result.data,
      ));
    } else {
      emit(state.copyWith(
        status: BlocStatus.failure,
      ));
    }
  }

  updateUserMetaData(UpdateUserMetaDataPayload payload) async {
    emit(state.copyWith(
      status: BlocStatus.loading,
    ));

    final result = await _repository.updateUserMetaData(payload: payload);

    if (result.status) {
      emit(state.copyWith(
        status: BlocStatus.success,
        userMetaData: result.data,
      ));
    } else {
      emit(state.copyWith(
        status: BlocStatus.failure,
      ));
    }
  }

  setUserMetaData(UserMetaDataModel? data) {
    emit(state.copyWith(
      userMetaData: data,
    ));
  }

  updateAvatar({
    required File file,
    required Function() onSuccess,
  }) async {
    emit(state.copyWith(
      avatarStatus: BlocStatus.loading,
    ));

    final compressedXFile = await ImageUtil.compressImage(
      file: file,
      width: 128,
      height: 128,
      quality: 50,
    );

    if (compressedXFile == null || TextUtils.isEmpty(compressedXFile.path)) {
      emit(state.copyWith(
        avatarStatus: BlocStatus.failure,
        errorMessage: 'Đã có lỗi xảy ra',
      ));
      return;
    }

    file = File(compressedXFile.path);
    final uploadResult = await ChatRepository().uploadMultiFile(
      payload: FileUploadPayload(
        files: [file],
      ),
    );
    final url = uploadResult.data?.getFirst()?.url ?? '';

    if (url.isEmpty) {
      emit(state.copyWith(
        avatarStatus: BlocStatus.failure,
        errorMessage: 'Đã có lỗi xảy ra',
      ));
      return;
    }

    final result = await _repository.updateUser(
      payload: UpdateUserPayload(
        avatarImage: url,
      ),
    );

    if (result.status) {
      onSuccess();
      emit(state.copyWith(
        avatarStatus: BlocStatus.success,
        userInfo: state.userInfo?.copyWith(
          avatarImage: url,
        ),
      ));
    } else {
      emit(state.copyWith(
        avatarStatus: BlocStatus.failure,
        errorMessage: result.errorMessage,
      ));
    }
  }

  Future getUserDelete() async {
    final result = await _repository.getUserDelete();
    if (result.status) {
      emit(state.copyWith(
        userDelete: result.data,
      ));
    }
  }

  clearData() {
    emit(const UserState());
  }
}
