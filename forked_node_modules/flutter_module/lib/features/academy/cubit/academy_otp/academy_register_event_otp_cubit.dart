import 'dart:async';
import 'dart:convert';

import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter/material.dart';
import 'package:flutter_module/app_data.dart';
import 'package:flutter_module/common/enum/error_code_type.dart';
import 'package:flutter_module/models/academy/event/academy_event_checkout_model.dart';

import '../../../../services/api/academy/payload/academy_register_event_payload.dart';
import '../../repository/academy_repository.dart';
import '../../../../services/api/academy/payload/request_otp_payload.dart';
import '../../../../common/bloc_status.dart';
import '../../../../common/constants.dart';
import '../../../../models/base_model.dart';

part 'academy_register_event_otp_state.dart';

class AcademyRegisterEventOTPCubit extends Cubit<AcademyRegisterEventOTPState> {
  AcademyRegisterEventOTPCubit() : super(AcademyRegisterEventOTPState());

  final AcademyRepository repository = AcademyRepository();
  final TextEditingController otpController = TextEditingController();

  Timer? _timer;

  init({required String phoneNumber}) {
    _startTimer();
    requestOtp(phoneNumber: phoneNumber);
    emit(state.copyWith(status: BlocStatus.success));
  }

  requestOtp({required String phoneNumber, bool isRetry = false, String? type}) async {
    otpController.clear();
    state.errorFields.removeWhere((key, value) => key == AppConstants.otpKey);
    validateData();

    emit(state.copyWith(
      otpStatus: BlocStatus.loading,
      countDown: AppConstants.otpCountdown,
    ));

    BaseModel<bool> result = await repository.requestOTP(
      payload: AcademyRequestOTPPayload(
        mobilePhone: phoneNumber,
        type: type,
        isRetry: isRetry,
      ),
    );

    _startTimer();

    if (!result.status) {
      emit(state.copyWith(
        otpStatus: BlocStatus.failure,
        errMsg: result.errorMessage,
      ));
    } else {
      emit(state.copyWith(otpStatus: BlocStatus.success));
    }
  }

  _startTimer() {
    if (_timer != null) {
      return;
    }
    _timer = Timer.periodic(const Duration(seconds: 1), (Timer t) {
      if (state.countDown == 1) {
        t.cancel();
        _timer?.cancel();
        _timer = null;
        return;
      }
      emit(state.copyWith(countDown: state.countDown - 1));
    });
  }

  validateData() {
    emit(state.copyWith(completeStepStatus: BlocStatus.initial));
  }

  handleError(String? errorCode, String? errorMessage) {
    if (errorCode == ErrorCodeType.wrongOtp.value) {
      state.errorFields[AppConstants.otpKey] = errorMessage ?? '';
      validateData();
    } else {
      state.errorFields[AppConstants.otpKey] = errorMessage ?? '';
      emit(state.copyWith(completeStepStatus: BlocStatus.failure));
    }
  }

  otpChange(String text) {
    state.errorFields.removeWhere((key, value) => key == AppConstants.otpKey);
    validateData();
  }

  _checkFields() {
    if (otpController.text.isEmpty) {
      state.errorFields[AppConstants.otpKey] = 'Thông tin này là bắt buộc';
    }
  }

  register({
    required String eventID,
    required String phoneNumber,
  }) async {
    _checkFields();
    if (state.errorFields.isNotEmpty) {
      validateData();
      return;
    }

    emit(state.copyWith(completeStepStatus: BlocStatus.loading));

    BaseModel<bool> result = await repository.registerEvent(
      payload: AcademyRegisterEventPayload(
        eventID: eventID,
        mobilePhone: phoneNumber,
        otpCode: otpController.text,
      ),
    );

    if (result.status) {
      emit(state.copyWith(completeStepStatus: BlocStatus.success));
    } else {
      handleError(result.errorCode, result.errorMessage);
    }
  }

  checkIn({
    required String eventID,
    required String phoneNumber,
  }) async {
    _checkFields();
    if (state.errorFields.isNotEmpty) {
      validateData();
      return;
    }

    emit(state.copyWith(completeStepStatus: BlocStatus.loading));

    BaseModel<bool> result = await repository.checkInEvent(
      payload: AcademyRegisterEventPayload(
        eventID: eventID,
        mobilePhone: phoneNumber,
        otpCode: otpController.text,
      ),
    );

    if (result.status) {
      emit(state.copyWith(completeStepStatus: BlocStatus.success));
    } else {
      handleError(result.errorCode, result.errorMessage);
    }
  }

  checkOut({required String eventID, required String phoneNumber, isRequireOTP = true}) async {
    if (isRequireOTP) {
      _checkFields();
    }
    if (state.errorFields.isNotEmpty && isRequireOTP) {
      validateData();
      return;
    }

    emit(state.copyWith(completeStepStatus: BlocStatus.loading));

    BaseModel<AcademyEventCheckOutModel> result = await repository.checkOutEvent(
      payload: AcademyRegisterEventPayload(
        eventID: eventID,
        mobilePhone: phoneNumber,
        otpCode: otpController.text,
      ),
    );

    if (result.status) {
      AppData.instance.eventCheckOut = result.data;
      emit(state.copyWith(completeStepStatus: BlocStatus.success));
    } else {
      handleError(result.errorCode, result.errorMessage);
    }
  }

  @override
  void emit(AcademyRegisterEventOTPState state) {
    if (!isClosed) {
      super.emit(state);
    }
  }

  @override
  Future<void> close() {
    otpController.dispose(); //pin code widget disposed
    _timer?.cancel();
    _timer = null;
    return super.close();
  }
}
