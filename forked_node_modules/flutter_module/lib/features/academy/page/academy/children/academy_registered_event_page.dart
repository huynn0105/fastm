import 'package:auto_route/auto_route.dart';
import 'package:dotted_dashed_line/dotted_dashed_line.dart';
import 'package:flutter/cupertino.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:flutter_module/common/bloc_status.dart';
import 'package:flutter_module/common/enum/academy/registered_event_status.dart';
import 'package:flutter_module/common/extension/datetime_extension.dart';
import 'package:flutter_module/common/size.dart';
import 'package:flutter_module/common/widgets/loading.dart';
import 'package:flutter_module/common/widgets/loadmore_widget.dart';
import 'package:flutter_module/features/academy/cubit/registerd_event/academy_registered_event_cubit.dart';
import 'package:flutter_module/features/academy/page/academy/components/empty_event_component.dart';
import 'package:flutter_module/features/academy/page/academy/items/registered_event_item.dart';

import '../../../../../common/colors.dart';

@RoutePage()
class AcademyRegisteredEventPage extends StatelessWidget implements AutoRouteWrapper {
  const AcademyRegisteredEventPage({super.key, required this.status});
  final String? status;

  @override
  Widget wrappedRoute(BuildContext context) {
    return BlocProvider(
      create: (context) => AcademyRegisteredEventCubit(status!),
      child: this,
    );
  }

  @override
  Widget build(BuildContext context) {
    return BlocBuilder<AcademyRegisteredEventCubit, AcademyRegisteredEventState>(
      builder: (context, state) {
        if (state.status.isInitial) {
          final cubit = context.read<AcademyRegisteredEventCubit>();
          cubit.updatePayload(type: status!);
          cubit.fetchData();
        }
        if (state.status.showLoading) {
          return const SizedBox(
            width: double.infinity,
            height: 144,
            child: LoadingWidget.withoutText(),
          );
        }

        if (state.registeredEvents.isEmpty) {
          return LoadMoreWidget(
            onLoadMore: () {
              final cubit = context.read<AcademyRegisteredEventCubit>();
              return cubit.loadMoreData();
            },
            onRefresh: () {
              final cubit = context.read<AcademyRegisteredEventCubit>();
              return cubit.refreshData();
            },
            child: Center(
              child: EmptyEventComponent(
                title: status == RegisteredEventStatus.startSoon.name
                    ? "Không có sự kiện đăng ký nào sắp/đang diễn ra"
                    : "Không có sự kiện đăng ký nào đã kết thúc",
              ),
            ),
          );
        }

        return Stack(
          children: [
            Positioned(
              left: 78,
              top: 0,
              bottom: 0,
              child: Visibility(
                visible: state.registeredEvents.isNotEmpty,
                child: const DottedDashedLine(
                  height: double.infinity,
                  width: 1,
                  axis: Axis.vertical,
                  dashHeight: 5,
                  dashWidth: 5,
                  dashSpace: 5,
                  dashColor: UIColors.gray,
                ),
              ),
            ),
            LoadMoreWidget(
              onLoadMore: () {
                final cubit = context.read<AcademyRegisteredEventCubit>();
                return cubit.loadMoreData();
              },
              onRefresh: () {
                final cubit = context.read<AcademyRegisteredEventCubit>();
                return cubit.refreshData();
              },
              child: ListView.builder(
                padding: EdgeInsets.only(bottom: AppSize.instance.safeBottom),
                itemBuilder: (context, index) {
                  final item = state.registeredEvents[index];
                  final isLastItem = index == state.registeredEvents.length - 1;
                  late bool isNewDate;

                  if (index > 0) {
                    final date = DateTime.parse(item.eventStart ?? '').dateOnly();

                    final prevItem = state.registeredEvents[index - 1];
                    final prevDate = DateTime.parse(prevItem.eventStart ?? '').dateOnly();

                    isNewDate = date.difference(prevDate).inDays != 0;
                  } else {
                    isNewDate = true;
                  }

                  return RegisteredEventItem(
                    index: index,
                    item: item,
                    isNewDate: isNewDate,
                    isLastItem: isLastItem,
                  );
                },
                itemCount: state.registeredEvents.length,
              ),
            ),
          ],
        );
      },
    );
  }
}
