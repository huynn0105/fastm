import 'dart:math';

import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter_module/common/bloc_status.dart';
import 'package:flutter_module/common/utils/count_down_util.dart';
import 'package:flutter_module/common/utils/datetime_util.dart';
import 'package:flutter_module/features/personal_setting/repository/time_checking_config_repository.dart';
import 'package:flutter_module/models/mfast/time_checking/statistic_config_model.dart';
import 'package:flutter_module/models/mfast/time_checking/time_checking_config_model.dart';

part 'time_checking_config_state.dart';

class TimeCheckingConfigCubit extends Cubit<TimeCheckingConfigState> {
  TimeCheckingConfigCubit() : super(const TimeCheckingConfigState());

  final _repository = TimeCheckingConfigRepository();

  CountDownUtil? countdownUtil;

  Future fetchData() async {
    await Future.wait([
      _getTimeCheckingConfig(),
      _getStatisticConfig(),
    ]);
  }

  Future _getTimeCheckingConfig() async {
    final result = await _repository.getTimeCheckingConfig();
    if (result.status) {
      startCountDown(result.data?.checkConfig?.duration ?? 0);
      emit(state.copyWith(
        timeChecking: result.data,
      ));
    } else {
      cancelCountDown();
      emit(state.copyWith(
        clearTimeChecking: true,
        showTimeCheckingCountDown: false,
      ));
    }
  }

  Future _getStatisticConfig() async {
    final result = await _repository.getStatisticConfig();
    if (result.status) {
      emit(state.copyWith(
        statistic: result.data,
      ));
    } else {
      emit(state.copyWith(
        clearStatistic: true,
      ));
    }
  }

  startCountDown(int seconds) {
    cancelCountDown();
    if (seconds > 0) {
      countdownUtil = CountDownUtil(seconds: seconds);
      countdownUtil!.start(
        onCompleted: cancelCountDown,
      );
    }
    emit(state.copyWith(
      showTimeCheckingCountDown: seconds > 0,
    ));
  }

  pauseCountDown() {
    countdownUtil?.pause();
  }

  resumeCountDown() {
    final seconds = state.timeChecking?.checkConfig?.duration ?? 0;
    final remains = DateTimeUtil.getRemainSeconds(
      state.timeChecking?.checkConfig?.endTime,
      format: DateTimeFormat.yyyy_MM_dd_HH_mm_ss,
      isFromUtc: false,
    );
    if (remains < seconds) {
      startCountDown(remains);
    } else {
      cancelCountDown();
    }
  }

  cancelCountDown() {
    countdownUtil?.cancel();
    emit(state.copyWith(
      showTimeCheckingCountDown: false,
    ));
  }

  @override
  Future<void> close() {
    cancelCountDown();
    return super.close();
  }

  void clearData() {
    emit(const TimeCheckingConfigState());
  }
}
