import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter/cupertino.dart';
import 'package:flutter_module/common/bloc_status.dart';
import 'package:flutter_module/common/enum/tracking_event_type.dart';
import 'package:flutter_module/di/get_it.dart';
import 'package:flutter_module/features/account/cubit/user/user_cubit.dart';
import 'package:flutter_module/features/account/repository/user_repository.dart';
import 'package:flutter_module/features/app_cubit.dart';
import 'package:flutter_module/models/user/user_meta_data_model.dart';
import 'package:flutter_module/services/api/user/payload/check_duplicate_nick_name_payload.dart';
import 'package:flutter_module/services/api/user/payload/update_user_meta_data_payload.dart';

part 'edit_nick_name_state.dart';

class EditNickNameCubit extends Cubit<EditNickNameState> {
  EditNickNameCubit() : super(const EditNickNameState());

  final _repository = UserRepository();
  final TextEditingController nickNameController = TextEditingController();

  initNickName(String value) {
    nickNameController.text = value;
  }

  onNickNameChanged(String value) async {
    _validateErrorFields(fields: _validateNickName());
  }

  _validateNickName() {
    final errorFields = {...state.errorFields};
    final key = EditNickNameFields.nickName.name;

    if (nickNameController.text.isEmpty) {
      errorFields[key] = 'Thông tin này là bắt buộc';
    } else if (nickNameController.text.contains(' ')) {
      errorFields[key] = 'Nickname không được bao gồm khoảng trắng';
    } else if (nickNameController.text.length < 5 || nickNameController.text.length > 20) {
      errorFields[key] = 'Độ dài từ 5 đến 20 ký tự';
    } else {
      errorFields.removeWhere((k, v) => k == key);
    }

    return errorFields;
  }

  _validateErrorFields({Map<String, String>? fields}) {
    final errorFields = {...(fields ?? state.errorFields)};
    final enabledNextStep = errorFields.isEmpty;
    emit(state.copyWith(
      errorFields: errorFields,
      enabledNextStep: enabledNextStep,
    ));
    return enabledNextStep;
  }

  validateAll() {
    final errorFields = {...state.errorFields};

    errorFields.addAll(_validateNickName());

    return _validateErrorFields(fields: errorFields);
  }

  submit() async {
    if (!validateAll()) {
      return;
    }

    emit(state.copyWith(
      status: BlocStatus.loading,
    ));

    String nickName = nickNameController.text;

    final checkDupNickNameResult = await _repository.checkDuplicateNickName(
      payload: CheckDuplicateNickNamePayload(
        nickName: nickName,
      ),
    );

    if (!checkDupNickNameResult.status) {
      emit(state.copyWith(
        status: BlocStatus.failure,
        errorMessage: checkDupNickNameResult.errorMessage,
      ));
      return;
    }

    final updateResult = await _repository.updateUserMetaData(
      payload: UpdateUserMetaDataPayload(
        user: UserMetaDataModel(
          fullName: nickName,
        ),
      ),
    );

    if (updateResult.status) {
      getItInstance.get<UserCubit>().setUserMetaData(updateResult.data);
      getItInstance.get<AppCubit>().trackingEvent(event: TrackingEventType.updateNickname);
      emit(state.copyWith(
        status: BlocStatus.success,
      ));
    } else {
      emit(state.copyWith(
        status: BlocStatus.failure,
        errorMessage: updateResult.errorMessage,
      ));
    }
  }

  @override
  Future<void> close() {
    nickNameController.dispose();
    return super.close();
  }
}
