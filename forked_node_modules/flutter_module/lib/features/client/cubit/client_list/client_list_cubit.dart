import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter_module/common/bloc_status.dart';
import 'package:flutter_module/common/extension/list_extension.dart';
import 'package:flutter_module/common/utils/debounce_util.dart';
import 'package:flutter_module/features/client/repository/client_repository.dart';
import 'package:flutter_module/models/client/client_detail/client_detail_model.dart';
import 'package:flutter_module/services/api/client/payload/get_list_customer_payload.dart';
import 'package:flutter_module/services/api/client/payload/priority_payload.dart';
import 'package:flutter_module/services/api/client/payload/update_client_payload.dart';

part 'client_list_state.dart';

class ClientListGlobalCubit extends Cubit<ClientListState> with ClientListCubit {
  ClientListGlobalCubit() : super(const ClientListState());
}

class ClientListLocalCubit extends Cubit<ClientListState> with ClientListCubit {
  ClientListLocalCubit() : super(const ClientListState());
}

mixin ClientListCubit on Cubit<ClientListState> {

  final _repository = ClientRepository();
  final _debounce = DebounceUtil(milliseconds: 250);

  GetListClientPayload _payload = GetListClientPayload();

  Future fetchData({bool showLoading = true, bool loadMore = false}) async {
    if (showLoading) {
      emit(state.copyWith(
        status: BlocStatus.loading,
        forceRefresh: loadMore ? null : false,
      ));
    }

    updatedPayload(page: loadMore ? (_payload.page ?? 0) + 1 : 1);

    final result = await _repository.getListCustomer(_payload);

    if (result.status) {
      var data = [...?result.data];
      if (loadMore) {
        data = [...state.data, ...data];
      }
      emit(state.copyWith(
        status: BlocStatus.success,
        data: data,
        enabledLoadMore: loadMore ? null : true,
        forceRefresh: loadMore ? null : true,
      ));
      if (!loadMore) {
        loadMoreData();
      }
    } else {
      emit(state.copyWith(
        status: BlocStatus.failure,
        data: [],
        enabledLoadMore: loadMore ? null : true,
        forceRefresh: loadMore ? null : true,
      ));
    }
  }

  updatedPayload({
    int? page,
    String? keySearch,
    Map<String, dynamic>? filters,
  }) {
    _payload = _payload.copyWith(
      page: page,
      keySearch: keySearch,
      filters: filters,
    );
  }

  refreshData() async {
    await fetchData(showLoading: false);
  }

  Future loadMoreData() async {
    if (!state.enabledLoadMore) {
      return false;
    }
    final length = state.data.length;
    await fetchData(showLoading: false, loadMore: true);
    emit(state.copyWith(
      enabledLoadMore: length != state.data.length,
    ));
    return length != state.data.length;
  }

  onKeySearchChanged(String value) {
    updatedPayload(keySearch: value);
    _debounce.run(fetchData);
  }

  updatePriority({
    required String clientID,
    required bool isPriority,
  }) async {
    emit(state.copyWith(
      priorityStatus: BlocStatus.loading,
    ));

    final result = isPriority
        ? await _repository.deletePriority(PriorityPayload(id: clientID))
        : await _repository.addPriority(PriorityPayload(id: clientID));

    if (result.status) {
      emit(state.copyWith(
        priorityStatus: BlocStatus.success,
      ));
      updateLocalPriority(clientID: clientID, isPriority: isPriority);
    } else {
      emit(state.copyWith(
        priorityStatus: BlocStatus.success,
        errorMessage: result.errorMessage,
      ));
    }
  }

  updateLocalPriority({
    required String clientID,
    required bool isPriority,
  }) {
    var data = [...state.data];
    var index = data.indexWhere((e) => e.id == clientID);
    data = data.updateAt(index, data[index].copyWith(isPrioritized: isPriority ? '0' : '1'));

    ///
    emit(state.copyWith(
      data: data,
    ));
  }

  updateLocalClient({
    required String clientID,
    required UpdateClientPayload payload,
  }) {
    var data = [...state.data];
    var index = data.indexWhere((e) => e.id == clientID);
    data[index] = ClientDetailModel.fromJson({...data[index].toJson(), ...payload.toJson()});

    ///
    emit(state.copyWith(
      data: data,
    ));
  }

  removeAllLocalClient() {
    emit(state.copyWith(
      data: [],
    ));
  }

  removeLocalClient({
    required String clientID,
  }) {
    var data = [...state.data]..removeWhere((e) => e.id == clientID);

    ///
    emit(state.copyWith(
      data: data,
    ));
  }

  clearData() {
    emit(const ClientListState());
  }

  @override
  Future<void> close() {
    _debounce.cancel();
    return super.close();
  }
}
