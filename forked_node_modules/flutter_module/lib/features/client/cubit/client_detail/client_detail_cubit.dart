import 'dart:io';

import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter_module/common/bloc_status.dart';
import 'package:flutter_module/common/extension/list_extension.dart';
import 'package:flutter_module/features/chat/repository/chat_repository.dart';
import 'package:flutter_module/features/client/repository/client_repository.dart';
import 'package:flutter_module/models/client/client_detail/client_detail_model.dart';
import 'package:flutter_module/services/api/chat/payload/file_upload_payload.dart';
import 'package:flutter_module/services/api/client/payload/delete_client_payload.dart';
import 'package:flutter_module/services/api/client/payload/get_customer_detail_payload.dart';
import 'package:flutter_module/services/api/client/payload/priority_payload.dart';
import 'package:flutter_module/services/api/client/payload/update_client_payload.dart';
import 'package:flutter_module/services/local/local_data_helper.dart';

part 'client_detail_state.dart';

class ClientDetailCubit extends Cubit<ClientDetailState> {
  ClientDetailCubit() : super(const ClientDetailState());

  final _repository = ClientRepository();
  GetClientDetailPayload _payload = GetClientDetailPayload();

  fetchData({bool showLoading = true}) async {
    if (showLoading) {
      emit(state.copyWith(
        status: BlocStatus.loading,
      ));
    }

    final result = await _repository.getCustomerDetail(_payload);

    if (result.status) {
      emit(state.copyWith(
        status: BlocStatus.success,
        data: state.data == null
            ? result.data
            : state.data?.merge(
                result.data?.copyWith(id: state.data?.id),
              ),
        isUserGuideClientDetail: LocalDataHelper.instance.getIsUserGuideClientDetail(),
        isUserGuideClientUnclassified: LocalDataHelper.instance.getIsUserGuideClientUnclassified(),
        isUserGuideClientTrash: LocalDataHelper.instance.getIsUserGuideClientTrash(),
      ));
    } else {
      emit(state.copyWith(
        status: BlocStatus.failure,
      ));
    }
  }

  void onDisableUserGuideClientDetail() {
    if (state.isUserGuideClientDetail) {
      LocalDataHelper.instance.setIsUserGuideClientDetail();
      emit(state.copyWith(
        isUserGuideClientDetail: false,
      ));
    }
  }

  void onDisableUserGuideClientUnclassified() {
    if (state.isUserGuideClientUnclassified) {
      LocalDataHelper.instance.setIsUserGuideClientUnclassified();
      emit(state.copyWith(
        isUserGuideClientUnclassified: false,
      ));
    }
  }

  void onDisableUserGuideClientTrash() {
    if (state.isUserGuideClientTrash) {
      LocalDataHelper.instance.setIsUserGuideClientTrash();
      emit(state.copyWith(
        isUserGuideClientTrash: false,
      ));
    }
  }

  refreshData() async {
    await fetchData(showLoading: false);
  }

  _updatePayload({
    String? id,
  }) {
    _payload = _payload.copyWith(
      id: id,
    );
  }

  clearClient() {
    emit(state.copyWith(
      clearClient: true,
    ));
  }

  updateClientID(String? userID) {
    _updatePayload(id: userID);
  }

  updateInitClient(ClientDetailModel? client) {
    emit(state.copyWith(
      data: client,
      status: BlocStatus.success,
    ));
  }

  updateAvatar({
    required File file,
    required Function() onSuccess,
  }) async {
    emit(state.copyWith(
      updateStatus: BlocStatus.loading,
    ));

    final uploadResult = await ChatRepository().uploadMultiFile(
      payload: FileUploadPayload(
        files: [file],
      ),
    );
    final url = uploadResult.data.getFirst()?.url ?? '';

    if (url.isEmpty) {
      emit(state.copyWith(
        updateStatus: BlocStatus.failure,
        errorMessage: uploadResult.errorMessage,
      ));
      return;
    }

    final result = await _repository.updateClient(UpdateClientPayload(
      id: state.data?.id,
      avatar: url,
    ));

    if (result.status) {
      onSuccess();
      emit(state.copyWith(
        updateStatus: BlocStatus.success,
        data: state.data?.copyWith(
          avatar: url,
        ),
      ));
    } else {
      emit(state.copyWith(
        updateStatus: BlocStatus.failure,
        errorMessage: result.errorMessage,
      ));
    }
  }

  updateInfo({
    required UpdateClientPayload payload,
    required Function() onSuccess,
  }) async {
    emit(state.copyWith(
      updateStatus: BlocStatus.loading,
    ));

    final result = await _repository.updateClient(payload);

    if (result.status) {
      onSuccess();
      emit(state.copyWith(
        updateStatus: BlocStatus.success,
        data: ClientDetailModel.fromJson({...?state.data?.toJson(), ...payload.toJson()}),
      ));
    } else {
      emit(state.copyWith(
        updateStatus: BlocStatus.failure,
        errorMessage: result.errorMessage,
      ));
    }
  }

  updatePriority({
    required String clientID,
    required bool isPriority,
    required Function() onSuccess,
  }) async {
    emit(state.copyWith(
      priorityStatus: BlocStatus.loading,
    ));

    final result = isPriority
        ? await _repository.deletePriority(PriorityPayload(id: clientID))
        : await _repository.addPriority(PriorityPayload(id: clientID));

    if (result.status) {
      onSuccess();
      emit(state.copyWith(
        priorityStatus: BlocStatus.success,
        data: state.data?.copyWith(
          isPrioritized: isPriority ? '0' : '1',
        ),
      ));
    } else {
      emit(state.copyWith(
        priorityStatus: BlocStatus.success,
        errorMessage: result.errorMessage,
      ));
    }
  }

  addPriority({
    required String clientID,
    required Function() onSuccess,
  }) async {
    emit(state.copyWith(
      priorityStatus: BlocStatus.loading,
    ));

    final result = await _repository.addPriority(PriorityPayload(id: clientID));

    if (result.status) {
      onSuccess();
      emit(state.copyWith(
        priorityStatus: BlocStatus.success,
      ));
    } else {
      emit(state.copyWith(
        priorityStatus: BlocStatus.success,
        errorMessage: result.errorMessage,
      ));
    }
  }

  deleteTrash({
    required Function() onSuccess,
  }) async {
    emit(state.copyWith(
      deleteStatus: BlocStatus.loading,
    ));

    final result = await _repository.deleteTrash();

    if (result.status) {
      onSuccess();
      emit(state.copyWith(
        deleteStatus: BlocStatus.success,
      ));
    } else {
      emit(state.copyWith(
        deleteStatus: BlocStatus.success,
        errorMessage: result.errorMessage,
      ));
    }
  }

  deleteClient({
    String? clientID,
    bool? permanentlyDeleted,
    bool? deleteAll,
    required Function() onSuccess,
  }) async {
    emit(state.copyWith(
      deleteStatus: BlocStatus.loading,
    ));

    final result = await _repository.deleteClient(DeleteClientPayload(
      clientID: clientID,
      permanentlyDeleted: permanentlyDeleted,
      deleteAll: deleteAll,
    ));

    if (result.status) {
      onSuccess();
      emit(state.copyWith(
        deleteStatus: BlocStatus.success,
      ));
    } else {
      emit(state.copyWith(
        deleteStatus: BlocStatus.success,
        errorMessage: result.errorMessage,
      ));
    }
  }
}
