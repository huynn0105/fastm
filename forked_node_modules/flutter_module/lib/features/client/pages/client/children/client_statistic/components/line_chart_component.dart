import 'dart:math';

import 'package:fl_chart/fl_chart.dart';
import 'package:flutter/material.dart';
import 'package:flutter_module/common/colors.dart';
import 'package:flutter_module/common/enum/client/client_statistic_chart_filter.dart';
import 'package:flutter_module/common/size.dart';
import 'package:flutter_module/common/styles.dart';
import 'package:flutter_module/models/client_data/client_statistic_by_date_model.dart';
import 'package:intl/intl.dart';

class LineChartComponent extends StatefulWidget {
  const LineChartComponent({
    super.key,
    required this.statistic,
    required this.selectedType,
  });
  final ClientStatisticByDateModel? statistic;
  final ClientStatisticChartFilterType selectedType;
  @override
  State<LineChartComponent> createState() => _LineChartComponentState();
}

const int maxColumn = 6;

class _LineChartComponentState extends State<LineChartComponent> {
  final gradientColors = UIColors.stepGradient;
  List<int> showingTooltipOnSpots = [DateTime.now().month];
  int maxCount = 0;
  List<FlSpot> flData = [];
  int interval = 0;
  double witdhLineChart = AppSize.instance.width * 2;

  @override
  void initState() {
    super.initState();

    final data = widget.statistic;

    if (data?.data?.isNotEmpty == true) {
      if (widget.selectedType == ClientStatisticChartFilterType.year) {
        flData = data!.data!.map((e) => FlSpot(e.month?.toDouble() ?? 0, e.count?.toDouble() ?? 0)).toList();
      } else {
        flData = data!.data!.map((e) => FlSpot(double.tryParse(e.day ?? '') ?? 0, e.count?.toDouble() ?? 0)).toList();
      }
      maxCount = data.data?.map((e) => e.count ?? 0).reduce(max) ?? 0;
    }
    interval = (maxCount / maxColumn).ceil();

    witdhLineChart = widget.selectedType == ClientStatisticChartFilterType.year
        ? AppSize.instance.width * 2
        : AppSize.instance.width * 4;
  }

  @override
  Widget build(BuildContext context) {
    if (widget.statistic?.data?.isNotEmpty != true) {
      return const SizedBox.shrink();
    }
    final lineBarsData = [
      LineChartBarData(
        showingIndicators: showingTooltipOnSpots,
        spots: flData,
        isCurved: true,
        barWidth: 4,
        shadow: const Shadow(
          blurRadius: 8,
        ),
        dotData: const FlDotData(show: false),
      ),
    ];

    return Stack(
      children: [
        SingleChildScrollView(
          scrollDirection: Axis.horizontal,
          padding: const EdgeInsets.symmetric(horizontal: 30),
          child: Row(
            children: [
              SizedBox(
                height: 224,
                width: witdhLineChart,
                child: _buildLineChart(lineBarsData, flData),
              ),
            ],
          ),
        ),
        _buildRightWidget(interval),
      ],
    );
  }

  LineChart _buildLineChart(List<LineChartBarData> lineBarsData, List<FlSpot> flData) {
    return LineChart(
      LineChartData(
        gridData: const FlGridData(
          show: false,
        ),
        titlesData: FlTitlesData(
          show: true,
          rightTitles: const AxisTitles(
            sideTitles: SideTitles(
              showTitles: false,
            ),
          ),
          topTitles: const AxisTitles(
            sideTitles: SideTitles(showTitles: false),
          ),
          bottomTitles: AxisTitles(
            sideTitles: SideTitles(
              showTitles: true,
              reservedSize: 35,
              interval: 1,
              getTitlesWidget: widget.selectedType == ClientStatisticChartFilterType.year
                  ? bottomMonthTitleWidgets
                  : bottomDayTitleWidgets,
            ),
          ),
          leftTitles: const AxisTitles(
            sideTitles: SideTitles(showTitles: false),
          ),
        ),
        borderData: FlBorderData(
          show: false,
        ),
        showingTooltipIndicators: showingTooltipOnSpots.map((index) {
          return ShowingTooltipIndicators(
            [
              LineBarSpot(
                lineBarsData[0],
                lineBarsData.indexOf(lineBarsData[0]),
                lineBarsData[0].spots[index],
              ),
            ],
          );
        }).toList(),
        lineTouchData: _buildLineTouch(),
        lineBarsData: [
          _buildLineChartBar(flData),
        ],
      ),
    );
  }

  LineTouchData _buildLineTouch() {
    return LineTouchData(
      enabled: true,
      handleBuiltInTouches: false,
      touchCallback: (FlTouchEvent event, LineTouchResponse? response) {
        if (response == null || response.lineBarSpots == null) {
          return;
        }
        if (event is FlTapUpEvent) {
          final spotIndex = response.lineBarSpots!.first.spotIndex;
          setState(() {
            showingTooltipOnSpots.clear();
            showingTooltipOnSpots.add(spotIndex);
          });
        }
      },
      getTouchedSpotIndicator: (LineChartBarData barData, List<int> spotIndexes) {
        return spotIndexes.map((index) {
          return TouchedSpotIndicatorData(
            const FlLine(
              strokeWidth: 2,
              dashArray: [4],
              color: UIColors.blue,
            ),
            FlDotData(
              show: true,
              getDotPainter: (spot, percent, barData, index) => FlDotCirclePainter(
                radius: 6,
                strokeWidth: 2,
                strokeColor: UIColors.white,
                color: UIColors.blue,
              ),
            ),
          );
        }).toList();
      },
      touchTooltipData: LineTouchTooltipData(
        tooltipBgColor: UIColors.blue,
        tooltipRoundedRadius: 8,
        fitInsideVertically: true,
        getTooltipItems: (List<LineBarSpot> lineBarsSpot) {
          return lineBarsSpot.map((lineBarSpot) {
            return LineTooltipItem(
              lineBarSpot.y.toStringAsFixed(0),
              const TextStyle(
                color: Colors.white,
                fontWeight: FontWeight.bold,
              ),
            );
          }).toList();
        },
      ),
    );
  }

  LineChartBarData _buildLineChartBar(List<FlSpot> flData) {
    return LineChartBarData(
      spots: flData,
      isCurved: true,
      barWidth: 2,
      showingIndicators: showingTooltipOnSpots,
      color: UIColors.primaryColor,
      dotData: const FlDotData(
        show: false,
      ),
      belowBarData: BarAreaData(
        show: true,
        applyCutOffY: false,
        spotsLine: const BarAreaSpotsLine(
          applyCutOffY: true,
          show: true,
          flLineStyle: FlLine(
            strokeWidth: 2,
            dashArray: [4],
            color: UIColors.white,
          ),
        ),
        gradient: LinearGradient(
          colors: [
            UIColors.primaryColor.withOpacity(0.55),
            UIColors.primaryColor.withOpacity(0.35),
            UIColors.primaryColor.withOpacity(0.15),
          ],
          begin: Alignment.topCenter,
          end: Alignment.bottomCenter,
        ),
      ),
      isStrokeJoinRound: true,
      preventCurveOverShooting: true,
    );
  }

  Align _buildRightWidget(int interval) {
    return Align(
      alignment: Alignment.topRight,
      child: Container(
        color: Colors.white,
        height: 196,
        margin: const EdgeInsets.only(bottom: 30),
        child: Column(
          mainAxisSize: MainAxisSize.max,
          crossAxisAlignment: CrossAxisAlignment.end,
          verticalDirection: VerticalDirection.up,
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            ...List.generate(
                interval <= maxColumn ? interval + 1 : maxColumn,
                (index) => Text(
                      (index * interval).toString(),
                    )),
          ],
        ),
      ),
    );
  }

  Widget bottomMonthTitleWidgets(double value, TitleMeta meta) {
    var style = UITextStyle.regular;
    final year = DateTime.now().year;

    if (value.toInt() == showingTooltipOnSpots.first + 1) {
      style = style.copyWith(color: UIColors.blue, fontWeight: FontWeight.w600);
    }

    return SideTitleWidget(
      axisSide: meta.axisSide,
      child: Text('${value.toInt()}/$year', style: style),
    );
  }

  Widget bottomDayTitleWidgets(double value, TitleMeta meta) {
    var style = UITextStyle.regular;

    if (value.toInt() == showingTooltipOnSpots.first + 1) {
      style = style.copyWith(color: UIColors.blue, fontWeight: FontWeight.w600);
    }
    return SideTitleWidget(
      axisSide: meta.axisSide,
      child: Text(
        NumberFormat("00").format(value),
        style: style,
      ),
    );
  }
}
