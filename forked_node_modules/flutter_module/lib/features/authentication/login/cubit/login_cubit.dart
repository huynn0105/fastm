import 'dart:convert';

import 'package:bloc/bloc.dart';
import 'package:crypto/crypto.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter_module/app_data.dart';
import 'package:flutter_module/common/utils/biometrics_helper.dart';
import 'package:flutter_module/services/api/authentication/payload/verify_password_payload.dart';
import 'package:flutter_module/services/local/local_data_helper.dart';

import '../../../../common/bloc_status.dart';
import '../../../../di/get_it.dart';
import '../../../../models/base_model.dart';
import '../../../../models/user/user_info_model.dart';
import '../../auth/auth_cubit.dart';
import '../../repository/authentication_repository.dart';

part 'login_state.dart';

class LoginCubit extends Cubit<LoginState> {
  LoginCubit() : super(LoginState());

  final _repository = AuthenticationRepository();

  onPolicyChanged() {
    emit(state.copyWith(acceptedPolicy: !state.acceptedPolicy));
  }

  Future<void> checkAvailableBiometrics({Function()? onSuccess}) async {
    emit(state.copyWith(status: BlocStatus.loading));
    final canAuthenticate = await BiometricsHelper.checkAvailableBiometrics();

    emit(state.copyWith(status: BlocStatus.loading, enableBiometric: canAuthenticate));
    if (canAuthenticate) {
      authenticateWithBiometrics(onSuccess: onSuccess);
    }
  }

  Future<void> authenticateWithBiometrics({Function()? onSuccess}) async {
    final authenticated = await BiometricsHelper.authenticateWithBiometrics();
    if (onSuccess != null && authenticated) {
      onSuccess.call();
      return;
    }
    if (authenticated) {
      final password = LocalDataHelper.instance.getPassword() ?? '';
      verifyPassword(password, hashed: true);
    }
  }

  onPhoneChanged(String value) {
    emit(state.copyWith(phoneNumber: value));
  }

  verifyPassword(String password, {bool hashed = false}) async {
    emit(state.copyWith(verifyPasswordStatus: BlocStatus.loading));
    final md5PassCode = hashed ? password : md5.convert(utf8.encode(password)).toString();
    BaseModel<UserInfoModel> result = await _repository.verifyPassword(VerifyPasswordPayload(
      mobilePhone: LocalDataHelper.instance.getLoginPhone(),
      deviceUDID: AppData.instance.deviceUDID,
      password: md5PassCode,
    ));
    final tryTime = (LocalDataHelper.instance.getTryTimeLogin() ?? 3);

    if (result.status) {
      await LocalDataHelper.instance.setPassword(md5PassCode);
      await LocalDataHelper.instance.setTryTimeLogin(3);
      emit(state.copyWith(verifyPasswordStatus: BlocStatus.success));
      await getItInstance
          .get<AuthCubit>()
          .onLogin(phoneNumber: LocalDataHelper.instance.getLoginPhone(), user: result.data);
    } else {
      await LocalDataHelper.instance.setTryTimeLogin(tryTime < 0 ? 0 : tryTime - 1);
      emit(
        state.copyWith(
          verifyPasswordStatus: BlocStatus.failure,
          errMsg: 'Mật khẩu không chính xác, vui lòng thử lại hoặc đổi sang hình thức đăng nhập khác',
        ),
      );
    }
  }
}
