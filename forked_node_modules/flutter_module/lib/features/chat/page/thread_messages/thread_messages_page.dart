import 'dart:async';
import 'dart:convert';

import 'package:auto_route/auto_route.dart';
import 'package:collection/collection.dart';
import 'package:firebase_database/firebase_database.dart';
import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:flutter_json_path/flutter_json_path.dart';
import 'package:flutter_module/app_data.dart';
import 'package:flutter_module/common/bloc_status.dart';
import 'package:flutter_module/common/colors.dart';
import 'package:flutter_module/common/dialogs/dialog_provider.dart';
import 'package:flutter_module/common/enum/chat/media_type.dart';
import 'package:flutter_module/common/enum/chat/quoted_message_type.dart';
import 'package:flutter_module/common/styles.dart';
import 'package:flutter_module/common/enum/chat/thread_action_type.dart';
import 'package:flutter_module/common/toast/toast_provider.dart';
import 'package:flutter_module/common/utils/log_util.dart';
import 'package:flutter_module/common/utils/text_util.dart';
import 'package:flutter_module/common/widgets/avatar/chat_avatar.dart';
import 'package:flutter_module/common/widgets/images.dart';
import 'package:flutter_module/features/chat/cubit/chat_thread/chat_thread_cubit.dart';
import 'package:flutter_module/features/chat/cubit/device_audio_recorder/device_audio_recorder_cubit.dart';
import 'package:flutter_module/features/chat/cubit/device_icon/device_icon_cubit.dart';
import 'package:flutter_module/features/chat/cubit/device_media/device_media_cubit.dart';
import 'package:flutter_module/features/chat/cubit/file_handler/file_handler_cubit.dart';
import 'package:flutter_module/features/chat/cubit/thread_action/thread_action_cubit.dart';
import 'package:flutter_module/features/chat/cubit/thread_messages/thread_messages_cubit.dart';
import 'package:flutter_module/features/chat/page/thread_messages/components/chat_action_component.dart';
import 'package:flutter_module/features/chat/page/thread_messages/components/chat_list_component.dart';
import 'package:flutter_module/features/chat/page/thread_messages/components/quoted_message_component.dart';
import 'package:flutter_module/features/chat/page/thread_messages/components/reaction_detail_component.dart';
import 'package:flutter_module/features/chat/page/thread_messages/components/welcome_component.dart';
import 'package:flutter_module/features/chat/page/thread_messages/inheritance/message_action_provider.dart';
import 'package:flutter_module/features/chat/page/thread_messages/widgets/markup_input/models/markup_config_model.dart';
import 'package:flutter_module/features/chat/page/thread_messages/widgets/markup_input/models/markup_data_model.dart';
import 'package:flutter_module/features/chat/page/thread_messages/widgets/app_bar.dart';
import 'package:flutter_module/features/chat/page/thread_messages/widgets/scroll_to_top_button.dart';
import 'package:flutter_module/models/chat/file/media_model.dart';
import 'package:flutter_module/models/chat/location_model.dart';
import 'package:flutter_module/models/chat/message/message_model.dart';
import 'package:flutter_module/models/chat/thread/chat_thread_model.dart';
import 'package:flutter_module/routes/routes.gr.dart';
import 'package:flutter_module/services/firebase/firebase_database/firebase_database_subscription.dart';
import 'package:flutter_module/services/firebase/firebase_database/firebase_database_util.dart';

import '../../../../models/chat/message/user_on_message_model.dart';
import '../../../../services/local/user_chat_data_helper.dart';

@RoutePage()
class ThreadMessagesPage extends StatefulWidget implements AutoRouteWrapper {
  const ThreadMessagesPage({
    super.key,
    @QueryParam('threadID') this.threadID,
    this.thread,
  });

  final String? threadID;
  final ChatThreadModel? thread;

  @override
  Widget wrappedRoute(BuildContext context) {
    return MultiBlocProvider(
      providers: [
        BlocProvider(
          create: (_) => ThreadMessagesCubit(threadID: threadID)..initData(thread: thread),
        ),
        BlocProvider(
          create: (_) => ThreadActionCubit(),
        ),
        BlocProvider(
          create: (_) => FileHandlerCubit(),
        ),
        BlocProvider(
          create: (_) => DeviceAudioRecorderCubit(),
        ),
        BlocProvider(
          create: (_) => DeviceMediaCubit(),
        ),
        BlocProvider(
          lazy: false,
          create: (_) => DeviceIconCubit()..fetchData(),
        ),
      ],
      child: this,
    );
  }

  @override
  State<ThreadMessagesPage> createState() => _ThreadMessagesPageState();
}

class _ThreadMessagesPageState extends State<ThreadMessagesPage> {
  final FirebaseDatabaseSubscription _subscription = FirebaseDatabaseSubscription();

  late final StreamSubscription _messageAddedSubscription;
  late final StreamSubscription _messageChangedSubscription;
  late final StreamSubscription _usersBlockByChangedSubscription;

  bool isInitialDataLoaded = false;

  @override
  void initState() {
    super.initState();
    _onInit();
  }

  @override
  void dispose() {
    _messageAddedSubscription.cancel();
    _messageChangedSubscription.cancel();
    _usersBlockByChangedSubscription.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return MultiBlocListener(
      listeners: [
        /// TODO: Check Thread is existed
        BlocListener<ChatThreadCubit, ChatThreadState>(
          listenWhen: (pre, cur) {
            final preThread = pre.threads.firstWhereOrNull((e) => e.uid == widget.threadID);
            final curThread = cur.threads.firstWhereOrNull((e) => e.uid == widget.threadID);
            return preThread != curThread;
          },
          listener: (context, state) {
            final thread = state.threads.firstWhereOrNull((e) => e.uid == widget.threadID);
            if (thread == null) {
              context.popRoute();
            } else {
              context.read<ThreadMessagesCubit>().initData(thread: thread);
            }
          },
        ),

        /// TODO: Check thread is blocked
        BlocListener<ChatThreadCubit, ChatThreadState>(
          listenWhen: (pre, cur) {
            final preBlocked = pre.blockThreads[widget.threadID ?? ''] == true;
            final curBlocked = cur.blockThreads[widget.threadID ?? ''] == true;
            return preBlocked != curBlocked;
          },
          listener: (context, state) {
            final isBlock = state.blockThreads[widget.threadID ?? ''] == true;
            context.read<ThreadMessagesCubit>().updateBlockedThread(isBlock);
          },
        ),
      ],
      child: Scaffold(
        resizeToAvoidBottomInset: false,
        appBar: ThreadAppBar(
          context: context,
          title: _getThreadTitle(context),
          onBack: context.popRoute,
          showOnMore: _showOnMore(context),
          onMore: () {
            final threadCubit = context.read<ThreadMessagesCubit>();
            context.pushRoute(ChatSettingRoute(thread: threadCubit.state.thread!));
          },
          onTap: () {
            final threadCubit = context.read<ThreadMessagesCubit>();
            context.pushRoute(ChatSettingRoute(thread: threadCubit.state.thread!));
          },
        ),
        body: GestureDetector(
          onTap: () {
            final actionCubit = context.read<ThreadActionCubit>();
            FocusManager.instance.primaryFocus?.unfocus();
            actionCubit.updateAction(ThreadActionType.none);
          },
          child: Stack(
            children: [
              BlocBuilder<ThreadMessagesCubit, ThreadMessagesState>(
                buildWhen: (pre, cur) {
                  return pre.thread?.backgroundImage != cur.thread?.backgroundImage;
                },
                builder: (context, state) {
                  final image = state.thread?.backgroundImage ?? '';
                  if (image.isEmpty) {
                    return const Positioned.fill(
                      child: Center(
                        child: AppImage.asset(
                          asset: 'ic_chat_mfast_logo',
                          height: 300,
                          width: 300,
                        ),
                      ),
                    );
                  }
                  return Positioned.fill(
                    child: Visibility(
                      visible: image.isNotEmpty,
                      child: AppImage.network(
                        url: state.thread?.backgroundImage,
                        height: double.infinity,
                        width: double.infinity,
                      ),
                    ),
                  );
                },
              ),
              Column(
                children: [
                  Expanded(
                    child: BlocBuilder<ThreadMessagesCubit, ThreadMessagesState>(
                      buildWhen: (pre, cur) {
                        return pre.data != cur.data || pre.enableLoadMore != cur.enableLoadMore;
                      },
                      builder: (context, state) {
                        final actionCubit = context.read<ThreadActionCubit>();
                        final threadCubit = context.read<ThreadMessagesCubit>();
                        return MessageActionProvider(
                          onMessageReplied: (context, message) {
                            threadCubit.updateQuotedMessage(message, QuotedMessageType.reply);
                            actionCubit.updateAction(ThreadActionType.input, force: true);
                            actionCubit.focusInput(delay: true);
                          },
                          onMessageEdited: (context, message) {
                            threadCubit.updateQuotedMessage(message, QuotedMessageType.edit);
                            actionCubit.updateAction(ThreadActionType.input, force: true);
                            actionCubit.focusInput(delay: true);
                          },
                          onReactionMessageSelected: (context, message, reaction) {
                            _onUpdateReactionForMessage(
                              context: context,
                              messageID: message.uid ?? '',
                              reaction: reaction,
                            );
                          },
                          onReactionMessageTap: (context, message, reactions) {
                            final thread = context.read<ThreadMessagesCubit>().state.thread;
                            if (thread?.isGroupThread() == true) {
                              DialogProvider.instance.show(
                                context: context,
                                barrierDismissible: true,
                                child: ReactionDetailComponent(
                                  reactions: message.reaction ?? {},
                                  users: thread?.usersDetails ?? [],
                                ),
                              );
                            }
                          },
                          onQuotedMessageTap: (context, message) async {
                            threadCubit.getIndexMessage(
                              message,
                              onFailure: () {
                                ToastProvider.instance.show(
                                  context: context,
                                  message: 'Tin nhắn không tồn tại',
                                );
                              },
                            ).then((index) {
                              if (index != null && index >= 0) {
                                actionCubit.scrollToIndex(index).then((_) {
                                  threadCubit.updateHighlightMessage(message.uid ?? '');
                                });
                              } else {
                                ToastProvider.instance.show(
                                  context: context,
                                  message: 'Tin nhắn không tồn tại',
                                );
                              }
                            });
                          },
                          onMessageRecalled: (context, message) {
                            _onUpdateRecalledForMessage(
                              context: context,
                              messageID: message.uid ?? '',
                            );
                          },
                          onMessageDeleted: (context, message) async {
                            _onUpdateDeletedForMessage(
                              context: context,
                              messageID: message.uid ?? '',
                            );
                          },
                          child: Column(
                            children: [
                              Expanded(
                                child: ChatListComponent(
                                  status: state.status,
                                  data: state.data,
                                  isDisabledThread: state.isDisableThread,
                                  itemScrollController: actionCubit.itemScrollController,
                                  itemPositionsListener: actionCubit.itemPositionsListener,
                                  scrollOffsetController: actionCubit.scrollOffsetController,
                                  emptyBuilder: (context) {
                                    return WelcomeComponent(
                                      thread: state.thread,
                                    );
                                  },
                                  onIndexed: threadCubit.updateIndexedMessages,
                                  onLoadMore: threadCubit.loadMoreData,
                                  showLoadMoreIndicator: state.enableLoadMore && state.isDataRemote,
                                ),
                              ),
                              BlocBuilder<ThreadActionCubit, ThreadActionState>(
                                buildWhen: (pre, cur) {
                                  return pre.showScrollToTopButton != cur.showScrollToTopButton;
                                },
                                builder: (context, actionState) {
                                  return Align(
                                    alignment: Alignment.bottomCenter,
                                    child: Visibility(
                                      visible: actionState.showScrollToTopButton,
                                      child: ScrollToTopButton(
                                        onTap: actionCubit.scrollToTop,
                                      ),
                                    ),
                                  );
                                },
                              ),
                              AnimatedSize(
                                duration: const Duration(milliseconds: 600),
                                curve: Curves.easeInOut,
                                child: Visibility(
                                  visible: !state.isDataRemote,
                                  child: Container(
                                    margin: const EdgeInsets.only(bottom: 10),
                                    decoration: BoxDecoration(
                                      color: UIColors.darkGray,
                                      borderRadius: BorderRadius.circular(16),
                                    ),
                                    padding: const EdgeInsets.all(10),
                                    child: Row(
                                      mainAxisSize: MainAxisSize.min,
                                      children: [
                                        const CupertinoActivityIndicator(
                                          color: UIColors.white,
                                        ),
                                        const SizedBox(width: 10),
                                        Text(
                                          'Đang tải tin nhắn mới',
                                          style: UITextStyle.regular.copyWith(
                                            fontSize: 12,
                                            color: UIColors.white,
                                          ),
                                        ),
                                      ],
                                    ),
                                  ),
                                ),
                              ),
                            ],
                          ),
                        );
                      },
                    ),
                  ),
                  const RepaintBoundary(
                    child: QuotedMessageComponent(),
                  ),
                  BlocBuilder<ThreadMessagesCubit, ThreadMessagesState>(
                    builder: (context, state) {
                      final threadCubit = context.read<ThreadMessagesCubit>();
                      return ChatActionComponent(
                        markupConfigs: [
                          _getMentionMarkupConfig(state.thread?.usersDetails ?? []),
                        ],
                        disabled: state.isDisableThread == true,
                        disabledMessage: threadCubit.getDisabledThreadMessage() ?? state.disableThreadMessage,
                        onTextActionSent: (_, value) => _actionTextSent(context: context, text: value),
                        onMentionActionSent: (_, text, htmlText) => _actionMentionSent(
                          context: context,
                          text: text,
                          htmlText: htmlText,
                        ),
                        onMediaActionSent: (_, value) => _actionMediaSent(context: context, medias: value),
                        onStickerActionSent: (_, value) => _actionStickerSent(context: context, sticker: value),
                        onLocationActionSent: (_, value) => _actionLocationSent(context: context, location: value),
                        onAudioActionSent: (_, value) => _actionAudioSent(context: context, media: value),
                        onEditingActionSent: (_, value) => _actionEditingSent(context: context, text: value),
                      );
                    },
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  _onInit() {
    _messageAddedSubscription = _subscription
        .threadMessagesAdded(widget.threadID ?? '')
        .listen((event) => _onListenMessageAdded(context, event));

    _messageChangedSubscription = _subscription
        .threadMessagesChanged(widget.threadID ?? '')
        .listen((event) => _onListenMessageUpdated(context, event));

    _usersBlockByChangedSubscription = _subscription
        .usersBlockByChanged(threadID: widget.threadID ?? '', userID: AppData.instance.userID)
        .listen((event) => _onListenUserBlockByChanged(context, event));

    ///
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final threadCubit = context.read<ThreadMessagesCubit>();
      if (!threadCubit.state.status.isSuccess) {
        threadCubit.fetchData();
      }
      final chatThreadCubit = context.read<ChatThreadCubit>();
      final isBlock = chatThreadCubit.isBlockedThread(widget.threadID);
      threadCubit.updateBlockedThread(isBlock);
      chatThreadCubit.updateReadTimeToNow(
        threadID: widget.threadID ?? '',
        userID: AppData.instance.userID,
      );
    });
  }

  _onListenMessageAdded(BuildContext context, DatabaseEvent event) async {
    if (!context.mounted) {
      return;
    }
    debugPrint('_onListenMessageAdded: ${jsonEncode(FirebaseDatabaseUtil.convertObjectToMap(event.snapshot.value))}');
    final message = MessageModel.fromJson(
      FirebaseDatabaseUtil.convertObjectToMap(event.snapshot.value),
    );
    final cubit = context.read<ThreadMessagesCubit>();
    if (!isInitialDataLoaded) {
      isInitialDataLoaded = true;
      //get and apply last info
      UserOnMessageModel? user = await cubit.getUserChat(message.author?.id ?? '');
      if (user != null) {
        message.author?.avatar = user.avatar;
        message.author?.fullName = user.fullName;
      }
    } else {
      final user = UserChatDataHelper.instance.getExistUser(message.author?.id ?? '');
      if (message.author?.id != null) {
        if (user == null) {
          //save user on last msg to reuse
          UserChatDataHelper.instance.addUser(UserOnMessageModel(
            id: message.author?.id,
            fullName: message.author?.fullName,
            avatar: message.author?.avatar,
          ));
        }
      }
    }
    cubit.addMessageFromListener(message, onFromMeSent: () {
      _scrollToTop(context);
    });
  }

  _scrollToTop(BuildContext context) {
    final actionCubit = context.read<ThreadActionCubit>();
    Future.delayed(const Duration(milliseconds: 200), actionCubit.scrollToTop);
  }

  _onListenMessageUpdated(BuildContext context, DatabaseEvent event) {
    if (!context.mounted) {
      return;
    }
    final message = MessageModel.fromJson(
      FirebaseDatabaseUtil.convertObjectToMap(event.snapshot.value),
    );
    if (message.author?.id != null) {
      final user = UserChatDataHelper.instance.getExistUser(message.author?.id ?? '');
      if (user == null) {
        UserChatDataHelper.instance.addUser(UserOnMessageModel(
          id: message.author?.id,
          fullName: message.author?.fullName,
          avatar: message.author?.avatar,
        ));
      }
    }
    final cubit = context.read<ThreadMessagesCubit>();
    cubit.updateMessageFromListener(
      message,
      onFromMeSent: () {
        ///
      },
    );
  }

  _onListenUserBlockByChanged(BuildContext context, DatabaseEvent event) {
    if (!context.mounted) {
      return;
    }
  }

  _actionTextSent({
    required BuildContext context,
    required String text,
  }) {
    final actionCubit = context.read<ThreadActionCubit>();
    actionCubit.inputController.clear();
    final cubit = context.read<ThreadMessagesCubit>();
    cubit.sendMessage(
      MessageModel.newTextMessage(text: text.trim()),
      onSuccess: (messageID) {},
      onFailure: () {},
    );
  }

  _actionMentionSent({
    required BuildContext context,
    required String text,
    required String htmlText,
  }) {
    final actionCubit = context.read<ThreadActionCubit>();
    actionCubit.inputController.clear();
    final cubit = context.read<ThreadMessagesCubit>();
    cubit.sendMessage(
      MessageModel.newMentionMessage(
        text: text.trim(),
        htmlText: htmlText.trim(),
      ),
      onSuccess: (messageID) {},
      onFailure: () {},
    );
  }

  _actionStickerSent({
    required BuildContext context,
    required String sticker,
  }) {
    final cubit = context.read<ThreadMessagesCubit>();
    cubit.sendMessage(
      MessageModel.newStickerMessage(sticker: sticker),
      onSuccess: (messageID) {},
      onFailure: () {},
    );
  }

  _actionMediaSent({
    required BuildContext context,
    required List<MediaModel> medias,
    bool ignoreUploadThumbnail = false,
  }) async {
    send(
      BuildContext context,
      MessageModel message,
      List<MediaModel> medias,
    ) {
      final jPath = FlutterJsonPath();
      final uploadCubit = context.read<FileHandlerCubit>();
      _onAddLocalMessage(
        context: context,
        message: message,
        futures: (json) {
          return medias.map((e) {
            return uploadCubit.upload(
              id: e.id ?? '',
              media: e,
              onSuccess: (urls) {
                jPath.set(json, 'imageURLs/${e.id}/url', urls.first);
                if (!ignoreUploadThumbnail) {
                  jPath.set(json, 'imageURLs/${e.id}/thumbnail/url', urls.last);
                }
              },
            );
          }).toList();
        },
      );
    }

    final images = medias.where((e) => e.type == MediaType.image.name).toList();
    final videos = medias.where((e) => e.type == MediaType.video.name).toList();
    final audios = medias.where((e) => e.type == MediaType.audio.name).toList();
    if (images.isNotEmpty) {
      send(context, MessageModel.newImageMessage(medias: images), images);
    }
    if (videos.isNotEmpty) {
      send(context, MessageModel.newVideoMessage(medias: videos), videos);
    }
    if (audios.isNotEmpty) {
      send(context, MessageModel.newAudioMessage(media: audios.first), audios);
    }
  }

  _actionLocationSent({
    required BuildContext context,
    required LocationModel location,
  }) {
    final cubit = context.read<ThreadMessagesCubit>();
    cubit.sendMessage(
      MessageModel.newLocationMessage(location: location),
      onSuccess: (messageID) {},
      onFailure: () {},
    );
  }

  _actionAudioSent({
    required BuildContext context,
    required MediaModel media,
  }) {
    _actionMediaSent(context: context, medias: [media], ignoreUploadThumbnail: true);
  }

  _actionEditingSent({
    required BuildContext context,
    required String text,
  }) {
    final cubit = context.read<ThreadMessagesCubit>();
    final message = cubit.state.quotedMessage;
    _onUpdateEditedForMessage(
      context: context,
      messageID: message?.uid ?? '',
      text: text,
    );
  }

  _onAddLocalMessage({
    required BuildContext context,
    required MessageModel message,
    List<Future> Function(Map<String, dynamic>)? futures,
  }) async {
    final cubit = context.read<ThreadMessagesCubit>();
    final data = await cubit.pushLocalMessage(message);
    final json = data?.toFirebaseJson() ?? {};
    if (futures != null) {
      await Future.wait(futures(json));
    }
    AppLog.d('_onAddLocalMessage:', jsonEncode(json));
    cubit.sendLocalMessage(MessageModel.fromJson(json));
  }

  _onUpdateReactionForMessage({
    required BuildContext context,
    required String messageID,
    required String? reaction,
  }) {
    final cubit = context.read<ThreadMessagesCubit>();
    cubit.updateReactionForMessage(
      messageID: messageID,
      reaction: reaction,
    );
  }

  _onUpdateRecalledForMessage({
    required BuildContext context,
    required String messageID,
  }) {
    final cubit = context.read<ThreadMessagesCubit>();
    cubit.updateRecalledForMessage(
      messageID: messageID,
    );
  }

  _onUpdateEditedForMessage({
    required BuildContext context,
    required String messageID,
    required String text,
  }) {
    final actionCubit = context.read<ThreadActionCubit>();
    actionCubit.inputController.clear();
    final cubit = context.read<ThreadMessagesCubit>();
    cubit.updateEditedForMessage(
      messageID: messageID,
      text: text,
    );
  }

  _onUpdateDeletedForMessage({
    required BuildContext context,
    required String messageID,
  }) {
    final cubit = context.read<ThreadMessagesCubit>();
    cubit.updateDeletedForMessage(
      messageID: messageID,
    );
  }

  _getThreadTitle(BuildContext context) {
    return context.select((ThreadMessagesCubit cubit) => cubit.state.thread?.getDefaultThreadTitle() ?? '');
  }

  _showOnMore(BuildContext context) {
    return context.select((ThreadMessagesCubit cubit) {
      final state = cubit.state;
      final isDisableThread = state.isDisableThread;
      if (state.disabledThreadFields.keys.contains(DisabledThreadType.blocked.name)) {
        return true;
      }
      return !isDisableThread;
    });
  }

  MarkupConfigModel _getMentionMarkupConfig(List<ThreadUserDetail> users) {
    final all = MarkupDataModel(
      id: 'all',
      display: 'All',
      label: 'Tất cả',
      assetURI: 'ic_chat_mention_all',
    );
    final data = users.where((e) => e.uid != AppData.instance.userID).map(
      (e) {
        final imageURL = FirebaseDatabaseUtil.convertUrlAvatar(e.avatarImage);
        return MarkupDataModel(
          id: e.uid ?? '',
          display: e.fullName ?? '',
          imageURL: imageURL,
        );
      },
    ).toList();
    return MarkupConfigModel(
      trigger: '@',
      matchAll: false,
      style: UITextStyle.medium.copyWith(
        fontSize: 16,
        color: UIColors.primaryColor,
      ),
      data: [all, ...data],
      suggestionBuilder: (data) {
        return Padding(
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
          child: Row(
            children: [
              if (TextUtils.isNotEmpty(data.assetURI))
                Container(
                  width: 32,
                  height: 32,
                  alignment: Alignment.center,
                  decoration: const BoxDecoration(
                    shape: BoxShape.circle,
                    color: UIColors.gray,
                  ),
                  child: AppImage.asset(
                    asset: data.assetURI ?? '',
                    width: 24,
                    height: 24,
                    borderRadius: BorderRadius.circular(16),
                  ),
                )
              else
                ChatAvatar(
                  url: data.imageURL ?? '',
                  size: 32,
                  isSingleThread: true,
                  name: data.display,
                ),
              const SizedBox(
                width: 12,
              ),
              if (data.id != 'all')
                Text(
                  data.display,
                  style: UITextStyle.medium.copyWith(
                    fontSize: 16,
                  ),
                ),
              if (data.id == 'all')
                Row(
                  children: [
                    Text(
                      data.label ?? '',
                      style: UITextStyle.medium.copyWith(
                        fontSize: 16,
                      ),
                    ),
                    const SizedBox(
                      width: 3,
                    ),
                    Text(
                      '@${data.display}',
                      style: UITextStyle.medium.copyWith(
                        fontSize: 16,
                        color: UIColors.primaryColor,
                      ),
                    ),
                  ],
                ),
            ],
          ),
        );
      },
    );
  }
}
