import 'package:collection/collection.dart';
import 'package:diffutil_dart/diffutil.dart';
import 'package:flutter/material.dart';
import 'package:flutter_module/common/bloc_status.dart';
import 'package:flutter_module/common/extension/datetime_extension.dart';
import 'package:flutter_module/common/widgets/lazy_load_scroll_view.dart';
import 'package:flutter_module/common/widgets/loadmore_widget.dart';
import 'package:flutter_module/features/chat/page/thread_messages/inheritance/message_wrapper_provider.dart';
import 'package:flutter_module/features/chat/page/thread_messages/items/message_item.dart';
import 'package:flutter_module/features/chat/page/thread_messages/widgets/header/date_group_header.dart';
import 'package:flutter_module/models/chat/message/message_model.dart';
import 'package:flutter_module/models/chat/message/message_wrapper_model.dart';

import 'package:flutter_module/common/widgets/scrollable_positioned_list/scrollable_positioned_list.dart';

class ChatListComponent extends StatefulWidget {
  const ChatListComponent({
    super.key,
    required this.status,
    required this.data,
    required this.itemScrollController,
    required this.itemPositionsListener,
    required this.scrollOffsetController,
    required this.onIndexed,
    required this.onLoadMore,
    required this.emptyBuilder,
    this.showLoadMoreIndicator = true,
    this.isDisabledThread = false,
  });

  final BlocStatus status;
  final List<MessageModel> data;
  final ItemScrollController itemScrollController;
  final ItemPositionsListener itemPositionsListener;
  final ScrollOffsetController scrollOffsetController;
  final Function(Map<String, int>) onIndexed;
  final bool showLoadMoreIndicator;
  final Future Function() onLoadMore;
  final WidgetBuilder emptyBuilder;
  final bool isDisabledThread;

  @override
  State<ChatListComponent> createState() => _ChatListComponentState();
}

class _ChatListComponentState extends State<ChatListComponent> {
  /// TODO: Animation
  // final GlobalKey<SliverAnimatedListState> _key = GlobalKey<SliverAnimatedListState>();
  final Map<String, int> _messageIndex = <String, int>{};
  List<MessageWrapperModel> _data = <MessageWrapperModel>[];

  @override
  void initState() {
    super.initState();
    didUpdateWidget(widget);
  }

  @override
  void dispose() {
    super.dispose();
  }

  @override
  void didUpdateWidget(covariant ChatListComponent oldWidget) {
    super.didUpdateWidget(oldWidget);
    _calculateListDiff(_messageWrapperList(data: widget.data));
  }

  @override
  Widget build(BuildContext context) {
    /// TODO: Animation
    // return LoadMoreWidget(
    //   reverse: true,
    //   onLoadMore: widget.onLoadMore,
    //   child: CustomScrollView(
    //     reverse: true,
    //     cacheExtent: 1000,
    //     slivers: [
    //       const SliverToBoxAdapter(
    //         child: SizedBox(
    //           height: 16,
    //         ),
    //       ),
    //       SliverAnimatedList(
    //         key: _key,
    //         initialItemCount: _data.length,
    //         itemBuilder: (_, index, animation) {
    //           return _newMessageBuilder(context, _data[index], animation);
    //         },
    //         findChildIndexCallback: (Key key) {
    //           if (key is ValueKey<String>) {
    //             final index = _data.indexWhere((v) => v.message?.uid == key.value);
    //             return index >= 0 ? index : null;
    //           }
    //           return null;
    //         },
    //       ),
    //       const SliverToBoxAdapter(
    //         child: SizedBox(
    //           height: 16,
    //         ),
    //       ),
    //     ],
    //   ),
    // );
    if (widget.status.isSuccess && _data.isEmpty) {
      return widget.emptyBuilder(context);
    }
    final itemCount = widget.showLoadMoreIndicator ? _data.length + 1 : _data.length;
    return LazyLoadScrollView(
      key: const ValueKey<String>('lazy_thread_message_list'),
      onEndOfPage: widget.onLoadMore,
      child: ScrollablePositionedList.separated(
        key: const ValueKey<String>('thread_message_list'),
        reverse: true,
        minCacheExtent: 1000,
        physics: const ClampingScrollPhysics(),
        itemScrollController: widget.itemScrollController,
        itemPositionsListener: widget.itemPositionsListener,
        scrollOffsetController: widget.scrollOffsetController,
        keyboardDismissBehavior: ScrollViewKeyboardDismissBehavior.onDrag,
        itemCount: itemCount,
        itemBuilder: (context, index) {
          if (index == itemCount - 1 && widget.showLoadMoreIndicator) {
            return Container(
              alignment: Alignment.center,
              padding: const EdgeInsets.symmetric(vertical: 16),
              child: const SizedBox(
                width: 35,
                height: 35,
                child: CircularProgressIndicator.adaptive(),
              ),
            );
          }
          final item = _data[index];
          return KeyedSubtree(
            key: ValueKey(item.message?.uid ?? ''),
            child: MessageWrapperProvider(
              data: item,
              child: MessageItem(
                isDisabledGesture: widget.isDisabledThread,
              ),
            ),
          );
        },
        separatorBuilder: (_, index) {
          final item = _data[index];
          if (item.message?.isDeletedByMe() == true) {
            return const SizedBox();
          }
          return const SizedBox(height: 4);
        },
        // findChildIndexCallback: (Key key) {
        //   if (key is IndexedKey) {
        //     final valueKey = key.key as ValueKey<String>?;
        //     final index = _messageIndex[valueKey?.value ?? ''] ?? -1;
        //     return index >= 0 ? index : null;
        //   }
        //   return null;
        // },
      ),
    );
  }

  List<MessageWrapperModel> _messageWrapperList({
    required List<MessageModel> data,
  }) {
    List<MessageWrapperModel> result = [];

    ///
    for (int i = 0; i < data.length; i++) {
      bool isFirstMessage = (i == 0);
      bool isLastMessage = (i == data.length - 1);

      ///
      MessageModel message = data[i];
      MessageModel? nextMessage = isLastMessage ? null : data[i + 1];
      MessageModel? previousMessage = isFirstMessage ? null : data[i - 1];

      bool hasSameNextAuthor = message.author?.id == nextMessage?.author?.id;
      bool hasSamePreviousAuthor = message.author?.id == previousMessage?.author?.id;

      ///
      bool isFirstMessageInGroup = false;
      bool isLastMessageInGroup = false;
      bool showReceiverAvatar = false;
      bool showMessageCreateTime = false;

      ///
      showReceiverAvatar = !hasSamePreviousAuthor;
      isFirstMessageInGroup = isLastMessage || !hasSameNextAuthor;
      isLastMessageInGroup = isFirstMessage || !hasSamePreviousAuthor;

      /// COMPARE: createTime
      {
        DateTime now = DateTime.now();
        DateTime? pre = previousMessage?.getCreatedTime()?.toLocal();
        DateTime? cur = message.getCreatedTime()?.toLocal();

        showMessageCreateTime = (cur?.hour != pre?.hour || cur?.minute != pre?.minute) || isFirstMessage;

        now = now.dateOnly();
        pre = pre?.dateOnly();
        cur = cur?.dateOnly();

        if (pre != null) {
          final isToday = now.difference(pre).inDays == 0;
          final difference = !(cur?.isAtSameMomentAs(pre) == true);
          if (difference) {
            MessageWrapperModel wrapper = MessageWrapperModel(
              header: DateGroupHeader(
                isToday: isToday,
                date: pre.toIso8601String(),
              ),
            );
            result.add(wrapper);
          }
        }
      }

      _messageIndex[message.uid ?? ''] = result.length;
      MessageWrapperModel wrapper = MessageWrapperModel(
        message: message,
        showReceiverAvatar: showReceiverAvatar,
        showMessageCreateTime: showMessageCreateTime,
        isFirstMessageInThread: isFirstMessage,
        isLastMessageInThread: isLastMessage,
        isFirstMessageInGroup: isFirstMessageInGroup,
        isLastMessageInGroup: isLastMessageInGroup,
      );
      result.add(wrapper);

      /// COMPARE: createTime for last message
      {
        DateTime now = DateTime.now();
        DateTime? cur = message.getCreatedTime()?.toLocal();

        now = now.dateOnly();
        cur = cur?.dateOnly();

        if (isLastMessage && cur != null) {
          final isToday = now.difference(cur).inDays == 0;
          MessageWrapperModel wrapper = MessageWrapperModel(
            header: DateGroupHeader(
              isToday: isToday,
              date: cur.toIso8601String(),
            ),
          );
          result.add(wrapper);
        }
      }
    }

    ///
    widget.onIndexed(_messageIndex);

    ///
    return result;
  }

  _calculateListDiff(List<MessageWrapperModel> data) {
    /// TODO: Animation
    // final results = calculateListDiff<MessageWrapperModel>(
    //   _data,
    //   data,
    //   equalityChecker: (e1, e2) => e1.message?.uid == e2.message?.uid,
    // );
    // for (final update in results.getUpdates(batch: false)) {
    //   update.when(
    //     insert: (index, count) {
    //       _key.currentState?.insertItem(
    //         index,
    //         duration: const Duration(milliseconds: 350),
    //       );
    //     },
    //     remove: (index, count) {
    //       final item = _data[index];
    //       _key.currentState?.removeItem(
    //         index,
    //         duration: const Duration(milliseconds: 500),
    //         (context, animation) => _removedMessageBuilder(context, item, animation),
    //       );
    //     },
    //     change: (index, payload) {},
    //     move: (from, to) {},
    //   );
    // }
    _data = List.from(data);
  }

  /// TODO: Animation
// _messageBuilder(
//   BuildContext context,
//   MessageWrapperModel data,
//   Animation<double>? animation,
// ) {
//   return MessageWrapperProvider(
//     data: data,
//     child: const MessageItem(),
//   );
// }
//
// _newMessageBuilder(
//   BuildContext context,
//   MessageWrapperModel item,
//   Animation<double> animation,
// ) {
//   animation = animation.drive(CurveTween(curve: Curves.linear));
//   return FadeTransition(
//     key: ValueKey(item.message?.uid ?? ''),
//     opacity: animation,
//     child: SizeTransition(
//       axisAlignment: -1,
//       sizeFactor: animation,
//       child: _messageBuilder(context, item, animation),
//     ),
//   );
// }
//
// _removedMessageBuilder(
//   BuildContext context,
//   MessageWrapperModel item,
//   Animation<double> animation,
// ) {
//   animation = animation.drive(CurveTween(curve: Curves.linear));
//   return FadeTransition(
//     key: ValueKey(item.message?.uid ?? ''),
//     opacity: animation,
//     child: SizeTransition(
//       axisAlignment: -1,
//       sizeFactor: animation,
//       child: _messageBuilder(context, item, animation),
//     ),
//   );
// }
}
