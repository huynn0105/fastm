import 'package:flutter/material.dart';

import 'models/markup_annotation_model.dart';

/// A custom implementation of [TextEditingController] to support @ mention or other
/// trigger based mentions.
class MarkupTextEditingController extends TextEditingController {
  Map<String, MarkupAnnotationModel> _mapping;
  String? _pattern;

  /// Generate the Regex pattern for matching all the suggestions in one.
  MarkupTextEditingController(this._mapping) {
    _pattern = _mapping.keys.isNotEmpty ? getPatternFromMapping(_mapping) : null;
  }

  Map<String, MarkupAnnotationModel> get mapping => _mapping;

  set mapping(Map<String, MarkupAnnotationModel> mapping) {
    _mapping = mapping;
    _pattern = getPatternFromMapping(mapping);
  }

  bool get hasMarkup {
    return RegExp('$_pattern').hasMatch(text);
  }

  /// Can be used to get the markup from the controller directly.
  String get markupText {
    if (_mapping.isEmpty) {
      return text;
    }
    return text.splitMapJoin(
      RegExp('$_pattern'),
      onMatch: (Match match) {
        var mention = _mapping[match[0]!];
        if (mention == null) {
          var key = _mapping.keys.firstWhere((e) => RegExp(e).hasMatch(match[0]!));
          mention = _mapping[key]!;
        }

        /// Default markup format for mentions
        if (!mention.disableMarkup) {
          return mention.markupConverter != null
              ? mention.markupConverter!(mention.trigger, mention.display!, mention.id!)
              : mention.getMarkupFormatText();
        } else {
          return match[0]!;
        }
      },
      onNonMatch: (String text) {
        return text;
      },
    );
  }

  String getPatternFromMapping(Map<String, MarkupAnnotationModel> mapping) {
    return "(${mapping.keys.map((key) => RegExp.escape(key)).join('|')})";
  }

  @override
  TextSpan buildTextSpan({BuildContext? context, TextStyle? style, bool? withComposing}) {
    var children = <InlineSpan>[];

    if (_pattern == null || _pattern == '()') {
      children.add(TextSpan(text: text, style: style));
    } else {
      text.splitMapJoin(
        RegExp('$_pattern'),
        onMatch: (Match match) {
          if (_mapping.isNotEmpty) {
            var mention = _mapping[match[0]!];
            if (mention == null) {
              var key = _mapping.keys.firstWhere((e) => RegExp(e).hasMatch(match[0]!));
              mention = _mapping[key]!;
            }

            children.add(
              TextSpan(
                text: match[0],
                style: style!.merge(mention.style),
              ),
            );
          }
          return '';
        },
        onNonMatch: (String text) {
          children.add(TextSpan(text: text, style: style));
          return '';
        },
      );
    }
    return TextSpan(style: style, children: children);
  }
}
