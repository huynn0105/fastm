// ignore_for_file: no_leading_underscores_for_local_identifiers

import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_portal/flutter_portal.dart';

import 'enums/markup_suggestion_position.dart';
import 'markup_option_list.dart';
import 'markup_text_editing_controller.dart';
import 'models/markup_annotation_model.dart';
import 'models/markup_config_model.dart';
import 'models/markup_data_model.dart';
import 'models/markup_word_model.dart';

class MarkupTextField extends StatefulWidget {
  const MarkupTextField({
    Key? key,
    required this.markupConfigs,
    this.controller,
    this.focusNode,
    this.defaultText,
    this.suggestionPosition = MarkupSuggestionPosition.top,
    this.suggestionListHeight = 180.0,
    this.onMarkupChanged,
    this.onMentionAdd,
    this.onSearchChanged,
    this.leading = const [],
    this.trailing = const [],
    this.suggestionListDecoration,
    this.decoration,
    this.keyboardType,
    this.textInputAction,
    this.textCapitalization = TextCapitalization.none,
    this.style,
    this.strutStyle,
    this.textAlign = TextAlign.start,
    this.textDirection,
    this.autofocus = false,
    this.autocorrect = true,
    this.enableSuggestions = true,
    this.maxLines = 1,
    this.minLines,
    this.expands = false,
    this.readOnly = false,
    this.showCursor,
    this.maxLength,
    this.maxLengthEnforcement = MaxLengthEnforcement.none,
    this.onChanged,
    this.onEditingComplete,
    this.onSubmitted,
    this.enabled = true,
    this.cursorWidth = 2.0,
    this.cursorRadius = const Radius.circular(2.0),
    this.cursorColor,
    this.keyboardAppearance,
    this.scrollPadding = const EdgeInsets.all(20.0),
    this.enableInteractiveSelection = true,
    this.onTap,
    this.buildCounter,
    this.scrollPhysics,
    this.scrollController,
    this.autofillHints,
    this.appendSpaceOnAdd = true,
    this.hideSuggestionList = false,
    this.onSuggestionVisibleChanged,
    this.textAlignVertical = TextAlignVertical.center,
    this.placeholder,
    this.placeholderStyle,
    this.padding = const EdgeInsets.all(8),
  }) : super(key: key);

  /// Controls the text being edited.
  ///
  /// If null, this widget will create its own [MarkupTextEditingController].
  final MarkupTextEditingController? controller;

  /// {@macro flutter.widgets.Focus.focusNode}
  final FocusNode? focusNode;

  final bool hideSuggestionList;

  /// default text for the Mention Input.
  final String? defaultText;

  /// Triggers when the suggestion list visibility changed.
  final Function(bool)? onSuggestionVisibleChanged;

  /// List of Mention that the user is allowed to triggered
  final List<MarkupConfigModel> markupConfigs;

  /// Leading widgets to show before teh Input box, helps preseve the size
  /// size for the Portal widget size.
  final List<Widget> leading;

  /// Trailing widgets to show before teh Input box, helps preseve the size
  /// size for the Portal widget size.
  final List<Widget> trailing;

  /// Suggestion modal position, can be alligned to top or bottom.
  ///
  /// Defaults to [MarkupSuggestionPosition.Bottom].
  final MarkupSuggestionPosition suggestionPosition;

  /// Triggers when the suggestion was added by tapping on suggestion.
  final Function(MarkupDataModel)? onMentionAdd;

  /// Max height for the suggestion list
  ///
  /// Defaults to `180.0`
  final double suggestionListHeight;

  /// A Functioned which is triggered when ever the input changes
  /// but with the markup of the selected mentions
  ///
  /// This is an optional property.
  final ValueChanged<String>? onMarkupChanged;

  final void Function(String trigger, String value)? onSearchChanged;

  /// Decoration for the Suggestion list.
  final BoxDecoration? suggestionListDecoration;

  /// Should selecting a suggestion add a space at the end or not.
  final bool appendSpaceOnAdd;

  /// The decoration to show around the text field.
  final BoxDecoration? decoration;

  /// {@macro flutter.widgets.editableText.keyboardType}
  final TextInputType? keyboardType;

  /// The type of action button to use for the keyboard.
  ///
  /// Defaults to [TextInputAction.newline] if [keyboardType] is
  /// [TextInputType.multiline] and [TextInputAction.done] otherwise.
  final TextInputAction? textInputAction;

  /// {@macro flutter.widgets.editableText.textCapitalization}
  final TextCapitalization textCapitalization;

  /// The style to use for the text being edited.
  ///
  /// This text style is also used as the base style for the [decoration].
  ///
  /// If null, defaults to the `subtitle1` text style from the current [Theme].
  final TextStyle? style;

  /// {@macro flutter.widgets.editableText.strutStyle}
  final StrutStyle? strutStyle;

  /// {@macro flutter.widgets.editableText.textAlign}
  final TextAlign textAlign;

  /// {@macro flutter.widgets.editableText.textDirection}
  final TextDirection? textDirection;

  /// {@macro flutter.widgets.editableText.autofocus}
  final bool autofocus;

  /// {@macro flutter.widgets.editableText.autocorrect}
  final bool autocorrect;

  /// {@macro flutter.services.textInput.enableSuggestions}
  final bool enableSuggestions;

  /// {@macro flutter.widgets.editableText.maxLines}
  final int maxLines;

  /// {@macro flutter.widgets.editableText.minLines}
  final int? minLines;

  /// {@macro flutter.widgets.editableText.expands}
  final bool expands;

  /// {@macro flutter.widgets.editableText.readOnly}
  final bool readOnly;

  /// {@macro flutter.widgets.editableText.showCursor}
  final bool? showCursor;

  /// If [maxLength] is set to this value, only the "current input length"
  /// part of the character counter is shown.
  static const int noMaxLength = -1;

  /// The maximum number of characters (Unicode scalar values) to allow in the
  /// text field.
  final int? maxLength;

  /// If true, prevents the field from allowing more than [maxLength]
  /// characters.
  ///
  /// If [maxLength] is set, [maxLengthEnforcement] indicates whether or not to
  /// enforce the limit, or merely provide a character counter and warning when
  /// [maxLength] is exceeded.
  final MaxLengthEnforcement maxLengthEnforcement;

  /// {@macro flutter.widgets.editableText.onChanged}
  final ValueChanged<String>? onChanged;

  /// {@macro flutter.widgets.editableText.onEditingComplete}
  final VoidCallback? onEditingComplete;

  /// {@macro flutter.widgets.editableText.onSubmitted}
  final ValueChanged<String>? onSubmitted;

  /// If false the text field is "disabled": it ignores taps and its
  /// [decoration] is rendered in grey.
  ///
  /// If non-null this property overrides the [decoration]'s
  /// [Decoration.enabled] property.
  final bool enabled;

  /// {@macro flutter.widgets.editableText.cursorWidth}
  final double cursorWidth;

  /// {@macro flutter.widgets.editableText.cursorRadius}
  final Radius cursorRadius;

  /// The color to use when painting the cursor.
  ///
  /// Defaults to [ThemeData.cursorColor] or [CupertinoTheme.primaryColor]
  /// depending on [ThemeData.platform] .
  final Color? cursorColor;

  /// The appearance of the keyboard.
  ///
  /// This setting is only honored on iOS devices.
  ///
  /// If unset, defaults to the brightness of [ThemeData.primaryColorBrightness].
  final Brightness? keyboardAppearance;

  /// {@macro flutter.widgets.editableText.scrollPadding}
  final EdgeInsets scrollPadding;

  /// {@macro flutter.widgets.editableText.enableInteractiveSelection}
  final bool enableInteractiveSelection;

  /// {@macro flutter.rendering.editable.selectionEnabled}
  bool get selectionEnabled => enableInteractiveSelection;

  /// {@template flutter.material.textfield.onTap}
  /// Called for each distinct tap except for every second tap of a double tap.
  final GestureTapCallback? onTap;

  /// Callback that generates a custom [InputDecorator.counter] widget.
  ///
  /// See [InputCounterWidgetBuilder] for an explanation of the passed in
  /// arguments.  The returned widget will be placed below the line in place of
  /// the default widget built when [counterText] is specified.
  ///
  /// The returned widget will be wrapped in a [Semantics] widget for
  /// accessibility, but it also needs to be accessible itself.  For example,
  /// if returning a Text widget, set the [semanticsLabel] property.
  final InputCounterWidgetBuilder? buildCounter;

  /// {@macro flutter.widgets.editableText.scrollPhysics}
  final ScrollPhysics? scrollPhysics;

  /// {@macro flutter.widgets.editableText.scrollController}
  final ScrollController? scrollController;

  /// {@macro flutter.widgets.editableText.autofillHints}
  /// {@macro flutter.services.autofill.autofillHints}
  final Iterable<String>? autofillHints;

  /// {@macro flutter.material.InputDecorator.textAlignVertical}
  final TextAlignVertical? textAlignVertical;

  /// A lighter colored placeholder hint that appears on the first line of the
  /// text field when the text entry is empty.
  ///
  /// Defaults to having no placeholder text.
  ///
  /// The text style of the placeholder text matches that of the text field's
  /// main text entry except a lighter font weight and a grey font color.
  final String? placeholder;

  /// The style to use for the placeholder text.
  ///
  /// The [placeholderStyle] is merged with the [style] [TextStyle] when applied
  /// to the [placeholder] text. To avoid merging with [style], specify
  /// [TextStyle.inherit] as false.
  ///
  /// Defaults to the [style] property with w300 font weight and grey color.
  ///
  /// If specifically set to null, placeholder's style will be the same as [style].
  final TextStyle? placeholderStyle;

  /// Padding around the text entry area between the [prefix] and [suffix]
  /// or the clear button when [clearButtonMode] is not never.
  ///
  /// Defaults to a padding of 6 pixels on all sides and can be null.
  final EdgeInsetsGeometry padding;

  @override
  MarkupTextFieldState createState() => MarkupTextFieldState();
}

class MarkupTextFieldState extends State<MarkupTextField> {
  late final MarkupTextEditingController controller;
  late final ValueNotifier<bool> showSuggestions;

  MarkupWordModel? _selectedMention;
  String _pattern = '';

  @override
  void initState() {
    showSuggestions = ValueNotifier(false);

    if (widget.controller != null) {
      controller = widget.controller!..mapping = getMarkupAnnotation();
    } else {
      controller = MarkupTextEditingController(getMarkupAnnotation());
    }

    if (widget.defaultText != null) {
      controller.text = widget.defaultText!;
    }

// setup a listener to figure out which suggestions to show based on the trigger
    controller.addListener(suggestionListener);
    controller.addListener(inputListeners);

    super.initState();
  }

  @override
  void dispose() {
    controller.removeListener(suggestionListener);
    controller.removeListener(inputListeners);
    if (widget.controller == null) {
      controller.dispose();
    }

    super.dispose();
  }

  @override
  void didUpdateWidget(oldWidget) {
    super.didUpdateWidget(oldWidget);
    controller.mapping = getMarkupAnnotation();
  }

  @override
  Widget build(BuildContext context) {
    // Filter the list based on the selection
    final list = _selectedMention != null
        ? widget.markupConfigs.firstWhere((element) => _selectedMention!.value.contains(element.trigger))
        : widget.markupConfigs[0];

    return PortalTarget(
      anchor: Aligned(
        widthFactor: 1,
        target: widget.suggestionPosition.isBottom ? Alignment.bottomCenter : Alignment.topCenter,
        follower: widget.suggestionPosition.isBottom ? Alignment.topCenter : Alignment.bottomCenter,
      ),
      portalFollower: ValueListenableBuilder(
        valueListenable: showSuggestions,
        builder: (BuildContext context, bool show, Widget? child) {
          if (!(show && !widget.hideSuggestionList)) {
            return const SizedBox.shrink();
          }
          return MarkupSuggestionOptionList(
            suggestionListHeight: widget.suggestionListHeight,
            suggestionBuilder: list.suggestionBuilder,
            suggestionListDecoration: widget.suggestionListDecoration,
            data: list.data.where(
              (element) {
                final e = element.display.toLowerCase();
                final str = _selectedMention!.value.toLowerCase().replaceAll(RegExp(_pattern), '');
                return e == str ? false : (e.contains(str) == true);
              },
            ).toList(),
            onTap: (value) {
              addMarkupData(value, list);
            },
          );
        },
      ),
      child: Row(
        children: [
          ...widget.leading,
          Expanded(
            child: CupertinoTextField(
              maxLines: widget.maxLines,
              minLines: widget.minLines,
              maxLength: widget.maxLength,
              focusNode: widget.focusNode,
              keyboardType: widget.keyboardType,
              keyboardAppearance: widget.keyboardAppearance,
              textInputAction: widget.textInputAction,
              textCapitalization: widget.textCapitalization,
              style: widget.style,
              textAlign: widget.textAlign,
              textDirection: widget.textDirection,
              readOnly: widget.readOnly,
              showCursor: widget.showCursor,
              autofocus: widget.autofocus,
              autocorrect: widget.autocorrect,
              maxLengthEnforcement: widget.maxLengthEnforcement,
              cursorColor: widget.cursorColor,
              cursorRadius: widget.cursorRadius,
              cursorWidth: widget.cursorWidth,
              autofillHints: widget.autofillHints,
              decoration: widget.decoration,
              expands: widget.expands,
              onEditingComplete: widget.onEditingComplete,
              onTap: widget.onTap,
              onSubmitted: widget.onSubmitted,
              enabled: widget.enabled,
              enableInteractiveSelection: widget.enableInteractiveSelection,
              enableSuggestions: widget.enableSuggestions,
              scrollController: widget.scrollController,
              scrollPadding: widget.scrollPadding,
              scrollPhysics: widget.scrollPhysics,
              controller: controller,
              placeholder: widget.placeholder,
              placeholderStyle: widget.placeholderStyle,
              textAlignVertical: widget.textAlignVertical,
              padding: widget.padding,
            ),
          ),
          ...widget.trailing,
        ],
      ),
    );
  }

  Map<String, MarkupAnnotationModel> getMarkupAnnotation() {
    final data = <String, MarkupAnnotationModel>{};

// Loop over all the mention items and generate a suggestions matching list
    for (var element in widget.markupConfigs) {
// if matchAll is set to true add a general regex pattern to match with
      if (element.matchAll) {
        data['${element.trigger}([A-Za-z0-9])*'] = MarkupAnnotationModel(
          style: element.style,
          id: null,
          display: null,
          trigger: element.trigger,
          disableMarkup: element.disableMarkup,
          markupConverter: element.markupConverter,
        );
      }

      for (var e in element.data) {
        data['${element.trigger}${e.display}'] = MarkupAnnotationModel(
          id: e.id,
          display: e.display,
          style: element.style,
          trigger: element.trigger,
          disableMarkup: element.disableMarkup,
          markupConverter: element.markupConverter,
        );
      }
    }

    return data;
  }

  void addMarkupData(MarkupDataModel value, [MarkupConfigModel? list]) {
    showSuggestions.value = false;

    final selectedMention = _selectedMention!;

    setState(() {
      _selectedMention = null;
    });

    final _list = widget.markupConfigs.firstWhere((element) => selectedMention.value.contains(element.trigger));

// find the text by range and replace with the new value.
    controller.text = controller.value.text.replaceRange(
      selectedMention.start,
      selectedMention.end,
      "${_list.trigger}${value.display}${widget.appendSpaceOnAdd ? ' ' : ''}",
    );

    if (widget.onMentionAdd != null) {
      widget.onMentionAdd!(value);
    }

// Move the cursor to next position after the new mentioned item.
    var nextCursorPosition = selectedMention.start + 1 + (value.display.length);
    if (widget.appendSpaceOnAdd) {
      nextCursorPosition++;
    }
    controller.selection = TextSelection.fromPosition(TextPosition(offset: nextCursorPosition));
  }

  void suggestionListener() {
    final cursorPos = controller.selection.baseOffset;

    if (cursorPos >= 0) {
      var _pos = 0;

      final mentionWords = <MarkupWordModel>[];

// split on each word and generate a list with start & end position of each word.
      controller.value.text.split(RegExp(r'(\s)')).forEach((element) {
        mentionWords.add(MarkupWordModel(value: element, start: _pos, end: _pos + element.length));
        _pos = _pos + element.length + 1;
      });

      final val = mentionWords.indexWhere((element) {
        _pattern = widget.markupConfigs.map((e) => e.trigger).join('|');
        return element.end == cursorPos && element.value.toLowerCase().contains(RegExp(_pattern));
      });

      showSuggestions.value = val != -1;

      if (widget.onSuggestionVisibleChanged != null) {
        widget.onSuggestionVisibleChanged!(val != -1);
      }

      setState(() {
        _selectedMention = val == -1 ? null : mentionWords[val];
      });
    }
  }

  void inputListeners() {
    if (widget.onChanged != null) {
      widget.onChanged!(controller.text);
    }

    if (widget.onMarkupChanged != null) {
      widget.onMarkupChanged!(controller.markupText);
    }

    if (widget.onSearchChanged != null && _selectedMention?.value != null) {
      final str = _selectedMention!.value.toLowerCase();

      widget.onSearchChanged!(str[0], str.substring(1));
    }
  }
}
