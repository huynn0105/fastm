import 'package:auto_route/auto_route.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:flutter_module/common/colors.dart';
import 'package:flutter_module/common/constants.dart';
import 'package:flutter_module/common/dialogs/dialog_provider.dart';
import 'package:flutter_module/common/enum/chat/thread_message_type.dart';
import 'package:flutter_module/common/global_function.dart';
import 'package:flutter_module/common/toast/toast_provider.dart';
import 'package:flutter_module/features/chat/cubit/file_handler/file_handler_cubit.dart';
import 'package:flutter_module/features/chat/cubit/thread_messages/thread_messages_cubit.dart';
import 'package:flutter_module/features/chat/page/thread_messages/inheritance/message_wrapper_provider.dart';
import 'package:flutter_module/features/chat/page/thread_messages/widgets/message/noitce_message_widget.dart';
import 'package:flutter_module/features/chat/page/thread_messages/widgets/message_layout.dart';
import 'package:flutter_module/features/chat/page/thread_messages/widgets/rounded_message_widget.dart';
import 'package:flutter_module/features/chat/page/thread_messages/widgets/swipeable_message_widget.dart';
import 'package:flutter_module/features/chat/page/thread_messages/components/message_options_component.dart';
import 'package:flutter_module/features/chat/page/thread_messages/inheritance/message_action_provider.dart';
import 'package:flutter_module/features/chat/page/thread_messages/items/message_content_item.dart';
import 'package:flutter_module/models/chat/message/message_model.dart';
import 'package:flutter_module/routes/routes.gr.dart';

class MessageItem extends StatelessWidget {
  const MessageItem({
    super.key,
    this.isPreviewMode = false,
    this.isDisabledGesture = false,
    this.padding = const EdgeInsets.symmetric(horizontal: 12),
  });

  final bool isPreviewMode;
  final bool isDisabledGesture;
  final EdgeInsets padding;

  @override
  Widget build(BuildContext context) {
    final data = MessageWrapperProvider.of(context).data;
    final id = data.message?.uid ?? '';
    final isMe = data.message?.isMe() == true;
    final isRecalled = data.message?.isRecalled == true;
    final alignment = isMe ? Alignment.centerRight : Alignment.centerLeft;

    if (data.message == null) {
      return data.header ?? const SizedBox();
    }

    if (data.message?.getMessageType().isNotice == true) {
      return NoticeMessageWidget(data: data);
    }

    Widget child = SwipeableMessageWidget(
      id: id,
      isMe: isMe,
      disabled: isRecalled,
      onSwiped: (_) => _onReply(context, data.message),
      child: Container(
        padding: padding,
        alignment: alignment,
        child: AnimatedSize(
          alignment: Alignment.topCenter,
          duration: const Duration(milliseconds: 500),
          child: RoundedMessageWidget(
            isMe: isMe,
            isFirstMessageInGroup: data.isFirstMessageInGroup,
            isLastMessageInGroup: data.isLastMessageInGroup,
            showBorder: isPreviewMode,
            child: MessageContentItem(
              data: data,
              isPreviewMode: isPreviewMode,
              onLongPress: () => _onLongPress(context, data.message),
            ),
          ),
        ),
      ),
    );

    if (!isPreviewMode && data.isFirstMessageInThread) {
      child = MessageColumn(
        isMe: isMe,
        children: [
          child,
          Visibility(
            visible: !isPreviewMode && data.isFirstMessageInThread,
            child: const SizedBox(height: 16),
          ),
        ],
      );
    }

    ///
    return IgnorePointer(
      ignoring: isPreviewMode || isDisabledGesture || isRecalled,
      child: child,
    );
  }

  _onReply(BuildContext context, MessageModel? message) {
    if (message == null) {
      return;
    }
    Future.delayed(AppConstants.duration, () {
      MessageActionProvider.of(context).onMessageReplied(context, message);
    });
  }

  _onLongPress(BuildContext context, MessageModel? message) {
    if (message == null) {
      return;
    }

    ///
    FocusManager.instance.primaryFocus?.unfocus();
    final action = MessageActionProvider.of(context);
    final data = MessageWrapperProvider.of(context).data;
    final type = message.getMessageType();

    ///
    final messageWidget = MultiBlocProvider(
      providers: [
        BlocProvider.value(
          value: context.read<FileHandlerCubit>(),
        ),
        BlocProvider.value(
          value: context.read<ThreadMessagesCubit>(),
        ),
      ],
      child: MessageWrapperProvider(
        key: ValueKey(data.message?.uid ?? ''),
        data: data.copyWith(
          showMessageCreateTime: false,
          showReceiverAvatar: false,
          message: message.toNewMessage().copyWith(
                author: message.author,
                medias: message.medias?.take(1).toList(),
              ),
        ),
        child: const MessageItem(
          isPreviewMode: true,
          padding: EdgeInsets.zero,
        ),
      ),
    );

    ///
    DialogProvider.instance.showBuilder(
      context: context,
      barrierDismissible: true,
      builder: (_) {
        return MessageOptionsComponent(
          data: data,
          messageWidget: messageWidget,
          showCopy: type.isText || type.isMention,
          showEdit: message.isMe() && type.isText && !(message.isEdited == true),
          showRecall: message.isMe() && !(message.isRecalled == true),
          onReacted: (value) {
            action.onReactionMessageSelected(context, message, value);
          },
          onCopied: () {
            GlobalFunction.copyText(data.message?.text ?? '');
            ToastProvider.instance.showCopy(context: context);
          },
          onReplied: () {
            action.onMessageReplied(context, message);
          },
          onForwarded: () {
            context.pushRoute(ChatForwardMessageRoute(message: message));
          },
          onEdited: () {
            action.onMessageEdited(context, message);
          },
          onRecalled: () {
            action.onMessageRecalled(context, message);
          },
          onDeleted: () {
            DialogProvider.instance.showMTradeDialog(
              context: context,
              asset: 'ic_mascot_question',
              titleColor: UIColors.red,
              messageColor: UIColors.defaultText,
              enableAutoPop: true,
              title: 'Xóa tin nhắn cho riêng bạn?',
              message: 'Tin nhắn này chỉ bị xóa ở phía bạn. Để xóa cho mọi người, hãy thu hồi tin nhắn.',
              positiveTitle: 'Đồng ý',
              negativeTitle: 'Huỷ bỏ',
              positiveCallback: () => action.onMessageDeleted(context, message),
            );
          },
        );
      },
    );
  }
}
