import 'package:flutter_module/models/base_model.dart';
import 'package:flutter_module/models/chat/contact/blocked_user_model.dart';
import 'package:flutter_module/models/chat/file/media_model.dart';
import 'package:flutter_module/models/chat/contact/chat_contact_model.dart';
import 'package:flutter_module/models/chat/contact/chat_request_contact_model.dart';
import 'package:flutter_module/models/chat/contact/chat_search_contact_model.dart';
import 'package:flutter_module/models/chat/message/message_model.dart';
import 'package:flutter_module/models/chat/message/user_on_message_model.dart';
import 'package:flutter_module/models/chat/rating/user_rating_model.dart';
import 'package:flutter_module/models/chat/support_request/chat_support_request_model.dart';
import 'package:flutter_module/models/chat/thread/chat_thread_model.dart';
import 'package:flutter_module/models/mtrade/my_review/mentor_rating_model.dart';
import 'package:flutter_module/services/api/api_provider.dart';
import 'package:flutter_module/services/api/chat/payload/create_thread/create_group_thread_payload.dart';
import 'package:flutter_module/services/api/chat/payload/create_thread/create_single_thread_payload.dart';
import 'package:flutter_module/services/api/chat/payload/rating/user_review_payload.dart';
import 'package:flutter_module/services/api/chat/payload/thread_messages/add_message_to_thread_payload.dart';
import 'package:flutter_module/services/api/chat/payload/file_upload_payload.dart';
import 'package:flutter_module/services/api/chat/payload/thread_messages/get_messages_in_thread_payload.dart';
import 'package:flutter_module/services/api/chat/payload/thread_messages/message_payload.dart';
import 'package:flutter_module/services/api/chat/payload/thread_messages/search_message_payload.dart';
import 'package:flutter_module/services/api/chat/payload/thread_messages/update_message_payload.dart';
import 'package:flutter_module/services/api/chat/payload/thread_messages/update_read_time_in_thread_pay_load.dart';
import 'package:flutter_module/services/api/chat/payload/thread_setting/update_background_image_payload.dart';
import 'package:flutter_module/services/local/local_data_provider.dart';

class ChatRepository {
  Future<BaseModel<ChatSupportRequestModel>> getListSupportRequest({
    required String userID,
    required String type,
    int page = 1,
  }) {
    return ApiProvider.instance.chat.getListSupportRequest(
      userID: userID,
      type: type,
      page: page,
    );
  }

  Future<void> insertMessagesToDb(List<MessageModel> messages) async {
    await LocalDataProvider.instance.chat.insertOrUpdateChatMessage(messages);
  }

  Future<void> insertOrUpdateMessageToDb(MessageModel message) async {
    await LocalDataProvider.instance.chat.insertOrUpdateMessage(message);
  }

  List<MessageModel> getMessagesInDb(String threadID) {
    return LocalDataProvider.instance.chat.getMessagesByThreadID(threadID);
  }
  List<ChatThreadModel> getChatThreadsInDb() {
    return LocalDataProvider.instance.thread.getThreadChats();
  }

  Future<void> insertOrUpdateThreadToDb(ChatThreadModel thread) async {
    await LocalDataProvider.instance.thread.insertOrUpdateThread(thread);
  }

  Future<void> insertChatThreadsToDb(List<ChatThreadModel> threadChats) async {
    await LocalDataProvider.instance.thread.insertOrUpdateChatThread(threadChats);
  }

  Future<BaseModel<List<MediaModel>>> uploadMultiFile({
    required FileUploadPayload payload,
  }) {
    return ApiProvider.instance.chat.mUploadMultiFile(payload: payload);
  }

  Future<BaseModel<List<MessageModel>>> getMessagesInThread({
    required GetMessagesInThreadPayload payload,
  }) {
    return ApiProvider.instance.chat.getMessagesInThread(payload: payload);
  }

  Future<BaseModel<MessageModel>> getExistedMessageInThread({
    required MessagePayload payload,
  }) {
    return ApiProvider.instance.chat.getExistedMessageInThread(payload: payload);
  }

  Future<BaseModel<List<MessageModel>>> searchMessage({
    required SearchMessagePayload payload,
  }) {
    return ApiProvider.instance.chat.searchMessage(payload: payload);
  }

  Future<BaseModel<String>> addMessageToThread({
    required AddMessageToThreadPayload payload,
  }) {
    return ApiProvider.instance.chat.addMessageToThread(payload: payload);
  }

  Future<BaseModel<String>> addLocalMessageToThread({
    required AddMessageToThreadPayload payload,
  }) {
    return ApiProvider.instance.chat.addLocalMessageToThread(payload: payload);
  }

  Future<BaseModel<MessageModel>> pushLocalMessage({
    required AddMessageToThreadPayload payload,
  }) {
    return ApiProvider.instance.chat.pushLocalMessage(payload: payload);
  }

  Future<BaseModel<bool>> updateMessage({
    required UpdateMessagePayload payload,
  }) {
    return ApiProvider.instance.chat.updateMessage(payload: payload);
  }

  Future<BaseModel<List<ChatThreadModel>>> getThreadsOfUser(String userID, {int? fromUpdateTime}) {
    return ApiProvider.instance.chat.getThreadsOfUser(userID, fromUpdateTime: fromUpdateTime);
  }

  Future<BaseModel<List<ChatContactModel>>> getContactsOnline() {
    return ApiProvider.instance.chat.getContactsOnline();
  }

  Future<BaseModel<List<ChatSearchContactModel>>> searchContact({
    required String keyword,
  }) {
    return ApiProvider.instance.chat.searchContact(keyword: keyword);
  }

  Future<BaseModel<bool>> sendRequestAddContact({
    required String nickname,
    required String phoneNumber,
  }) {
    return ApiProvider.instance.chat.sendRequestAddContact(nickname: nickname, phoneNumber: phoneNumber);
  }

  Future<BaseModel<Map<String, List<ChatRequestContactModel>>>> getInvitationAndSendingRequest() {
    return ApiProvider.instance.chat.getInvitationAndSendingRequest();
  }

  Future<BaseModel<bool>> cancelRequestContact({required String phoneNumber}) {
    return ApiProvider.instance.chat.cancelRequestContact(phoneNumber: phoneNumber);
  }

  Future<BaseModel<bool>> acceptRequestContact({required String acceptedUserID, required String invitationID}) {
    return ApiProvider.instance.chat.acceptRequestContact(acceptedUserID: acceptedUserID, invitationID: invitationID);
  }

  Future<BaseModel<bool>> rejectRequestContact({required String senderID}) {
    return ApiProvider.instance.chat.rejectRequestContact(senderID: senderID);
  }

  Future<BaseModel<List<ChatContactModel>>> getContacts() {
    return ApiProvider.instance.chat.getContacts();
  }

  Future<BaseModel<bool>> updateBackgroundImage({
    required UpdateBackgroundImagePayload payload,
  }) {
    return ApiProvider.instance.chat.updateBackgroundImage(payload: payload);
  }

  Future<BaseModel<bool>> toggleUserNotificationOnInThread({
    required String threadID,
    required bool isOn,
  }) {
    return ApiProvider.instance.chat.toggleUserNotificationOnInThread(
      threadID: threadID,
      isOn: isOn,
    );
  }

  Future<BaseModel<bool>> toggleUserFavoriteInThread({
    required String threadID,
    required bool isFavorite,
  }) {
    return ApiProvider.instance.chat.toggleUserFavoriteInThread(
      threadID: threadID,
      isFavorite: isFavorite,
    );
  }

  Future<BaseModel<bool>> deleteChatThread({
    required String threadID,
  }) {
    return ApiProvider.instance.chat.deleteChatThread(
      threadID: threadID,
    );
  }

  Future<BaseModel<List<MessageModel>>> getImageMessagesInThread({
    required String threadID,
    int? maxMessages,
  }) {
    return ApiProvider.instance.chat.getImageMessagesInThread(
      threadID: threadID,
      maxMessages: maxMessages,
    );
  }

  Future<BaseModel<List<MessageModel>>> getVideoMessagesInThread({
    required String threadID,
    int? maxMessages,
  }) {
    return ApiProvider.instance.chat.getVideoMessagesInThread(
      threadID: threadID,
      maxMessages: maxMessages,
    );
  }

  Future<BaseModel<ChatThreadModel>> createThreadGroup({
    required CreateGroupThreadPayload payload,
  }) {
    return ApiProvider.instance.chat.createThreadGroup(
      payload: payload,
    );
  }

  Future<BaseModel<ChatThreadModel>> createSingleThread({
    required CreateSingleThreadPayload payload,
  }) {
    return ApiProvider.instance.chat.createSingleThread(
      payload: payload,
    );
  }

  Future<BaseModel<bool>> addUsersToGroupThread({
    required String threadID,
    required List<ThreadUserDetail> users,
  }) {
    return ApiProvider.instance.chat.addUsersToGroupThread(
      threadID: threadID,
      users: users,
    );
  }

  Future<BaseModel<bool>> leaveChatThread({
    required String threadID,
  }) {
    return ApiProvider.instance.chat.leaveChatThread(
      threadID: threadID,
    );
  }

  Future<BaseModel<List<ChatThreadModel>>> getThreadsFromThreadIDs({
    required List<String> threadIDs,
  }) {
    return ApiProvider.instance.chat.getThreadsFromThreadIDs(
      threadIDs: threadIDs,
    );
  }

  Future<BaseModel<bool>> updateTitleGroupThread({
    required String threadID,
    required String title,
  }) {
    return ApiProvider.instance.chat.updateTitleGroupThread(
      threadID: threadID,
      title: title,
    );
  }

  Future<BaseModel<bool>> updateReadTimeToNowInThread({
    required UpdateReadTimeInThreadPayload payload,
  }) {
    return ApiProvider.instance.chat.updateReadTimeToNowInThread(
      payload: payload,
    );
  }

  Future<BaseModel<bool>> updateUserReadTimeInThread({
    required UpdateReadTimeInThreadPayload payload,
  }) {
    return ApiProvider.instance.chat.updateUserReadTimeInThread(
      payload: payload,
    );
  }

  Future<BaseModel<bool>> block({
    required String userID,
  }) {
    return ApiProvider.instance.chat.block(
      userID: userID,
    );
  }

  Future<BaseModel<bool>> unblock({
    required String userID,
  }) {
    return ApiProvider.instance.chat.unblock(
      userID: userID,
    );
  }

  Future<BaseModel<bool>> checkBeBlocked({
    required String threadID,
    required String userID,
  }) {
    return ApiProvider.instance.chat.checkBeBlocked(
      threadID: threadID,
      userID: userID,
    );
  }

  Future<BaseModel<int>> getTotalUnreadInThread({
    required String threadID,
    required int readTime,
  }) {
    return ApiProvider.instance.chat.getTotalUnreadInThread(
      threadID: threadID,
      readTime: readTime,
    );
  }

  Future<BaseModel<UserOnMessageModel>> getUserChat({
    required String userID,
  }) {
    return ApiProvider.instance.chat.getUserChat(
      userID: userID,
    );
  }

  Future<BaseModel<MentorRatingModel>> getReviews({required UserReviewPayload payload}) {
    return ApiProvider.instance.chat.getReviews(
      payload: payload,
    );
  }

  Future<BaseModel<UserRatingModel>> getUserRating({required String userID}) {
    return ApiProvider.instance.chat.getUserRating(
      userID: userID,
    );
  }

  Future<BaseModel<List<BlockedUserModel>>> getBlockedUsers() {
    return ApiProvider.instance.chat.getBlockedUsers();
  }
}
