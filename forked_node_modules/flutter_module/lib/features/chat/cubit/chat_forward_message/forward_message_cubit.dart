import 'package:bloc/bloc.dart';
import 'package:collection/collection.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter_module/app_data.dart';
import 'package:flutter_module/common/bloc_status.dart';
import 'package:flutter_module/common/enum/chat/forward_contact_type.dart';
import 'package:flutter_module/common/enum/chat/quoted_message_type.dart';
import 'package:flutter_module/features/chat/repository/chat_repository.dart';
import 'package:flutter_module/models/chat/contact/chat_contact_model.dart';
import 'package:flutter_module/models/chat/contact/forward_contact_model.dart';
import 'package:flutter_module/models/chat/message/message_model.dart';
import 'package:flutter_module/models/chat/thread/chat_thread_model.dart';
import 'package:flutter_module/services/api/chat/payload/thread_messages/add_message_to_thread_payload.dart';

part 'forward_message_state.dart';

class ChatForwardMessageCubit extends Cubit<ChatForwardMessageState> {
  ChatForwardMessageCubit() : super(const ChatForwardMessageState());

  final ChatRepository _repository = ChatRepository();

  MessageModel? rawMessage;
  List<ChatThreadModel> rawThreads = [];
  List<ChatContactModel> rawContacts = [];

  initData({
    required MessageModel? message,
    required List<ChatThreadModel> threads,
    required List<ChatContactModel> contacts,
  }) {
    rawMessage = message;
    rawThreads = threads;
    rawContacts = contacts;

    List<ForwardContactModel> fwRecentContacts = [];
    List<ForwardContactModel> fwGroupThreads = [];
    List<ForwardContactModel> fwFriendContacts = [];

    for (var thread in threads) {
      if (thread.isSingleThread() == true) {
        fwRecentContacts.add(
          ForwardContactModel.fromThread(thread).copyWith(type: ForwardContactType.recent.name),
        );
      } else {
        fwGroupThreads.add(
          ForwardContactModel.fromThread(thread).copyWith(type: ForwardContactType.group.name),
        );
      }
    }
    for (var contact in contacts) {
      fwFriendContacts.add(
        ForwardContactModel.fromContact(contact).copyWith(type: ForwardContactType.friend.name),
      );
    }

    emit(state.copyWith(
      status: BlocStatus.success,
      recentContacts: fwRecentContacts,
      groupContacts: fwGroupThreads,
      friendContacts: fwFriendContacts,
    ));
  }

  _select({
    required List<ForwardContactModel> data,
    required ForwardContactModel value,
  }) {
    data = [...data];
    var index = data.indexWhere((e) => e.uid == value.uid);
    if (index >= 0) {
      data.removeAt(index);
    } else {
      data.add(value);
    }
    return data;
  }

  selectRecentContact(ForwardContactModel value) {
    final data = _select(data: state.selectedRecentContacts, value: value);
    emit(state.copyWith(
      selectedRecentContacts: data,
    ));
  }

  selectGroupContact(ForwardContactModel value) {
    final data = _select(data: state.selectedGroupContacts, value: value);
    emit(state.copyWith(
      selectedGroupContacts: data,
    ));
  }

  selectFriendContact(ForwardContactModel value) {
    final data = _select(data: state.selectedFriendContacts, value: value);
    emit(state.copyWith(
      selectedFriendContacts: data,
    ));
  }

  selectAll(List<ForwardContactModel> value) {
    final data = groupBy(value, (e) => e.type);
    emit(state.copyWith(
      selectedRecentContacts: data[ForwardContactType.recent.name],
      selectedGroupContacts: data[ForwardContactType.group.name],
      selectedFriendContacts: data[ForwardContactType.friend.name],
    ));
  }

  List<ForwardContactModel> getAllContacts() {
    return [
      ...state.selectedRecentContacts,
      ...state.selectedGroupContacts,
      ...state.selectedFriendContacts,
    ];
  }

  updateDescription(String value) {
    emit(state.copyWith(
      description: value,
    ));
  }

  sendMessage(
    String threadID,
    MessageModel message, {
    bool forwarding = false,
  }) async {
    message = message.toNewMessage();
    await _repository.addMessageToThread(
      payload: AddMessageToThreadPayload(
        threadID: threadID,
        message: message.copyWith(
          threadID: threadID,
          author: AppData.instance.author,
          quotedType: forwarding ? QuotedMessageType.forward.name : null,
        ),
      ),
    );
  }

  submit() async {
    wrapper(String? threadID, MessageModel quoted, String description) async {
      await sendMessage(threadID ?? '', quoted, forwarding: true);
      if (description.isNotEmpty) {
        await sendMessage(threadID ?? '', MessageModel.newTextMessage(text: description));
      }
    }

    emit(state.copyWith(
      submitStatus: BlocStatus.loading,
    ));

    ///
    for (var g in state.selectedRecentContacts) {
      await wrapper(g.uid, rawMessage!, state.description);
    }
    for (var g in state.selectedGroupContacts) {
      await wrapper(g.uid, rawMessage!, state.description);
    }
    for (var g in state.selectedFriendContacts) {
      final thread = rawThreads
          .where((e) => e.isSingleThread() == true)
          .firstWhereOrNull((e) => e.getSingleThreadTargetUser()?.uid == g.uid);
      if (thread != null) {
        await wrapper(thread.uid ?? '', rawMessage!, state.description);
      }
    }

    emit(state.copyWith(
      submitStatus: BlocStatus.success,
    ));
  }
}
