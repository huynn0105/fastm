import 'dart:async';

import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter/material.dart';
import 'package:flutter_keyboard_visibility/flutter_keyboard_visibility.dart';
import 'package:flutter_module/common/constants.dart';
import 'package:flutter_module/common/enum/chat/thread_action_type.dart';

import 'package:flutter_module/common/widgets/scrollable_positioned_list/scrollable_positioned_list.dart';
import 'package:flutter_module/features/chat/page/thread_messages/widgets/markup_input/markup_text_editing_controller.dart';
import 'package:flutter_module/services/local/local_data_helper.dart';
import 'package:keyboard_height_plugin/keyboard_height_plugin.dart';

part 'thread_action_state.dart';

class ThreadActionCubit extends Cubit<ThreadActionState> {
  ThreadActionCubit() : super(const ThreadActionState()) {
    addScrollListener();
    keyboardPlugin.onKeyboardHeightChanged(_listenKeyboardHeightChanged);
    keyboardSubscription = KeyboardVisibilityController().onChange.listen(_listenVisibleKeyboardChanged);
  }

  final FocusNode inputFocusNode = FocusNode();
  final MarkupTextEditingController inputController = MarkupTextEditingController({});
  final ItemScrollController itemScrollController = ItemScrollController();
  final ItemPositionsListener itemPositionsListener = ItemPositionsListener.create();
  final ScrollOffsetController scrollOffsetController = ScrollOffsetController();
  final ScrollOffsetListener scrollOffsetListener = ScrollOffsetListener.create();
  final KeyboardHeightPlugin keyboardPlugin = KeyboardHeightPlugin();
  late final StreamSubscription keyboardSubscription;

  _listenKeyboardHeightChanged(double height) {
    double kKeyboardHeight = LocalDataHelper.instance.getKeyboardHeight() ?? 0;
    if (height != kKeyboardHeight && height > 0) {
      LocalDataHelper.instance.setKeyboardHeight(height);
      emit(state.copyWith(
        keyboardHeight: height,
      ));
    }
  }

  _listenVisibleKeyboardChanged(bool visible) {
    if (visible && !state.showKeyboard) {
      updateVisibleKeyboard(true);
    } else if (!visible && state.showKeyboard) {
      updateVisibleKeyboard(false);
      if (state.action == ThreadActionType.input) {
        updateAction(ThreadActionType.none);
      }
    }
  }

  onScrollListen() {
    final itemPositions = itemPositionsListener.itemPositions.value.toList();
    if (itemPositions.isNotEmpty) {
      final minEdge = itemPositions
          .where((pos) => pos.itemTrailingEdge > 0)
          .reduce((min, pos) => pos.itemTrailingEdge < min.itemTrailingEdge ? pos : min)
          .index;
      // final maxEdge = itemPositions
      //     .where((pos) => pos.itemLeadingEdge < 1)
      //     .reduce((max, pos) => pos.itemLeadingEdge > max.itemLeadingEdge ? pos : max)
      //     .index;

      final enabled = minEdge > 0;

      emit(state.copyWith(
        showScrollToTopButton: enabled,
      ));
    }
  }

  addScrollListener() {
    itemPositionsListener.itemPositions.addListener(onScrollListen);
  }

  removeScrollListener() {
    itemPositionsListener.itemPositions.removeListener(onScrollListen);
  }

  updateAction(ThreadActionType action, {bool force = false}) {
    if (!force) {
      action = state.action == action && state.action != ThreadActionType.input ? ThreadActionType.none : action;
    }
    emit(state.copyWith(
      action: action,
    ));
  }

  updateVisibleKeyboard(bool visible) {
    emit(state.copyWith(
      showKeyboard: visible,
    ));
  }

  updateVisibleScrollToTop(bool visible) {
    emit(state.copyWith(
      showScrollToTopButton: visible,
    ));
  }

  focusInput({required bool delay}) async {
    if (delay) {
      await Future.delayed(AppConstants.duration);
    }
    if (!inputFocusNode.hasFocus) {
      inputFocusNode.requestFocus();
    }
  }

  unfocusInput({required bool delay}) {
    if (delay) {
      Future.delayed(AppConstants.duration, inputFocusNode.unfocus);
      return;
    }
    inputFocusNode.unfocus();
  }

  scrollToTop() {
    itemScrollController.jumpTo(
      index: 0,
      alignment: 0.0,
    );
  }

  Future<void> scrollToIndex(int index) async {
    return await itemScrollController.scrollTo(
      index: index,
      alignment: 0.5,
      curve: Curves.easeInOutCubic,
      duration: const Duration(milliseconds: 700),
    );
  }

  @override
  Future<void> close() {
    removeScrollListener();
    keyboardPlugin.dispose();
    keyboardSubscription.cancel();
    inputFocusNode.dispose();
    inputController.dispose();
    return super.close();
  }
}
