import 'dart:io';

import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter_module/common/bloc_status.dart';
import 'package:flutter_module/common/extension/list_extension.dart';
import 'package:flutter_module/common/utils/image_util.dart';
import 'package:flutter_module/features/chat/repository/chat_repository.dart';
import 'package:flutter_module/models/base_model.dart';
import 'package:flutter_module/models/chat/thread/chat_thread_model.dart';
import 'package:flutter_module/services/api/chat/payload/file_upload_payload.dart';
import 'package:flutter_module/services/api/chat/payload/thread_setting/update_background_image_payload.dart';
import 'package:image_picker/image_picker.dart';

part 'chat_setting_state.dart';

class ChatSettingCubit extends Cubit<ChatSettingState> {
  ChatSettingCubit() : super(const ChatSettingState());

  final ChatRepository _repository = ChatRepository();
  String threadID = '';

  initState(
    ChatThreadModel thread, {
    bool? isBlock = false,
  }) {
    threadID = thread.uid ?? '';
    emit(state.copyWith(
      isNotificationOn: thread.isNotificationOn(),
      isFavorite: thread.isFavorite(),
      isBlock: isBlock,
    ));
  }

  updateBackgroundImage({
    File? file,
  }) async {
    String urlImage = '';
    if (file != null) {
      emit(state.copyWith(
        backgroundImageStatus: BlocStatus.loading,
      ));

      final compressed = await ImageUtil.compressImage(file: file);
      final imageResult = await _repository.uploadMultiFile(
        payload: FileUploadPayload(
          files: [File(compressed?.path ?? '')],
        ),
      );

      if (imageResult.status == false) {
        emit(state.copyWith(
          backgroundImageStatus: BlocStatus.failure,
        ));
        return;
      }

      urlImage = imageResult.data?.getFirst()?.url ?? '';
    }

    final updateResult = await _repository.updateBackgroundImage(
      payload: UpdateBackgroundImagePayload(
        threadID: threadID,
        backgroundImage: urlImage,
      ),
    );

    if (updateResult.status) {
      emit(state.copyWith(
        backgroundImageStatus: BlocStatus.success,
      ));
    } else {
      emit(state.copyWith(
        backgroundImageStatus: BlocStatus.failure,
      ));
    }
  }

  updateAvatarImage({
    File? file,
  }) async {
    String urlImage = '';
    if (file != null) {
      emit(state.copyWith(
        avatarStatus: BlocStatus.loading,
      ));

      final compressed = await ImageUtil.compressImage(file: file);
      if (compressed == null) return;
      final imageResult = await _repository.uploadMultiFile(
        payload: FileUploadPayload(
          files: [File(compressed.path ?? '')],
        ),
      );

      if (imageResult.status == false) {
        emit(state.copyWith(
          avatarStatus: BlocStatus.failure,
        ));
        return;
      }

      urlImage = imageResult.data?.getFirst()?.url ?? '';
    }

    final updateResult = await _repository.updateBackgroundImage(
      payload: UpdateBackgroundImagePayload(
        threadID: threadID,
        photoImage: urlImage,
      ),
    );

    if (updateResult.status) {
      emit(state.copyWith(
        avatarStatus: BlocStatus.success,
      ));
    } else {
      emit(state.copyWith(
        avatarStatus: BlocStatus.failure,
      ));
    }
  }

  toggleUserNotificationOnInThread({
    required bool isOn,
  }) async {
    emit(state.copyWith(
      notificationStatus: BlocStatus.loading,
      isNotificationOn: isOn,
    ));

    final updateResult = await _repository.toggleUserNotificationOnInThread(
      threadID: threadID,
      isOn: isOn,
    );

    if (updateResult.status) {
      emit(state.copyWith(
        notificationStatus: BlocStatus.success,
      ));
      return true;
    } else {
      emit(state.copyWith(
        notificationStatus: BlocStatus.failure,
        isNotificationOn: !isOn,
      ));
      return false;
    }
  }

  toggleUserFavoriteInThread({
    required bool isFavorite,
  }) async {
    emit(state.copyWith(
      favoriteStatus: BlocStatus.loading,
      isFavorite: isFavorite,
    ));

    final updateResult = await _repository.toggleUserFavoriteInThread(
      threadID: threadID,
      isFavorite: isFavorite,
    );

    if (updateResult.status) {
      emit(state.copyWith(
        favoriteStatus: BlocStatus.success,
      ));
      return true;
    } else {
      emit(state.copyWith(
        favoriteStatus: BlocStatus.failure,
        isFavorite: !isFavorite,
      ));
      return false;
    }
  }

  deleteChatThread() async {
    emit(state.copyWith(
      deleteStatus: BlocStatus.loading,
    ));

    final deleteResult = await _repository.deleteChatThread(
      threadID: threadID,
    );

    if (deleteResult.status) {
      emit(state.copyWith(
        deleteStatus: BlocStatus.success,
      ));
      return true;
    } else {
      emit(state.copyWith(
        deleteStatus: BlocStatus.failure,
      ));
      return false;
    }
  }

  leaveChatThread() async {
    emit(state.copyWith(
      leaveStatus: BlocStatus.loading,
    ));

    final result = await _repository.leaveChatThread(
      threadID: threadID,
    );

    if (result.status) {
      emit(state.copyWith(
        leaveStatus: BlocStatus.success,
      ));
    } else {
      emit(state.copyWith(
        leaveStatus: BlocStatus.failure,
      ));
    }
  }

  updateTitleGroupThread({required String title}) async {
    final result = await _repository.updateTitleGroupThread(
      threadID: threadID,
      title: title,
    );
  }

  toggleUserBlockInThread({
    required bool isBlock,
    required String userID,
  }) async {
    late final BaseModel<bool> result;
    emit(state.copyWith(
      blockStatus: BlocStatus.initial,
    ));
    if (isBlock) {
      result = await _repository.block(userID: userID);
    } else {
      result = await _repository.unblock(userID: userID);
    }

    if (result.status) {
      emit(state.copyWith(
        blockStatus: BlocStatus.success,
        isBlock: isBlock,
      ));
      return true;
    } else {
      emit(state.copyWith(
        blockStatus: BlocStatus.failure,
        isBlock: isBlock,
      ));
      return false;
    }
  }
}
