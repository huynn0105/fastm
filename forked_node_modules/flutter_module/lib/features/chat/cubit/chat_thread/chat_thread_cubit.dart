import 'package:bloc/bloc.dart';
import 'package:collection/collection.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter_module/app_data.dart';
import 'package:flutter_module/common/bloc_status.dart';
import 'package:flutter_module/common/extension/iterable_extension.dart';
import 'package:flutter_module/common/extension/list_extension.dart';
import 'package:flutter_module/features/chat/repository/chat_repository.dart';
import 'package:flutter_module/models/base_model.dart';
import 'package:flutter_module/models/chat/message/chat_message_model.dart';
import 'package:flutter_module/models/chat/thread/chat_thread_model.dart';
import 'package:flutter_module/services/api/chat/payload/create_thread/create_single_thread_payload.dart';
import 'package:flutter_module/services/api/chat/payload/thread_messages/update_read_time_in_thread_pay_load.dart';
import 'package:flutter_module/services/firebase/firebase_database/firebase_database_util.dart';

part 'chat_thread_state.dart';

class ChatThreadCubit extends Cubit<ChatThreadState> {
  ChatThreadCubit() : super(const ChatThreadState());
  final ChatRepository _repository = ChatRepository();

  fetchThreads({bool? loadmore = false, bool forceResetData = false}) async {
    emit(state.copyWith(
      status: BlocStatus.loading,
      threads: forceResetData ? [] : null,
      threadMessages: forceResetData ? {} : null,
    ));

    int? fromUpdateTime;

    final chatThreadsLocal = _repository.getChatThreadsInDb();
    if (loadmore == false) {
      emit(state.copyWith(
        status: BlocStatus.success,
        threads: chatThreadsLocal,
      ));
    }

    if (loadmore == true) {
      fromUpdateTime = (getLastThread()?.createTime ?? 1) - 1;
    }

    final result = await _repository.getThreadsOfUser(
      AppData.instance.userID,
      fromUpdateTime: fromUpdateTime,
    );
    final resultData = result.data ?? [];
    if (result.status == true) {
      final dataRemote = loadmore == true
          ? [...state.threads, ...resultData]
              .map((e) => e)
              .distinctByCondition(
                (e) => e.uid ?? '',
              )
              .toList()
          : resultData;
      dataRemote.sort((a, b) => b.updateTime!.compareTo(a.updateTime!));

      for (var thread in state.threads) {
        final indexThread = dataRemote.indexWhere(
          (element) => element.uid == thread.uid,
        );
        if (indexThread < 0) {
          continue;
        }
        dataRemote[indexThread] = dataRemote[indexThread].copyWith(
          lastMessage: thread.lastMessage,
        );
      }

      emit(state.copyWith(
        status: BlocStatus.success,
        threads: dataRemote,
        isDataRemote: true,
      ));
      if (loadmore == false) {
        await _repository.insertChatThreadsToDb(dataRemote);
      }
    } else {
      emit(state.copyWith(
        status: BlocStatus.failure,
        errorMessage: result.errorMessage,
      ));
    }
  }

  addNewMessage({required ChatMessageModel message}) {
    final newThreadMessages = {...state.threadMessages};

    final messages = newThreadMessages["${message.threadID}"] ?? [];
    final isExistMessage = messages.firstWhereIndexedOrNull((index, element) => element.uid == message.uid) != null;
    if (isExistMessage) return;

    newThreadMessages["${message.threadID}"] = messages..add(message);

    emit(state.copyWith(
      threadMessages: newThreadMessages,
    ));

    setLastMessageInThread(messages, message.threadID);
    increaseUnreadMessage(message.threadID ?? '');
  }

  changeMessage({required ChatMessageModel message}) {
    final newThreadMessages = {...state.threadMessages};
    final messages = newThreadMessages["${message.threadID}"] ?? [];
    final indexMessage = messages.indexWhere((element) => element.uid == message.uid);

    if (indexMessage < 0) {
      newThreadMessages["${message.threadID}"] = messages..add(message);
    } else {
      newThreadMessages["${message.threadID}"]![indexMessage] = message;
    }

    setLastMessageInThread(messages, message.threadID);
    resetUnreadMessage(message.threadID ?? '');
  }

  ChatMessageModel? getLastMessage(List<ChatMessageModel> messages) {
    messages.sort(
      (a, b) => (b.createTime ?? 0).compareTo(a.createTime ?? 0),
    );
    final lastMessage = messages.firstOrNull;
    return lastMessage;
  }

  ChatThreadModel? getLastThread() {
    final threads = [...state.threads];

    threads.sort(
      (a, b) => (b.createTime ?? 0).compareTo(a.createTime ?? 0),
    );
    final lastThread = threads.firstOrNull;
    return lastThread;
  }

  setLastMessageInThread(List<ChatMessageModel> messages, String? threadID) {
    final List<ChatThreadModel> newThreads = [...state.threads];

    final indexThread = newThreads.indexWhere(
      (element) => element.uid == threadID,
    );
    if (indexThread < 0) {
      return;
    }
    newThreads[indexThread] = newThreads[indexThread].copyWith(
      lastMessage: getLastMessage(messages),
    );

    emit(state.copyWith(
      threads: newThreads,
    ));
    _repository.insertOrUpdateThreadToDb(newThreads[indexThread]);
  }

  increaseUnreadMessage(String threadID) {
    final Map<String, int> newThreadUnread = {...state.threadUnread};
    final thread = state.threads.firstWhereIndexedOrNull((index, element) => element.uid == threadID);
    if ((thread?.lastMessage?.createTime ?? 0) > (thread?.getLastReadTime() ?? 0)) {
      newThreadUnread[threadID] = (newThreadUnread[threadID] ?? 0) + 1;

      emit(state.copyWith(
        threadUnread: newThreadUnread,
      ));
    }
  }

  resetUnreadMessage(String threadID) {
    final Map<String, int> newThreadUnread = {...state.threadUnread};
    final thread = state.threads.firstWhereIndexedOrNull((index, element) => element.uid == threadID);

    if ((thread?.getLastReadTime() ?? 0) > (thread?.lastMessage?.createTime ?? 0)) {
      newThreadUnread[threadID] = 0;
    }

    emit(state.copyWith(
      threadUnread: newThreadUnread,
    ));
  }

  changeThread({required ChatThreadModel thread}) {
    List<ChatThreadModel> newThreads = [...state.threads];
    final indexThread = newThreads.indexWhere(
      (element) => element.uid == thread.uid,
    );
    if (indexThread < 0) {
      newThreads = newThreads..add(thread);
    } else {
      newThreads[indexThread] = newThreads[indexThread].merge(thread);
    }
    newThreads = newThreads.where((element) {
      final isValid = FirebaseDatabaseUtil.isThreadValid(element);
      return isValid;
    }).toList();
    newThreads.sort((a, b) => (b.updateTime ?? 0).compareTo(a.updateTime ?? 0));
    emit(state.copyWith(
      threads: newThreads,
    ));
    resetUnreadMessage(thread.uid ?? '');
    _repository.insertOrUpdateThreadToDb(newThreads[indexThread]);
  }

  typingThread({
    required String threadID,
    Map<String, bool>? typings,
  }) {
    List<ChatThreadModel> newThreads = [...state.threads];
    final indexThread = newThreads.indexWhere(
      (element) => element.uid == threadID,
    );
    if (indexThread < 0) {
      return;
    }

    newThreads[indexThread] = newThreads[indexThread].copyWith(typings: typings);
    newThreads.sort((a, b) => (b.updateTime ?? 0).compareTo(a.updateTime ?? 0));
    emit(state.copyWith(
      threads: newThreads,
    ));
  }

  newThread({required String threadID}) async {
    final threadResult = await _repository.getThreadsFromThreadIDs(threadIDs: [threadID]);
    if (threadResult.status) {
      final ChatThreadModel? thread = threadResult.data?.getFirst();
      if (thread == null) return;

      changeThread(thread: thread);
    }
  }

  ChatThreadModel? getThreadWithUserID({String userID = ''}) {
    final thread = state.threads.firstWhereOrNull((element) => element.getSingleThreadTargetUser()?.uid == userID);
    return thread;
  }

  ChatThreadModel? getThreadWithThreadID({String threadID = ''}) {
    final thread = state.threads.firstWhereOrNull((element) => element.uid == threadID);
    return thread;
  }

  Future<ChatThreadModel?> createSingleThread({
    required ThreadUserDetail user1,
    required ThreadUserDetail user2,
  }) async {
    emit(state.copyWith(
      openChatThreadStatus: BlocStatus.loading,
    ));

    final result = await _repository.createSingleThread(
      payload: CreateSingleThreadPayload(
        user1: user1,
        user2: user2,
      ),
    );

    if (result.status) {
      emit(state.copyWith(
        openChatThreadStatus: BlocStatus.success,
      ));
    } else {
      emit(state.copyWith(
        openChatThreadStatus: BlocStatus.failure,
      ));
    }

    return result.data;
  }

  updateReadTimeToNow({
    required String threadID,
    required String userID,
  }) async {
    await _repository.updateUserReadTimeInThread(
      payload: UpdateReadTimeInThreadPayload(
        threadID: threadID,
        userID: userID,
      ),
    );
  }

  updateBlockThreads({required Map<String, bool> blockThreads}) {
    emit(state.copyWith(blockThreads: blockThreads));
  }

  bool isBlockedThread(String? threadID) {
    return state.blockThreads[threadID ?? ''] == true;
  }

  getTotalUnreadMessageInThreads({required List<ChatThreadModel> threads}) async {
    final List<Future<BaseModel<int>>> futures = [];
    Map<String, int> threadUnread = {};

    for (final thread in threads) {
      futures.add(
          _repository.getTotalUnreadInThread(threadID: thread.uid ?? "", readTime: thread.getLastReadTime() ?? 0).then(
        (value) {
          threadUnread[thread.uid ?? ""] = (threadUnread[thread.uid] ?? 0) + (value.data ?? 0);
          return value;
        },
      ));
    }

    await Future.wait(futures);

    emit(state.copyWith(
      threadUnread: threadUnread,
    ));
  }

  Future<ChatThreadModel?> getSingleThreadAndCreateIfNotExisted({String? userID}) async {
    ChatThreadModel? thread;

    /// Local
    thread = getThreadWithUserID(userID: userID ?? '');
    if (thread != null) {
      return thread;
    }

    /// Remote
    final generatedSingleThreadID = FirebaseDatabaseUtil.generateSingleThreadID(
      userID1: AppData.instance.userID,
      userID2: userID,
    );
    final remoteResult = await _repository.getThreadsFromThreadIDs(threadIDs: [generatedSingleThreadID ?? '']);
    if (remoteResult.data?.isNotEmpty == true) {
      thread = remoteResult.data.getFirst();
      if (thread != null) {
        return thread;
      }
    }

    /// Create
    final targetUser = await _repository.getUserChat(userID: userID ?? '');
    if (targetUser.data == null) {
      return null;
    }
    thread = await createSingleThread(
      user1: ThreadUserDetail.fromAuthor(AppData.instance.author),
      user2: ThreadUserDetail.fromUserOnMessageModel(targetUser.data),
    );
    return thread;
  }

  clearData() {
    emit(const ChatThreadState());
  }
}
