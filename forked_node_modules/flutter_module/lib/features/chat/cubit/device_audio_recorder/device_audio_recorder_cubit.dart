import 'dart:async';
import 'dart:io';

import 'package:audio_waveforms/audio_waveforms.dart';
import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter_module/common/bloc_status.dart';
import 'package:flutter_module/common/enum/chat/media_type.dart';
import 'package:flutter_module/common/utils/log_util.dart';
import 'package:flutter_module/models/chat/file/media_model.dart';
import 'package:path_provider/path_provider.dart';

part 'device_audio_recorder_state.dart';

class DeviceAudioRecorderCubit extends Cubit<DeviceAudioRecorderState> {
  DeviceAudioRecorderCubit() : super(const DeviceAudioRecorderState()) {
    // initRecorder();
  }

  /// Record
  // final FlutterSoundRecorder soundRecordController = FlutterSoundRecorder();

  /// Wave
  PlayerController wavePlayerController = PlayerController();
  final RecorderController waveRecorderController = RecorderController();

  String? _uid;
  Directory? _dir;

  // initRecorder() async {
  //   await soundRecordController.openRecorder();
  //   await soundRecordController.setSubscriptionDuration(const Duration(milliseconds: 100));
  // }
  //
  // startRecorder() async {
  //   final hasPermission = await waveRecorderController.checkPermission();
  //   if (!hasPermission || soundRecordController.isRecording) {
  //     return;
  //   }
  //
  //   ///
  //   _dir = await getTemporaryDirectory();
  //   _uid = 'audio_${DateTime.now().millisecondsSinceEpoch}';
  //
  //   ///
  //   await soundRecordController.startRecorder(
  //     toFile: '${_dir!.path}/$_uid.aac',
  //     codec: Codec.aacADTS,
  //   );
  // }
  //
  // stopRecorder({required Function(MediaModel) onSuccess}) async {
  //   if (soundRecordController.isStopped) {
  //     return;
  //   }
  //   final path = await soundRecordController.stopRecorder();
  //   if (path != null) {
  //     await wavePlayerController.preparePlayer(
  //       path: path,
  //       shouldExtractWaveform: false,
  //     );
  //     final samples = await wavePlayerController.extractWaveformData(
  //       path: path,
  //       noOfSamples: const PlayerWaveStyle(spacing: 4, waveThickness: 3).getSamplesForWidth(250),
  //     );
  //     final media = MediaModel(
  //       id: _uid,
  //       path: path,
  //       type: MediaType.audio.name,
  //       duration: wavePlayerController.maxDuration,
  //       extraData: {
  //         'waveform': samples.toString(),
  //       },
  //     );
  //     onSuccess(media);
  //     _uid = null;
  //   }
  // }

  resetWaveRecorder() async {
    try {
      if (waveRecorderController.isRecording) {
        waveRecorderController.stop(false);
      }
      waveRecorderController.reset();
    } on Exception catch (e) {
      AppLog.d('DeviceAudioRecorderCubit', '$e');
    }
  }

  startWaveRecorder() async {
    final hasPermission = await waveRecorderController.checkPermission();
    if (!hasPermission || waveRecorderController.isRecording) {
      return;
    }

    ///
    _dir = await getTemporaryDirectory();
    _uid = 'audio_${DateTime.now().millisecondsSinceEpoch}';

    ///
    waveRecorderController.reset();
    await waveRecorderController.record(
      path: '${_dir!.path}/$_uid.aac',
      androidEncoder: AndroidEncoder.aac,
      androidOutputFormat: AndroidOutputFormat.mpeg4,
      iosEncoder: IosEncoder.kAudioFormatMPEG4AAC,
      sampleRate: 44100,
    );
  }

  stopWaveRecorder({required Function(MediaModel) onSuccess}) async {
    if (waveRecorderController.recorderState.isStopped) {
      return;
    }
    final path = await waveRecorderController.stop(false);
    if (path != null) {
      wavePlayerController.dispose();
      wavePlayerController = PlayerController();
      await wavePlayerController.preparePlayer(
        path: path,
        shouldExtractWaveform: false,
      );
      final samples = await wavePlayerController.extractWaveformData(
        path: path,
        noOfSamples: const PlayerWaveStyle(spacing: 2.1, waveThickness: 2).getSamplesForWidth(80),
      );
      final media = MediaModel(
        id: _uid,
        path: path,
        type: MediaType.audio.name,
        duration: wavePlayerController.maxDuration,
        extraData: {
          'waveform': samples.toString(),
        },
      );
      onSuccess(media);
      _uid = null;
    }
  }

  @override
  Future<void> close() async {
    // soundRecordController.closeRecorder();
    waveRecorderController.dispose();
    wavePlayerController.dispose();
    return super.close();
  }
}
