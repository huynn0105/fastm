import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter_module/app_data.dart';
import 'package:flutter_module/common/bloc_status.dart';
import 'package:flutter_module/common/enum/chat/quoted_message_type.dart';
import 'package:flutter_module/common/extension/iterable_extension.dart';
import 'package:flutter_module/common/extension/list_extension.dart';
import 'package:flutter_module/common/utils/text_util.dart';
import 'package:flutter_module/features/chat/repository/chat_repository.dart';
import 'package:flutter_module/models/base_model.dart';
import 'package:flutter_module/models/chat/message/message_model.dart';
import 'package:flutter_module/models/chat/message/user_on_message_model.dart';
import 'package:flutter_module/models/chat/thread/chat_thread_model.dart';
import 'package:flutter_module/services/api/chat/payload/thread_messages/add_message_to_thread_payload.dart';
import 'package:flutter_module/services/api/chat/payload/thread_messages/get_messages_in_thread_payload.dart';
import 'package:flutter_module/services/api/chat/payload/thread_messages/message_payload.dart';
import 'package:flutter_module/services/api/chat/payload/thread_messages/search_message_payload.dart';
import 'package:flutter_module/services/api/chat/payload/thread_messages/update_message_payload.dart';

part 'thread_messages_state.dart';

class ThreadMessagesCubit extends Cubit<ThreadMessagesState> {
  ThreadMessagesCubit({
    required this.threadID,
  }) : super(const ThreadMessagesState());

  final String? threadID;
  final ChatRepository _repository = ChatRepository();

  initData({ChatThreadModel? thread}) {
    final disabledThreadFields = {...state.disabledThreadFields};
    if (thread?.isDisabled() == true) {
      disabledThreadFields[DisabledThreadType.left.name] = 'Bạn đã rời khỏi nhóm';
    } else {
      disabledThreadFields.removeWhere((key, value) => key == DisabledThreadType.left.name);
    }
    emit(state.copyWith(
      thread: thread,
      disabledThreadFields: disabledThreadFields,
    ));
    checkDisabledThread();
  }

  updateBlockedThread(bool value) {
    if (!(state.thread?.isSingleThread() == true)) {
      return;
    }
    final disabledThreadFields = {...state.disabledThreadFields};
    final targetUser = state.thread?.getSingleThreadTargetUser()?.fullName ?? '';
    if (value) {
      disabledThreadFields[DisabledThreadType.blocked.name] = 'Bạn đã chặn <b>$targetUser</b>';
    } else {
      disabledThreadFields.removeWhere((key, value) => key == DisabledThreadType.blocked.name);
    }
    emit(state.copyWith(
      disabledThreadFields: disabledThreadFields,
    ));
    checkDisabledThread();
  }

  updateBeBlockedThread() async {
    if (!(state.thread?.isSingleThread() == true)) {
      return;
    }
    final result = await _repository.checkBeBlocked(
      threadID: threadID ?? '',
      userID: AppData.instance.userID,
    );
    final value = result.data == true;

    final disabledThreadFields = {...state.disabledThreadFields};
    final targetUser = state.thread?.getSingleThreadTargetUser()?.fullName ?? '';
    if (value) {
      disabledThreadFields[DisabledThreadType.beBlocked.name] = 'Bạn đã bị chặn bởi <b>$targetUser</b>';
    } else {
      disabledThreadFields.removeWhere((key, value) => key == DisabledThreadType.beBlocked.name);
    }

    emit(state.copyWith(
      disabledThreadFields: disabledThreadFields,
    ));

    checkDisabledThread();
  }

  checkDisabledThread() {
    emit(state.copyWith(
      isDisableThread: state.disabledThreadFields.isNotEmpty,
      disableThreadMessage: 'Bạn không thể gửi tin nhắn trong cuộc trò chuyện này',
    ));
  }

  getDisabledThreadMessage() {
    final leftGroupMessage = state.disabledThreadFields[DisabledThreadType.left.name];
    if (TextUtils.isNotEmpty(leftGroupMessage)) {
      return leftGroupMessage;
    }
    return state.disabledThreadFields.values.toList().getFirst();
  }

  fetchData({bool showLoading = true, bool loadMore = false}) async {
    if (showLoading) {
      emit(state.copyWith(
        status: BlocStatus.loading,
      ));
    }

    if (!loadMore) {
      final messagesInDb = _repository.getMessagesInDb(threadID ?? '');
      emit(state.copyWith(
        status: BlocStatus.success,
        data: messagesInDb,
      ));
    }
    updateBeBlockedThread();

    final result = await _repository.getMessagesInThread(
      payload: GetMessagesInThreadPayload(
        threadID: threadID,
        fromCreateTime: !state.isDataRemote ? null : state.data.getLast()?.createTime,
      ),
    );

    if (result.status) {
      List<MessageModel> data = result.data ?? [];
      data = data.where((x) => x.threadID != null).toList();
      if (loadMore) {
        data = [...state.data, ...data];
      }
      final messagesRemote = data.distinctByCondition((e) => e.uid ?? '').toList();
      messagesRemote.sort((a, b) => b.createTime!.compareTo(a.createTime!));

      emit(state.copyWith(
        status: BlocStatus.success,
        data: messagesRemote,
        isDataRemote: true,
      ));

      if (!loadMore) {
        await _repository.insertMessagesToDb(messagesRemote);
        await loadMoreData();
      }
    } else {
      emit(state.copyWith(
        status: BlocStatus.failure,
        enableLoadMore: false,
      ));
    }
  }

  Future<bool> loadMoreData() async {
    if (!state.enableLoadMore || !(state.loadMoreStatus.isInitial || state.loadMoreStatus.isSuccess)) {
      return false;
    }
    emit(state.copyWith(
      loadMoreStatus: BlocStatus.loading,
    ));
    final length = state.data.length;
    await fetchData(showLoading: false, loadMore: true);
    emit(state.copyWith(
      loadMoreStatus: BlocStatus.success,
      enableLoadMore: length != state.data.length,
    ));
    return length != state.data.length;
  }

  addMessageFromListener(
    MessageModel message, {
    Function()? onFromMeSent,
  }) {
    var index = state.data.indexWhere((e) => e.uid == message.uid);
    var data = <MessageModel>[];
    if (index >= 0) {
      updateMessageFromListener(message);
      return;
    } else {
      data = [message, ...state.data];
    }
    emit(state.copyWith(
      data: data,
    ));
    _repository.insertOrUpdateMessageToDb(message);
    if (message.isMe()) {
      Future.delayed(const Duration(milliseconds: 200), () => onFromMeSent?.call());
    }
  }

  updateMessageFromListener(
    MessageModel message, {
    Function()? onFromMeSent,
  }) {
    List<MessageModel> data = [...state.data];
    int index = data.indexWhere((e) => e.uid == message.uid);
    if (index >= 0) {
      if (message.isDeletedByMe() == true) {
        data.removeAt(index);
      } else {
        data[index] = message.copyWith();
      }
      _repository.insertOrUpdateMessageToDb(message);
      emit(state.copyWith(
        data: data,
      ));
    }
  }

  sendMessage(
    MessageModel message, {
    required Function(String messageID) onSuccess,
    required Function() onFailure,
  }) async {
    String? type;
    MessageModel? quotedMessage;

    if (state.quotedType?.isReply == true) {
      type = state.quotedType?.name;
      quotedMessage = state.quotedMessage?.copyWith(
        medias: state.quotedMessage?.medias?.take(1).toList(),
      );
    }

    removeQuotedMessage();

    final result = await _repository.addMessageToThread(
      payload: AddMessageToThreadPayload(
        threadID: threadID,
        message: message.copyWith(
          threadID: threadID,
          author: AppData.instance.author,
          quotedType: type,
          quotedMessage: quotedMessage,
        ),
      ),
    );
    if (result.status) {
      onSuccess(result.data ?? '');
    } else {
      onFailure();
    }
  }

  sendLocalMessage(MessageModel message) async {
    await _repository.addLocalMessageToThread(
      payload: AddMessageToThreadPayload(
        threadID: threadID,
        message: message,
      ),
    );
  }

  Future<MessageModel?> pushLocalMessage(MessageModel message) async {
    String? type;
    MessageModel? quotedMessage;

    if (state.quotedType?.isReply == true) {
      type = state.quotedType?.name;
      quotedMessage = state.quotedMessage?.copyWith(
        medias: state.quotedMessage?.medias?.take(1).toList(),
      );
    }

    removeQuotedMessage();

    final result = await _repository.pushLocalMessage(
      payload: AddMessageToThreadPayload(
        threadID: threadID,
        message: message.copyWith(
          threadID: threadID,
          author: AppData.instance.author,
          quotedType: type,
          quotedMessage: quotedMessage,
        ),
      ),
    );

    if (result.data != null) {
      addMessageFromListener(result.data!);
    }

    return result.data;
  }

  updateMediaForMessage({
    required String messageID,
    required String mediaID,
    required String mediaURL,
    String? mediaThumbnailURL,
  }) async {
    await _repository.updateMessage(
      payload: UpdateMediaMessagePayload(
        threadID: threadID,
        messageID: messageID,
        mediaID: mediaID,
        mediaURL: mediaURL,
        mediaThumbnailURL: mediaThumbnailURL,
      ),
    );
  }

  updateReactionForMessage({
    required String messageID,
    required String? reaction,
  }) async {
    await _repository.updateMessage(
      payload: UpdateReactionMessagePayload(
        threadID: threadID,
        messageID: messageID,
        reaction: reaction,
        authorID: AppData.instance.userID,
      ),
    );
  }

  updateRecalledForMessage({
    required String messageID,
  }) async {
    await _repository.updateMessage(
      payload: UpdateRecalledMessagePayload(
        threadID: threadID,
        messageID: messageID,
      ),
    );
  }

  updateEditedForMessage({
    required String messageID,
    required String text,
  }) async {
    removeQuotedMessage();

    await _repository.updateMessage(
      payload: UpdateEditMessagePayload(
        threadID: threadID,
        messageID: messageID,
        text: text,
      ),
    );
  }

  Future<BaseModel<bool>> updateDeletedForMessage({
    required String messageID,
  }) async {
    return await _repository.updateMessage(
      payload: UpdateDeletedMessagePayload(
        threadID: threadID,
        messageID: messageID,
        authorID: AppData.instance.userID,
      ),
    );
  }

  Future<int?> getIndexMessage(
    MessageModel message, {
    Function()? onFailure,
  }) async {
    emit(state.copyWith(
      scrollToQuoteStatus: BlocStatus.loading,
    ));
    final messageID = message.uid ?? '';
    if (!state.indexedMessages.containsKey(messageID)) {
      final existed = await _repository.getExistedMessageInThread(
        payload: MessagePayload(
          threadID: threadID,
          messageID: messageID,
        ),
      );
      if (existed.status) {
        await searchMessage(message);
        await Future.delayed(const Duration(milliseconds: 300));
      } else {
        emit(state.copyWith(
          scrollToQuoteStatus: BlocStatus.failure,
        ));
        onFailure?.call();
        return null;
      }
    }
    emit(state.copyWith(
      scrollToQuoteStatus: BlocStatus.success,
    ));
    return state.indexedMessages[messageID];
  }

  searchMessage(MessageModel message) async {
    final result = await _repository.searchMessage(
      payload: SearchMessagePayload(
        threadID: threadID,
        messageID: message.uid ?? '',
        toCreateTime: state.data.getLast()?.createTime,
      ),
    );

    if (result.status) {
      List<MessageModel> data = result.data?.where((e) => !e.isDeletedByMe()).toList() ?? [];
      data = [...state.data, ...data];
      emit(state.copyWith(
        status: BlocStatus.success,
        data: data.distinctByCondition((e) => e.uid ?? '').toList(),
      ));
    } else {
      emit(state.copyWith(
        status: BlocStatus.failure,
      ));
    }
  }

  updateQuotedMessage(MessageModel message, QuotedMessageType quotingType) {
    emit(state.copyWith(
      quotedMessage: message,
      quotedType: quotingType,
    ));
  }

  removeQuotedMessage() {
    emit(state.copyWith(
      removeQuoted: true,
    ));
  }

  updateIndexedMessages(Map<String, int> data) {
    emit(state.copyWith(
      indexedMessages: data,
    ));
  }

  updateHighlightMessage(String messageID) {
    emit(state.copyWith(
      highlightMessageID: messageID,
    ));
  }

  Future<UserOnMessageModel?> getUserChat(String userID) async {
    BaseModel<UserOnMessageModel> result = await _repository.getUserChat(userID: userID);
    return result.data;
  }
}
