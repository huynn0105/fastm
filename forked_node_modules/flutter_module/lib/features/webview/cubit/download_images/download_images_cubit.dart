import 'dart:io';

import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter_module/common/bloc_status.dart';
import 'package:flutter_module/common/global_function.dart';
import 'package:path_provider/path_provider.dart';

import 'package:http/http.dart' as http;

part 'download_images_state.dart';

class DownloadImagesCubit extends Cubit<DownloadImagesState> {
  DownloadImagesCubit() : super(const DownloadImagesState());

  download({
    bool showLoading = true,
    List<String> urls = const [],
    Function(List<String>)? onSuccess,
    Function()? onFailure,
    String? ext = 'png',
    String? fileName,
  }) async {
    if (urls.isEmpty) {
      return;
    }

    if (showLoading) {
      emit(state.copyWith(status: BlocStatus.loading));
    }

    final futures = List.generate(
      urls.length,
      (index) => _downloadAndSaveFile(
        urls[index],
        ext: ext,
        fileName: fileName,
      ),
    );

    final results = await Future.wait(futures);
    final paths = results.whereType<String>().toList();

    if (results.isNotEmpty) {
      onSuccess?.call(paths);
      emit(state.copyWith(
        status: BlocStatus.success,
        paths: paths,
      ));
    } else {
      emit(state.copyWith(
        status: BlocStatus.failure,
      ));
    }
  }

  share({
    bool showLoading = true,
    List<String> urls = const [],
    Function(List<String>)? onSuccess,
    Function()? onFailure,
    String? ext = 'png',
    String? fileName,
  }) async {
    if (urls.isEmpty) {
      return;
    }

    if (showLoading) {
      emit(state.copyWith(shareStatus: BlocStatus.loading));
    }

    final futures = List.generate(
      urls.length,
      (index) => _downloadAndSaveFile(
        urls[index],
        ext: ext,
        fileName: fileName,
      ),
    );

    final results = await Future.wait(futures);
    final paths = results.whereType<String>().toList();

    if (results.isNotEmpty) {
      GlobalFunction.shareFiles(paths: paths);
      onSuccess?.call(paths);
      emit(state.copyWith(
        shareStatus: BlocStatus.success,
      ));
    } else {
      emit(state.copyWith(
        shareStatus: BlocStatus.failure,
      ));
    }
  }

  Future<String?> _downloadAndSaveFile(
    String url, {
    String? fileName,
    String? ext = 'png',
  }) async {
    try {
      final String name = fileName ?? "img_${DateTime.now().microsecondsSinceEpoch}";
      final Directory directory = await getApplicationDocumentsDirectory();
      final String filePath = '${directory.path}/$name.$ext';
      final http.Response response = await http.get(Uri.parse(url));
      final File file = File(filePath);
      await file.writeAsBytes(response.bodyBytes);
      return filePath;
    } on Exception catch (_) {
      return null;
    }
  }
}
