import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';

import 'package:flutter_module/common/bloc_status.dart';
import 'package:flutter_module/common/utils/debounce_util.dart';
import 'package:flutter_module/models/statistic_working/statistic_checking_model.dart';
import 'package:flutter_module/services/api/statistic_working/payload/get_statistic_checking_by_filter_payload.dart';
import 'package:flutter_module/features/statistic_working/repository/statistic_working_repository.dart';

part 'statistic_asm_checking_state.dart';

class StatisticAsmTotalCheckingCubit extends Cubit<StatisticAsmCheckingState> with StatisticAsmCheckingCubit {
  StatisticAsmTotalCheckingCubit() : super(const StatisticAsmCheckingState());
}

class StatisticAsmNotCheckingCubit extends Cubit<StatisticAsmCheckingState> with StatisticAsmCheckingCubit {
  StatisticAsmNotCheckingCubit() : super(const StatisticAsmCheckingState());
}

mixin StatisticAsmCheckingCubit on Cubit<StatisticAsmCheckingState> {
  final StatisticWorkingRepository _repository = StatisticWorkingRepository();
  final DebounceUtil _debounce = DebounceUtil(milliseconds: 250);

  GetStatisticCheckingByFilterPayload _payload = GetStatisticCheckingByFilterPayload();

  fetchData({bool showLoading = true, bool loadMore = false}) async {
    if (showLoading) {
      emit(state.copyWith(
        status: BlocStatus.loading,
      ));
    }

    updatePayload(page: loadMore ? _payload.page! + 1 : 1);
    final result = await _repository.getStatisticCheckingByFilter(_payload);
    final data = loadMore ? [...state.data, ...?result.data] : result.data;

    emit(state.copyWith(
      status: BlocStatus.success,
      data: result.status ? data : [],
    ));
  }

  onDateChanged(String date) {
    _debounce.run(() {
      updatePayload(date: date);
      fetchData();
    });
  }

  onSearchChanged(String keyword) {
    _debounce.run(() {
      updatePayload(filterText: keyword);
      fetchData();
    });
  }

  Future refreshData() async {
    await fetchData(showLoading: false);
  }

  Future loadmoreData() async {
    final length = state.data.length;
    await fetchData(showLoading: false, loadMore: true);
    return length != state.data.length;
  }

  updatePayload({
    String? userID,
    String? filterText,
    String? type,
    String? level,
    String? date,
    int? page,
    String? agentSort,
  }) {
    _payload = _payload.copyWith(
      userID: userID,
      filterText: filterText,
      type: type,
      level: level,
      date: date,
      page: page,
      agentSort: agentSort,
    );
  }
}
