import 'package:bloc/bloc.dart';
import 'package:collection/collection.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_product_detail_payload.dart';
import '../../../../common/bloc_status.dart';
import '../../../../common/constants.dart';
import '../../../../common/enum/mtrade/payment_type.dart';
import '../../../../common/extension/list_extension.dart';
import '../../../../models/base_model.dart';
import '../../../../models/mtrade/cart/mtrade_cart_product_model.dart';
import '../../../../models/mtrade/check_project_code/check_project_code_model.dart';
import '../../../../models/mtrade/order/mtrade_order_price_model.dart';
import '../../../../models/mtrade/product_detail/mtrade_product_detail_model.dart';
import '../../../../models/mtrade/product_detail/mtrade_sku_detail_model.dart';
import '../../../../models/mtrade/product_detail/product_location_support_model.dart';
import '../../../../services/api/mtrade/payload/check_product_stock_payload.dart';
import '../../../../services/api/mtrade/payload/mtrade_order_price_by_sku_payload.dart';
import '../../../../services/api/mtrade/payload/mtrade_pre_screen_payload.dart';
import '../../../../app_data.dart';
import '../../../../models/mtrade/product_detail/attribute_model.dart';
import '../../../../services/api/mtrade/payload/mtrade_cart_payload.dart';
import '../../../../services/api/mtrade/payload/mtrade_check_product_support_location_payload.dart';
import '../../../../services/api/mtrade/payload/mtrade_sku_payload.dart';
import '../../repository/mtrade_product_repository.dart';

part 'mtrade_product_detail_state.dart';

class MTradeProductDetailCubit extends Cubit<MTradeProductDetailState> {
  MTradeProductDetailCubit({
    required this.productCode,
  }) : super(const MTradeProductDetailState());

  final String productCode;

  bool _closed = false;

  final MTradeProductRepository _repository = MTradeProductRepository();

  fetchData({bool showLoading = true, bool checkSupportLocation = false}) async {
    if (showLoading) {
      emit(state.copyWith(
        status: BlocStatus.loading,
        supportLocationStatus: BlocStatus.loading,
      ));
    }

    final result = await _repository.getProductDetail(
      payload: MTradeProductDetailPayload(
        productCode: productCode,
        provinceCode: AppData.instance.deliverySupportProvinceCode,
        districtCode: AppData.instance.deliverySupportDistrictCode,
        wardCode: AppData.instance.deliverySupportWardCode,
      ),
    );

    if (result.status) {
      _validateInitData(
        product: result.data,
        checkSupportLocation: checkSupportLocation,
      );
    } else {
      emit(state.copyWith(
        status: BlocStatus.failure,
        supportLocationStatus: BlocStatus.failure,
      ));
    }
  }

  fetchFromProductList(MTradeProductDetailModel? data) {
    emit(state.copyWith(
      product: data,
      skuDetail: data?.skuDetail,
      productImg: data?.productImages,
    ));
  }

  refreshData() async {
    await fetchData(showLoading: false, checkSupportLocation: true);
  }

  selectAttribute(String keyword, String value, {bool checkSku = false}) {
    Map<String, String> json = {...state.selectedAttributes}..putIfAbsent(keyword, () => "");

    if (json[keyword] == value) {
      return;
    }

    final entries = json.entries.toList();

    entries
      ..removeWhere((e) => e.key == keyword)
      ..insert(0, MapEntry(keyword, value));

    json = Map.fromEntries(entries);

    if (checkSku) {
      _checkSkuDetail(json);
    } else {
      emit(state.copyWith(
        selectedAttributes: json,
      ));
    }
  }

  _fillDefaultAttribute(MTradeProductDetailModel? product) {
    final attributes = product?.skuDetail?.options ?? [];
    for (var e in attributes) {
      selectAttribute(e.valueAt(0) ?? "", e.valueAt(1) ?? "");
    }
  }

  _checkSkuDetail(Map<String, String> json) async {
    bool isPreOrder = (state.supportLocation?.delivery?.isPreOrder() ?? false);

    final errorFields = {...state.errorFields};
    final option = json.entries.toList().valueAt(0);

    errorFields
      ..remove(AppConstants.productInvalidKey)
      ..removeWhere((key, value) => key.contains(AppConstants.prefixSkuOption));

    ///
    emit(state.copyWith(
      checkSkuStatus: BlocStatus.loading,
    ));

    final List<List<String>> options = json.entries.map((e) => [e.key, e.value.toString()]).toList();
    final result = await _repository.getSkuDetailByOption(
      payload: MTradeSkuPayload(
        productID: int.tryParse(state.product?.productID ?? ""),
        provinceCode: AppData.instance.deliverySupportProvinceCode,
        districtCode: AppData.instance.deliverySupportDistrictCode,
        wardCode: AppData.instance.deliverySupportWardCode,
        option: options,
      ),
    );
    if (result.status) {
      final images = result.data?.productImg ?? [];
      String message = "Rất tiếc, ${state.product?.getNameWithSku(options)}";
      String key = "${AppConstants.prefixSkuOption}/${option?.value ?? ""}";
      if (result.data?.productInvalid == true) {
        errorFields[key] = "";
        errorFields[AppConstants.productInvalidKey] = "$message đang tạm ngưng bán";
      } else if (result.data?.productOutOfStock == true && !isPreOrder) {
        errorFields[key] = "";
        errorFields[AppConstants.productInvalidKey] = "$message đang tạm hết hàng";
      }
      //
      emit(state.copyWith(
        checkSkuStatus: BlocStatus.success,
        selectedAttributes: json,
        skuDetail: result.data,
        productImg: images.isNotEmpty ? images : null,
        errorFields: errorFields,
      ));
    } else {
      options.sort((first, second) {
        int firstIndex = state.attributes.indexWhere((e) => e.value == first.valueAt(0));
        int secondIndex = state.attributes.indexWhere((e) => e.value == second.valueAt(0));
        return firstIndex.compareTo(secondIndex);
      });
      String message = "Rất tiếc, ${state.product?.getNameWithSku(options)}";
      String key = "${AppConstants.prefixSkuOption}/${option?.value ?? ""}";
      errorFields[key] = "";
      errorFields[AppConstants.productInvalidKey] = "$message đang tạm ngưng bán";
      //
      emit(state.copyWith(
        checkSkuStatus: BlocStatus.failure,
        errorMessage: result.errorMessage,
        selectedAttributes: json,
        errorFields: errorFields,
      ));
    }
    _validate();
  }

  addCart() async {
    if (!state.enabledPayment) {
      return;
    }
    if (!(await _checkProjectPayNow())) {
      return;
    }
    emit(state.copyWith(
      addCartStatus: BlocStatus.loading,
    ));
    final result = await _repository.createCartItem(
      payload: MTradeCartPayload(
        productID: int.tryParse(state.product?.productID ?? ""),
        sku: state.skuDetail?.sku,
        quantity: 1,
      ),
    );
    if (result.status) {
      emit(state.copyWith(
        addCartStatus: BlocStatus.success,
      ));
    } else {
      emit(state.copyWith(
        addCartStatus: BlocStatus.failure,
        errorTitle: result.errorTitle,
        errorMessage: result.errorMessage,
        errorCode: result.errorCode,
      ));
    }
  }

  Future<bool> _checkProjectPayNow() async {
    emit(state.copyWith(
      checkProjectPayNowStatus: BlocStatus.loading,
    ));

    final result = await _repository.checkProjectCode();

    final status = result.data?.checkPayNow() ?? false;
    if (result.status) {
      if (status) {
        emit(state.copyWith(
          checkProjectPayNowStatus: BlocStatus.success,
          projectCode: result.data?.payNow,
        ));
      } else {
        emit(state.copyWith(
          checkProjectPayNowStatus: BlocStatus.failure,
          projectCode: result.data?.payNow,
        ));
      }
      return status;
    } else {
      emit(state.copyWith(
        checkProjectPayNowStatus: BlocStatus.failure,
        projectCode: result.data?.payNow,
      ));
    }
    return result.status;
  }

  Future<bool> _checkProjectPayLater() async {
    emit(state.copyWith(
      checkProjectPayLaterStatus: BlocStatus.loading,
    ));

    final result = await _repository.checkProjectCode();

    final status = result.data?.checkPayLater() ?? false;
    if (result.status) {
      if (status) {
        emit(state.copyWith(
          checkProjectPayLaterStatus: BlocStatus.success,
          projectCode: result.data?.payLater,
        ));
      } else {
        emit(state.copyWith(
          checkProjectPayLaterStatus: BlocStatus.failure,
          projectCode: result.data?.payLater,
        ));
      }
      return status;
    } else {
      emit(state.copyWith(
        checkProjectPayLaterStatus: BlocStatus.failure,
        projectCode: result.data?.payLater,
      ));
    }
    return result.status;
  }

  Future<bool> _checkProductSchemePayLater() async {
    emit(state.copyWith(
      checkProductSchemePayLater: BlocStatus.loading,
    ));

    double total = await _getTotalWithPriceOrder(products: [convertCartProduct()]);

    final result = await _repository.getPreScreenData(
      payload: MTradePreScreenDataPayload(
        orders: [
          MTradeCartPayload.fromJson(convertCartProduct().toJsonPreScreenPayload()),
        ],
        provinceCode: AppData.instance.deliverySupportProvinceCode,
        districtCode: AppData.instance.deliverySupportDistrictCode,
        wardCode: AppData.instance.deliverySupportWardCode,
        newPrice: total,
      ),
    );

    if (result.status) {
      AppData.instance.preScreenData = result.data;
      emit(state.copyWith(
        checkProductSchemePayLater: BlocStatus.success,
      ));
    } else {
      emit(state.copyWith(
        checkProductSchemePayLater: BlocStatus.failure,
        errorMessage: result.errorMessage,
      ));
    }
    return result.status;
  }

  Future<bool> _checkProductStock() async {
    emit(state.copyWith(
      checkProductStockStatus: BlocStatus.loading,
    ));

    final products = convertCartProduct();
    final result = await _repository.checkProductStock(
      payload: CheckProductStockPayload(
        listSku: [products.sku ?? ""],
        provinceCode: AppData.instance.deliverySupportProvinceCode,
        districtCode: AppData.instance.deliverySupportDistrictCode,
        wardCode: AppData.instance.deliverySupportWardCode,
      ),
    );

    if (result.status) {
      emit(state.copyWith(
        checkProductStockStatus: BlocStatus.success,
      ));
    } else {
      emit(state.copyWith(
        checkProductStockStatus: BlocStatus.failure,
        errorMessage: result.errorMessage,
      ));
    }
    return result.status;
  }

  Future<double> _getTotalWithPriceOrder({required List<MTradeCartProductModel> products}) async {
    if (products.where((element) => element.sku != null).isEmpty) return 0;
    BaseModel<MTradeOrderPriceModel> result = await _repository.getOrderPriceBySKU(
        payload: MTradeOrderPriceBySkuPayload(
          order: products.map((e) {
            return Order(sku: e.sku, quantity: e.quantity);
          }).toList(),
          channel: 'AGENT_APP',
          paymentMethod: MTradePaymentType.later.code,
          provinceCode: AppData.instance.deliverySupportProvinceCode,
          districtCode: AppData.instance.deliverySupportDistrictCode,
          wardCode: AppData.instance.deliverySupportWardCode,
        ));
    return _updateTotalPriceAfterPromotions(products: products, orderPrices: result.data?.listPrice ?? []);
  }

  double _updateTotalPriceAfterPromotions({
    required List<MTradeCartProductModel> products,
    required List<OrderPrice> orderPrices,
  }) {
    double totalPrice = products.map((e) => (e.price ?? 0) * (e.quantity ?? 0)).fold(0, (pre, cur) => pre + cur);
    bool existWholesalePrice = orderPrices.any((element) => element.existWholesalePrice());
    if (existWholesalePrice) {
      totalPrice = products
          .map((e) {
        OrderPrice? orderPrice = orderPrices.firstWhereOrNull((element) => element.sku == e.sku);
        if (orderPrice?.existWholesalePrice() == true) {
          return (orderPrice?.newPrice ?? 0) * (e.quantity ?? 1);
        }
        return (e.price ?? 0) * (e.quantity ?? 1);
      })
          .toList()
          .fold(0.0, (pre, cur) => pre + cur);
    }
    return totalPrice;
  }

  payNow({
    required Function(List<MTradeCartProductModel> data) onSuccess,
  }) async {
    if (!state.enabledPayment) {
      return;
    }
    if (!(await _checkProjectPayNow())) {
      return;
    }
    if (!(await _checkProductStock())) {
      return;
    }
    final products = [convertCartProduct()];
    onSuccess(products);
  }

  payLater({
    required Function(List<MTradeCartProductModel> data) onSuccess,
  }) async {
    if (!state.enabledPayment) {
      return;
    }
    if (!kIsWeb) {
      if (!(await _checkProjectPayLater())) {
        return;
      }
    }
    if (!(await _checkProductStock())) {
      return;
    }
    if (!(await _checkProductSchemePayLater())) {
      return;
    }
    final products = [convertCartProduct()];
    onSuccess(products);
  }

  MTradeCartProductModel convertCartProduct() {
    return MTradeCartProductModel.fromProductDetail(
      state.product,
      state.skuDetail,
    );
  }

  _validateInitData({
    MTradeProductDetailModel? product,
    bool checkSupportLocation = false,
  }) async {
    emit(state.copyWith(
      status: BlocStatus.success,
      product: product,
      skuDetail: product?.skuDetail,
      productImg: product?.skuDetail?.productImg ?? product?.productImages,
      attributes: product?.attributes,
    ));

    _fillDefaultAttribute(product);

    Map<String, String> errorFields = <String, String>{};
    ProductLocationSupportModel? supportLocation;

    /// check Support Location
    if (checkSupportLocation && product?.productInvalid == false) {
      final result = await _repository.checkProductLocationSupport(
        payload: MtradeCheckProductSupportLocationPayload(
          sku: product?.skuDetail?.sku,
          provinceCode: AppData.instance.deliverySupportProvinceCode,
          districtCode: AppData.instance.deliverySupportDistrictCode,
          wardCode: AppData.instance.deliverySupportWardCode,
        ),
      );
      supportLocation = result.data;
      if (result.status && result.data?.isSupport == true) {
        errorFields.remove(AppConstants.productLocationSupportKey);
      } else {
        errorFields[AppConstants.productLocationSupportKey] = result.errorMessage ?? "";
      }

      final List<List<String>> options = state.selectedAttributes.entries.map((e) => [e.key, e.value.toString()]).toList();
      final option = state.selectedAttributes.entries.toList().valueAt(0);

      String message = "Rất tiếc, ${state.product?.getNameWithSku(options)}";
      String key = "${AppConstants.prefixSkuOption}/${option?.value ?? ""}";
      if (result.data?.productPaymentMethod?.productInvalid == true) {
        errorFields[key] = "";
        errorFields[AppConstants.productInvalidKey] = "$message đang tạm ngưng bán";
      }
    }

    ///
    emit(state.copyWith(
      supportLocationStatus: BlocStatus.success,
      checkSupportLocationStatus: (supportLocation?.isSupport == true) ? null : BlocStatus.failure,
      supportLocation: supportLocation,
      errorFields: errorFields,
    ));

    ///
    _validate();
  }

  onLocationChange() async {
    emit(state.copyWith(
      checkMethodStatus: BlocStatus.loading,
    ));
    await Future.wait([
      _checkSkuByLocation(),
      _checkSupportLocation(),
    ]);
    emit(state.copyWith(
      checkMethodStatus: BlocStatus.success,
    ));
  }

  Future _checkSkuByLocation() async {
    Map<String, String> json = {...state.selectedAttributes};
    await _checkSkuDetail(json);
  }

  Future _checkSupportLocation() async {
    emit(state.copyWith(
      checkSupportLocationStatus: BlocStatus.loading,
    ));

    final result = await _repository.checkProductLocationSupport(
      payload: MtradeCheckProductSupportLocationPayload(
        sku: state.skuDetail?.sku,
        provinceCode: AppData.instance.deliverySupportProvinceCode,
        districtCode: AppData.instance.deliverySupportDistrictCode,
        wardCode: AppData.instance.deliverySupportWardCode,
      ),
    );

    bool isPreOrder = (result.data?.delivery?.isPreOrder() ?? false);

    if (result.status && result.data?.isSupport == true) {
      final errorFields = {...state.errorFields};
      errorFields.remove(AppConstants.productLocationSupportKey);
      if (isPreOrder) {
        errorFields.removeWhere((key, value) => key.contains(AppConstants.prefixSkuOption));
      }
      emit(state.copyWith(
        checkSupportLocationStatus: BlocStatus.success,
        supportLocation: result.data,
        errorFields: errorFields,
      ));
      _validate();
      return;
    }

    final errorFields = {...state.errorFields};
    errorFields[AppConstants.productLocationSupportKey] = result.errorMessage ?? "";
    if (isPreOrder) {
      errorFields.removeWhere((key, value) => key.startsWith(AppConstants.prefixSkuOption));
    }

    final List<List<String>> options = state.selectedAttributes.entries.map((e) => [e.key, e.value.toString()]).toList();
    final option = state.selectedAttributes.entries.toList().valueAt(0);

    String message = "Rất tiếc, ${state.product?.getNameWithSku(options)}";
    String key = "${AppConstants.prefixSkuOption}/${option?.value ?? ""}";
    if (result.data?.productPaymentMethod?.productInvalid == true) {
      errorFields[key] = "";
      errorFields[AppConstants.productInvalidKey] = "$message đang tạm ngưng bán";
    }
    emit(state.copyWith(
      checkSupportLocationStatus: BlocStatus.failure,
      errorFields: errorFields,
    ));
    _validate();
  }

  _validate() {
    emit(state.copyWith(
      errorFields: state.errorFields,
      enabledPayment: state.errorFields.isEmpty,
    ));
  }

  @override
  void emit(MTradeProductDetailState state) {
    if (!_closed) {
      super.emit(state);
    }
  }

  @override
  Future<void> close() {
    _closed = true;
    return super.close();
  }
}
