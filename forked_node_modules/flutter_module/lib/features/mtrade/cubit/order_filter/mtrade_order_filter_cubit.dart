import 'package:bloc/bloc.dart';
import 'package:collection/collection.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter_module/common/bloc_status.dart';
import 'package:flutter_module/features/mtrade/repository/mtrade_product_repository.dart';
import 'package:flutter_module/models/mtrade/filter/mtrade_filter_group_model.dart';
import 'package:flutter_module/models/mtrade/filter/mtrade_filter_model.dart';
import 'package:flutter_module/models/mtrade/filter/selected_filter_model.dart';

part 'mtrade_order_filter_state.dart';

class MTradeOrderFilterCubit extends Cubit<MTradeOrderFilterState> {
  MTradeOrderFilterCubit() : super(const MTradeOrderFilterState());

  final MTradeProductRepository _repository = MTradeProductRepository();

  String timeKeyword = 'time';

  fetchData({bool showLoading = true}) async {
    if (showLoading) {
      emit(state.copyWith(
        status: BlocStatus.loading,
      ));
    }

    final result = await _repository.getOrderFilters();

    if (result.status) {
      emit(state.copyWith(
        status: BlocStatus.success,
        filters: result.data,
      ));
      _selectedDefaultTime();
    } else {
      emit(state.copyWith(
        status: BlocStatus.failure,
      ));
    }
  }

  _select({
    bool isSelecting = false,
    required SelectedFilterModel item,
    required MTradeFilterGroupModel group,
    Function()? onAdded,
    Function()? onDeleted,
  }) {
    var isTimeFilter = item.keyword == timeKeyword;
    var filters = isTimeFilter
        ? state.selectedTimeFilters
        : isSelecting
            ? state.selectingFilters
            : state.selectedFilters;

    var json = {...filters}..putIfAbsent(item.keyword ?? '', () => []);
    var data = [...?json[item.keyword ?? '']];

    if (data.map((e) => e.code).toList().contains(item.code ?? '')) {
      data.removeWhere((e) => e.code == item.code);
      onDeleted?.call();
    } else {
      data = (group.multiSelect == true) ? [...data, item] : [item];
      onAdded?.call();
    }

    json[item.keyword ?? ''] = [...data];

    final selectedTimeFilters = isTimeFilter ? json : null;
    final selectingFilters = isTimeFilter
        ? null
        : isSelecting
            ? json
            : null;

    final selectedFilters = isTimeFilter
        ? null
        : !isSelecting
            ? json
            : null;

    emit(state.copyWith(
      selectedTimeFilters: selectedTimeFilters,
      selectingFilters: selectingFilters,
      selectedFilters: selectedFilters,
    ));

    if (!isSelecting) {
      getFilterPath();
    }
  }

  _selectedDefaultTime() {
    final group = state.filters.firstWhereOrNull((e) => e.keyword == timeKeyword);
    final data = state.filters.firstWhereOrNull((e) => e.keyword == timeKeyword)?.list ?? [];
    if (data.isEmpty) {
      return;
    }
    final index = data.indexWhere((e) => e.code == group?.defaultValue);
    if (index >= 0) {
      selectFilter(
        keyword: timeKeyword,
        filterIndex: index,
        filterItem: data[index],
      );
    }
  }

  selectFilter({
    bool isSelecting = false,
    required String keyword,
    required int filterIndex,
    required MTradeFilterModel filterItem,
    String? parentKeyword,
    Function()? onAdded,
    Function()? onDeleted,
  }) async {
    final group = state.filters.firstWhereOrNull((e) => e.keyword == keyword);
    if (group == null) {
      return;
    }
    final item = SelectedFilterModel(
      index: filterIndex,
      code: filterItem.code,
      name: filterItem.name,
      keyword: keyword,
      parentKeyword: parentKeyword,
    );
    _select(
      isSelecting: isSelecting,
      item: item,
      group: group,
      onAdded: onAdded,
      onDeleted: onDeleted,
    );
  }

  selectingFilter({
    required String keyword,
    required int filterIndex,
    required MTradeFilterModel filterItem,
    String? parentKeyword,
    Function()? onAdded,
    Function()? onDeleted,
  }) {
    selectFilter(
      isSelecting: true,
      keyword: keyword,
      filterIndex: filterIndex,
      filterItem: filterItem,
    );
  }

  getFilterPath() {
    final keywords = state.filters.map((e) => e.keyword ?? '').toList();
    final filters = {...state.selectedFilters};

    final sortedGroups = filters.entries.map(
      (e) {
        return MapEntry(
          e.key,
          e.value.map((e) => e).sorted(
            (a, b) {
              // sorted item in list by keyword
              final aIndex = a.index ?? -1;
              final bIndex = b.index ?? -1;
              return aIndex.compareTo(bIndex);
            },
          ),
        );
      },
    ).sorted(
      (a, b) {
        // sorted keyword
        final aIndex = keywords.indexOf(a.key);
        final bIndex = keywords.indexOf(b.key);
        return aIndex.compareTo(bIndex);
      },
    );

    final paths = sortedGroups
        .map((e) {
          final ePath = e.value.map((e) => e.name ?? '').where((e) => e.isNotEmpty).join(', ');
          return ePath;
        })
        .where((e) => e.isNotEmpty)
        .join(' - ');

    emit(state.copyWith(
      filterPath: paths,
    ));
  }

  Map<String, dynamic> getFilterData() {
    final converter = MTradeOrderFilterConverter(filter: {...state.selectedTimeFilters, ...state.selectedFilters});
    return converter.getData();
  }

  Map<String, dynamic> getFilterDataByKeyword(String keyword) {
    final converter = MTradeOrderFilterConverter(filter: {...state.selectedTimeFilters, ...state.selectedFilters});
    return converter.getDataByKeyword(keyword);
  }

  Map<String, dynamic> getTimeFilterData() {
    return getFilterDataByKeyword(timeKeyword);
  }

  initSelecting() {
    emit(state.copyWith(
      selectingFilters: state.selectedFilters,
    ));
  }

  clearSelecting() {
    emit(state.copyWith(
      selectingFilters: {},
    ));
  }

  clearSelected() {
    emit(state.copyWith(
      selectedFilters: {},
    ));
  }

  applySelecting() {
    clearSelected();
    emit(state.copyWith(
      selectedFilters: state.selectingFilters,
    ));
    getFilterPath();
  }

  clearSelection() {
    emit(state.copyWith(
      selectingFilters: {},
      selectedFilters: {},
      filterPath: '',
    ));
  }

  clearData() {
    emit(const MTradeOrderFilterState());
  }
}
