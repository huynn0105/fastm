import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';

import '../../../../common/bloc_status.dart';
import '../../../../common/widgets/nested_scrollview.dart';
import '../../../../models/mtrade/product/mtrade_product_model.dart';
import '../../../../services/api/mtrade/payload/mtrade_product_payload.dart';
import '../../repository/mtrade_product_repository.dart';

part 'mtrade_searched_product_state.dart';

class MTradeSearchedProductCubit extends Cubit<MTradeSearchedProductState> {
  MTradeSearchedProductCubit() : super(const MTradeSearchedProductState());
  late final LoadMoreListSource<MTradeProductModel> productsSource = LoadMoreListSource<MTradeProductModel>(
    onLoadMore: loadmoreData,
  );

  final MTradeProductRepository _repository = MTradeProductRepository();

  MTradeProductPayload _payload = MTradeProductPayload();
  bool _loadMoreProcess = false;

  fetchData({bool showLoading = true, bool loadmore = false}) async {
    if (showLoading) {
      emit(state.copyWith(
        status: BlocStatus.loading,
      ));
    }

    updatePayload(page: loadmore ? (_payload.page ?? 1) + 1 : 1);

    final result = await _repository.getFilterProducts(
      payload: _payload,
    );

    if (result.status) {
      var data = result.data ?? [];
      if (loadmore) {
        data = [...state.products, ...data];
      } else {
        productsSource.reset();
      }
      productsSource.clear();
      productsSource.addAll(data);
      emit(state.copyWith(
        status: BlocStatus.success,
        products: data,
        hasMore: (result.data?.length ?? 0) > 0,
      ));
    } else {
      emit(state.copyWith(
        status: BlocStatus.failure,
      ));
    }
  }

  updatePayload({
    String? group,
    List<String>? productGroup,
    List<String>? productCategory,
    List<String>? brand,
    List<String>? price,
    List<String>? paymentMethod,
    String? productName,
    String? provinceCode,
    String? districtCode,
    String? wardCode,
    int? page,
    Map<String, dynamic>? jsonFilters,
  }) {
    _payload = _payload.copyWith(
      group: group,
      productGroup: productGroup,
      productCategory: productCategory,
      brand: brand,
      price: price,
      paymentMethod: paymentMethod,
      productName: productName,
      provinceCode: provinceCode,
      districtCode: districtCode,
      wardCode: wardCode,
      page: page,
      jsonFilters: jsonFilters,
    );
  }

  updatePayloadFromFilter(Map<String, dynamic> filter) {
    updatePayload(
      jsonFilters: filter,
    );
  }

  Future refreshData() async {
    await fetchData(showLoading: false);
  }

  Future<bool> loadmoreData() async {
    if (_loadMoreProcess) return true;
    _loadMoreProcess = true;
    final length = state.products.length;
    await fetchData(showLoading: false, loadmore: true);
    _loadMoreProcess = false;
    return length != state.products.length;
  }

  @override
  Future<void> close() {
    productsSource.dispose();
    return super.close();
  }
}
