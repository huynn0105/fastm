import 'dart:async';

import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter/material.dart';
import 'package:flutter_module/app_data.dart';
import 'package:flutter_module/common/enum/otp_action.dart';
import 'package:flutter_module/common/enum/otp_type.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_request_paylater_otp_payload.dart';

import '../../../../common/bloc_status.dart';
import '../../../../common/constants.dart';
import '../../../../models/base_model.dart';
import '../../../../services/api/mtrade/payload/mtrade_request_paylater_confirm_payload.dart';
import '../../repository/mtrade_product_repository.dart';

part 'buyer_request_state.dart';

class BuyerRequestCubit extends Cubit<BuyerRequestState> {
  BuyerRequestCubit() : super(BuyerRequestState());

  final repository = MTradeProductRepository();
  final otpController = TextEditingController();
  Timer? _timer;

  init({required String phoneNumber}) {
    _startTimer();
    requestOtp(phoneNumber: phoneNumber);
    emit(state.copyWith(status: BlocStatus.success));
  }

  requestOtp({required String phoneNumber, bool retry = false, String? channel}) async {
    otpController.clear();
    state.errorFields.removeWhere((key, value) => key == AppConstants.otpKey);
    validateData();

    AppData.instance.lastOTPType = channel ?? OTPType.voice.name;

    emit(state.copyWith(
      otpStatus: BlocStatus.loading,
      countDown: AppConstants.otpCountdown,
    ));

    final result = await repository.requestPayLaterOtp(
      payload: MTradeRequestPayLaterOtpPayload(
        mobilePhone: phoneNumber,
        isRetry: retry ? 1 : 0,
        channel: channel,
      ),
    );

    _startTimer();

    if (!result.status) {
      emit(state.copyWith(
        otpStatus: BlocStatus.failure,
        errMsg: result.errorMessage,
      ));
    } else {
      emit(state.copyWith(
        otpStatus: BlocStatus.success,
        logOtpID: result.data?.logOtpID,
      ));
    }
  }

  _startTimer() {
    if (_timer != null) {
      return;
    }
    _timer = Timer.periodic(const Duration(seconds: 1), (Timer t) {
      if (state.countDown == 1) {
        t.cancel();
        _timer?.cancel();
        _timer = null;
        return;
      }
      emit(state.copyWith(countDown: state.countDown - 1));
    });
  }

  validateData() {
    emit(state.copyWith(completeStepStatus: BlocStatus.initial));
  }

  otpChange(String text) {
    state.errorFields.removeWhere((key, value) => key == AppConstants.otpKey);
    validateData();
  }

  _checkFields() {
    if (otpController.text.isEmpty) {
      state.errorFields[AppConstants.otpKey] = 'Thông tin này là bắt buộc';
    }
  }

  verifyOtp({
    required String phoneNumber,
    required String? sku,
    required String? productName,
    required String fullName,
    required String phone,
    required int? productPrice,
    required String? provinceID,
    required String? districtID,
    required int? schemeID,
    required double? prepayPercent,
    required int? loanTerms,
    required int? insurance,
    required String? idNumber,
    required double? loanTermsConversionFee,
    required String? loanPurpose,
    required double? interestRate,
    required int? requireInsurance,
    required String? schemeName,
  }) async {
    _checkFields();
    if (state.errorFields.isNotEmpty) {
      validateData();
      return;
    }

    emit(state.copyWith(completeStepStatus: BlocStatus.loading));

    BaseModel<String> result = await repository.requestPayLaterConfirm(
      payload: MTradeRequestPayLaterConfirmPayload(
        mobilePhone: phoneNumber,
        otpCode: otpController.text,
        action: OtpAction.create_mpl_mtrade.value,
        sku: sku,
        productName: productName,
        productPrice: productPrice,
        fullName: fullName.toUpperCase(),
        phone: phone,
        provinceID: provinceID,
        districtID: districtID,
        schemeID: schemeID,
        prepayPercent: prepayPercent,
        loanTerms: loanTerms,
        insurance: insurance,
        idNumber: idNumber,
        loanTermsConversionFee: loanTermsConversionFee,
        loanPurpose: loanPurpose,
        interestRate: interestRate,
        requireInsurance: requireInsurance,
        schemeName: schemeName,
      ),
    );

    if (result.status) {
      emit(state.copyWith(
        completeStepStatus: BlocStatus.success,
        redirectLink: result.data,
      ));
    } else {
      state.errorFields[AppConstants.otpKey] = result.errorMessage ?? '';
      validateData();
    }
  }

  Future requestPayLaterDAAMTrade({
    required String phoneNumber,
    required String? sku,
    required String? productName,
    required String fullName,
    required String phone,
    required int? productPrice,
    required String? provinceID,
    required String? districtID,
    required int? schemeID,
    required double? prepayPercent,
    required int? loanTerms,
    required int? insurance,
    required String? idNumber,
    required double? loanTermsConversionFee,
    required String? loanPurpose,
    required double? interestRate,
    required int? requireInsurance,
    required String? schemeName,
  }) async {
    if (state.errorFields.isNotEmpty) {
      validateData();
      return;
    }

    emit(state.copyWith(completeStepStatus: BlocStatus.loading));

    BaseModel<String> result = await repository.requestPayLaterDAAMTrade(
      payload: MTradeRequestPayLaterConfirmPayload(
        mobilePhone: phoneNumber,
        action: OtpAction.create_mpl_mtrade.value,
        sku: sku,
        productName: productName,
        productPrice: productPrice,
        fullName: fullName.toUpperCase(),
        phone: phone,
        provinceID: provinceID,
        districtID: districtID,
        schemeID: schemeID,
        prepayPercent: prepayPercent,
        loanTerms: loanTerms,
        insurance: insurance,
        idNumber: idNumber,
        loanTermsConversionFee: loanTermsConversionFee,
        loanPurpose: loanPurpose,
        interestRate: interestRate,
        requireInsurance: requireInsurance,
        schemeName: schemeName,
      ),
    );

    if (result.status) {
      emit(state.copyWith(
        completeStepStatus: BlocStatus.success,
        redirectLink: result.data,
      ));
    } else {
      emit(state.copyWith(
        completeStepStatus: BlocStatus.failure,
        errMsg: result.errorMessage,
      ));
    }
  }

  @override
  void emit(BuyerRequestState state) {
    if (!isClosed) {
      super.emit(state);
    }
  }

  @override
  Future<void> close() {
    otpController.dispose(); //pin code widget disposed
    _timer?.cancel();
    _timer = null;
    return super.close();
  }
}
