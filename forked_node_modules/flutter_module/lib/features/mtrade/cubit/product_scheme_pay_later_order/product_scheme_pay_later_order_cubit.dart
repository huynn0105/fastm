import 'dart:io';

import 'package:bloc/bloc.dart';
import 'package:collection/collection.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter/material.dart';
import 'package:flutter_module/app_data.dart';
import 'package:flutter_module/common/constants.dart';
import 'package:flutter_module/common/enum/mtrade/join_insurance_type.dart';
import 'package:flutter_module/common/extension/int_extension.dart';
import 'package:flutter_module/common/utils/calculate_util.dart';
import 'package:flutter_module/common/utils/text_util.dart';
import 'package:flutter_module/models/mtrade/pay_later/down_payment_model.dart';
import 'package:flutter_module/models/mtrade/pay_later/tenor_conversion_fee_model.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_gen_product_token_payload.dart';

import '../../../../common/bloc_status.dart';
import '../../../../common/enum/mtrade/pay_later_type.dart';
import '../../../../common/enum/mtrade/payment_type.dart';
import '../../../../common/enum/mtrade/vehicle_type.dart';
import '../../../../common/extension/list_extension.dart';
import '../../../../models/base_model.dart';
import '../../../../models/general_object.dart';
import '../../../../models/mtrade/cart/mtrade_cart_product_model.dart';
import '../../../../models/mtrade/order/mtrade_order_price_model.dart';
import '../../../../models/mtrade/pay_later/mtrade_pre_screen_data.dart';
import '../../../../models/mtrade/pay_later/mtrade_product_scheme_model.dart';
import '../../../../models/mtrade/promotion/data_product_variations_model.dart';
import '../../../../models/mtrade/promotion/mtrade_promotion_data_model.dart';
import '../../../../services/api/mtrade/payload/mtrade_cart_payload.dart';
import '../../../../services/api/mtrade/payload/mtrade_order_price_by_sku_payload.dart';
import '../../../../services/api/mtrade/payload/mtrade_pre_screen_payload.dart';
import '../../repository/mtrade_product_repository.dart';

part 'product_scheme_pay_later_order_state.dart';

class ProductSchemePayLaterOrderCubit extends Cubit<ProductSchemePayLaterOrderState> {
  ProductSchemePayLaterOrderCubit() : super(const ProductSchemePayLaterOrderState());

  final MTradeProductRepository _repository = MTradeProductRepository();

  final TextEditingController loanSchemeController = TextEditingController();
  final TextEditingController downPaymentAmountController = TextEditingController();
  final TextEditingController loanTenorController = TextEditingController();

  MTradePreScreenDataPayload _payload = MTradePreScreenDataPayload();

  fetchData({
    bool showLoading = true,
    String? selectedLoanSchemeID,
    String? selectedDownPaymentPercent,
    String? selectedLoanTenor,
    String? selectedJoinInsurance,
  }) async {
    if (showLoading) {
      emit(state.copyWith(
        status: BlocStatus.loading,
      ));
    }

    final result = await _repository.getPreScreenData(
      payload: _payload,
    );

    if (result.status) {
      _mapDataToState(
        value: result.data,
        selectedLoanSchemeID: selectedLoanSchemeID,
        selectedDownPaymentPercent: selectedDownPaymentPercent,
        selectedLoanTenor: selectedLoanTenor,
        selectedJoinInsurance: selectedJoinInsurance,
      );
    } else {
      emit(state.copyWith(
        status: BlocStatus.failure,
        errorMessage: result.errorMessage,
      ));
    }
  }

  initData() {
    _mapDataToState(value: AppData.instance.preScreenData);
  }

  _mapDataToState({
    MTradePreScreenDataModel? value,
    String? selectedLoanSchemeID,
    String? selectedDownPaymentPercent,
    String? selectedLoanTenor,
    String? selectedJoinInsurance,
  }) async {
    final data = value ?? AppData.instance.preScreenData;
    final listLoanScheme = data?.schemes?.map((e) => GeneralObject(id: e.schemeID, name: e.schemeName)).toList();
    // final totalPrice = data?.orders?.map((e) => (e.price ?? 0) * (e.quantity ?? 0)).fold(0, (pre, cur) => pre + cur);
    final orderPrices = await fetchPriceOrder(products: data?.orders ?? []);
    emit(state.copyWith(
      status: BlocStatus.success,
      data: data,
      products: data?.orders,
      enabledLoanScheme: data?.schemes?.isNotEmpty == true,
      listLoanScheme: listLoanScheme,
      // totalPrice: totalPrice?.toDouble(),
      selectedJoinInsurance: selectedJoinInsurance != null ? selectedJoinInsurance == 'true' : null,
      orderPrices: orderPrices,
    ));

    _updateTotalPriceAfterPromotions();

    if (selectedLoanSchemeID != null) {
      selectLoanScheme(int.tryParse(selectedLoanSchemeID));
      if (selectedLoanTenor != null) {
        selectLoanTenor(int.tryParse(selectedLoanTenor));
      }
      if (selectedDownPaymentPercent != null) {
        selectDownPaymentPercent(double.tryParse(selectedDownPaymentPercent));
      }
    }

    _calculate();
  }

  Future<List<OrderPrice>?> fetchPriceOrder({required List<MTradeCartProductModel> products}) async {
    if (products.where((element) => element.sku != null).isEmpty) return null;
    emit(state.copyWith(wholePriceStatus: BlocStatus.loading));
    BaseModel<MTradeOrderPriceModel> result = await _repository.getOrderPriceBySKU(
        payload: MTradeOrderPriceBySkuPayload(
          order: products.map((e) {
            return Order(sku: e.sku, quantity: e.quantity);
          }).toList(),
          channel: 'AGENT_APP',
          paymentMethod: MTradePaymentType.later.code,
          provinceCode: _payload.provinceCode,
          districtCode: _payload.districtCode,
          wardCode: _payload.wardCode,
        ));
    emit(state.copyWith(wholePriceStatus: BlocStatus.success));
    return result.data?.listPrice;
  }

  validateScheme() async {
    emit(state.copyWith(
      status: BlocStatus.loading,
    ));

    final double totalPrice = state.totalPrice ?? 0;
    final double totalPromotionPrice = state.totalPromotionPrice;
    final result = await _repository.getPreScreenData(
      payload: _payload.copyWith(newPrice: totalPrice - totalPromotionPrice),
    );

    final listLoanScheme = result.data?.schemes?.map((e) => GeneralObject(id: e.schemeID, name: e.schemeName)).toList();
    if (result.status) {
      loanSchemeController.clear();
      downPaymentAmountController.clear();
      loanTenorController.clear();
      emit(state.copyWith(
        status: BlocStatus.success,
        data: result.data,
        products: result.data?.orders,
        enabledLoanScheme: result.data?.schemes?.isNotEmpty == true,
        listLoanScheme: listLoanScheme,
        clear: true,
      ));
    } else {
      emit(state.copyWith(
        status: BlocStatus.failure,
        errorMessage: result.errorMessage,
      ));
    }
  }

  updatePayload({
    List<MTradeCartProductModel>? products,
    String? orderID,
    String? transactionID,
    String? provinceCode,
    String? districtCode,
    String? wardCode,
  }) {
    _payload = _payload.copyWith(
      type: orderID != null && transactionID != null ? 'mtrade/mpl_payment' : null,
      orders: products?.map((e) => MTradeCartPayload.fromJson(e.toJsonPreScreenPayload())).toList(),
      orderID: orderID,
      transactionID: transactionID,
      provinceCode: provinceCode,
      districtCode: districtCode,
      wardCode: wardCode,
    );
  }

  initProducts({
    List<MTradeCartProductModel>? products,
    String? orderID,
    String? transactionID,
  }) {
    updatePayload(
      products: products,
      orderID: orderID,
      transactionID: transactionID,
    );
    if (orderID == null && transactionID == null) {
      final totalPrice = products?.map((e) => (e.price ?? 0) * (e.quantity ?? 0)).fold(0, (pre, cur) => pre + cur);
      emit(state.copyWith(
        products: products,
        totalPrice: totalPrice?.toDouble(),
      ));
    }
    _updateTotalPriceAfterPromotions();
  }

  initDeliveryLocation({
    String? provinceCode,
    String? districtCode,
    String? wardCode,
  }) {
    updatePayload(
      provinceCode: provinceCode,
      districtCode: districtCode,
      wardCode: wardCode,
    );
  }

  selectVehicleType({required VehicleType vehicleType}) {
    emit(state.copyWith(
      vehicleType: vehicleType,
    ));
    _validate();
  }

  captureFrontDocument({
    required File image,
  }) async {
    emit(state.copyWith(
      frontCaptureStatus: BlocStatus.loading,
    ));
    BaseModel<String> result = await _repository.uploadImageFromFile(image);
    if (result.status) {
      emit(state.copyWith(
        frontCaptureStatus: BlocStatus.success,
        imageDocumentFrontUrl: result.data,
      ));
    } else {
      emit(state.copyWith(
        frontCaptureStatus: BlocStatus.failure,
      ));
    }
    _validate();
  }

  captureBackDocument({
    required File image,
  }) async {
    emit(state.copyWith(
      backCaptureStatus: BlocStatus.loading,
    ));
    BaseModel<String> result = await _repository.uploadImageFromFile(image);
    if (result.status) {
      emit(state.copyWith(
        backCaptureStatus: BlocStatus.success,
        imageDocumentBackUrl: result.data,
      ));
    } else {
      emit(state.copyWith(
        backCaptureStatus: BlocStatus.failure,
      ));
    }
    _validate();
  }

  removeFrontDocument() async {
    emit(state.copyWith(
      imageDocumentFrontUrl: '',
    ));
    _validate();
  }

  removeBackDocument() async {
    emit(state.copyWith(
      imageDocumentBackUrl: '',
    ));
    _validate();
  }

  _selectDefaultJoinInsurance() {
    final type = JoinInsuranceType.values.firstWhereOrNull((e) => e.value == state.scheme?.requireInsurance);
    emit(state.copyWith(
      joinInsuranceType: type,
    ));
    if (type?.isRequired == true) {
      selectJoinInsurance(join: true);
    }
  }

  selectLoanScheme(int? value) {
    final data = state.data?.schemes?.firstWhereOrNull((e) => e.schemeID == value);

    loanSchemeController.text = data?.schemeName ?? "";
    downPaymentAmountController.clear();
    loanTenorController.clear();

    final hasDownPayment = data?.hasDownPayment() ?? false;
    final List<DownPaymentModel> listDownPayment =
        data?.getListDownPayment(totalPrice: state.totalPriceAfterPromotions) ?? [];
    final List<TenorConversionFeeSchemeModel> listLoanTenor = data?.getListLoanTenor() ?? [];

    emit(state.clear().copyWith(
          scheme: data,
          selectedLoanSchemeID: value,
          listDownPayment: listDownPayment,
          listLoanTenor: listLoanTenor,
          enabledDownPaymentAmount: true,
          enabledLoanTenor: true,
        ));

    _selectDefaultJoinInsurance();
    selectLoanTenor(listLoanTenor.getFirst()?.tenor ?? 0);

    final tenor = listLoanTenor.firstWhereOrNull((e) => e.tenor == AppConstants.defaultLoanTenor);
    if (tenor?.tenor != null) {
      selectLoanTenor(tenor?.tenor);
    } else {
      selectLoanTenor(listLoanTenor.getFirst()?.tenor ?? 0);
    }

    if (!hasDownPayment) {
      selectDownPaymentPercent(listDownPayment.valueAt(0)?.percent);
    }

    _validate();
  }

  selectDownPaymentPercent(double? value) {
    final data = state.listDownPayment.firstWhereOrNull((e) => e.percent == value);
    if (data == null) {
      return;
    }

    downPaymentAmountController.text = data.name ?? "";

    emit(state.copyWith(
      selectedDownPaymentPercent: data.percent,
    ));

    _calculate();
  }

  selectLoanTenor(int? value) {
    final data = state.listLoanTenor.firstWhereOrNull((e) => e.tenor == value);
    if (data == null) {
      return;
    }

    loanTenorController.text = data.name ?? "";

    emit(state.copyWith(
      selectedLoanTenor: data,
    ));

    _calculate();
  }

  selectJoinInsurance({required bool join}) {
    emit(state.copyWith(
      selectedJoinInsurance: join,
    ));

    _calculate();
  }

  double _getInsurancePercent() {
    return (state.selectedJoinInsurance == true) ? (state.scheme?.insurance ?? 0) : 0;
  }

  _calculate() {
    int tenor = state.selectedLoanTenor?.tenor ?? 0;
    double tenorConversionFeePercent = state.selectedLoanTenor?.conversionFee ?? 0;
    double totalPrice = state.totalPriceAfterPromotions;
    double selectedDownPaymentPercent = state.selectedDownPaymentPercent ?? 0;
    double newDownPaymentAmount =
        CalculateUtil.getPrice(price: totalPrice, percent: selectedDownPaymentPercent).roundToThousands().toDouble();
    double newLoanAmount = totalPrice - newDownPaymentAmount;
    double newTenorConversionFeeAmount =
        CalculateUtil.getPrice(price: newLoanAmount, percent: tenorConversionFeePercent).roundToThousands().toDouble();
    double newInsurancePercent = _getInsurancePercent();
    double newInsuranceAmount =
        CalculateUtil.getPrice(price: newLoanAmount, percent: newInsurancePercent).roundToThousands().toDouble();
    double newTotalLoanAmount = newLoanAmount + newInsuranceAmount + newTenorConversionFeeAmount;
    double interestRate = state.scheme?.interestRate ?? 0;
    double newEmi =
        CalculateUtil.getAnnuity(newLoanAmount + newTenorConversionFeeAmount, interestRate, tenor, newInsurancePercent)
            .roundToThousands()
            .toDouble();

    emit(state.copyWith(
      newDownPaymentAmount: newDownPaymentAmount,
      newLoanAmount: newLoanAmount,
      newInsurancePercent: newInsurancePercent,
      newInsuranceAmount: newInsuranceAmount,
      newTotalLoanAmount: newTotalLoanAmount,
      newTenorConversionFeeAmount: newTenorConversionFeeAmount,
      newEmi: newEmi,
    ));

    _validate();
  }

  changePolicy() {
    emit(state.copyWith(
      acceptedPolicy: !state.acceptedPolicy,
    ));
  }

  _validate() {
    final joinInsurance = state.joinInsuranceType.isRequired
        ? state.selectedJoinInsurance == true
        : state.joinInsuranceType.isOptional
            ? state.selectedJoinInsurance != null
            : true; // true: ignore because type is hide, don't config insurance to select
    final enabledSubmit = state.selectedDownPaymentPercent != null &&
        state.selectedLoanSchemeID != null &&
        state.selectedLoanTenor?.tenor != null &&
        joinInsurance;
    bool insuranceMissing = /*state.vehicleType == null ||*/
        TextUtils.isEmpty(state.imageDocumentBackUrl) || TextUtils.isEmpty(state.imageDocumentBackUrl);
    bool disable = state.data?.type == PayLaterType.mpl.value && insuranceMissing;
    emit(state.copyWith(
      enabledSubmit: enabledSubmit && !disable,
    ));
  }

  submit(String? source) async {
    if (!state.enabledSubmit) {
      return;
    }

    emit(state.copyWith(
      statusSubmit: BlocStatus.loading,
    ));

    final scheme = state.scheme;
    final orders = state.data?.orders?.map((item) {
      final promotions = state.promotions.where((e) => e.sku == item.sku).toList();
      List<OmsPromotionCodes> codes = [];
      double promotionPrice = 0.0;
      for (var promo in promotions) {
        promo.codes?.forEach((element) {
          promotionPrice += element.promotion?.getPromotionPriceByQuantity(1, sku: item.sku ?? "") ?? 0;
        });
        codes.addAll(promo.codes?.map((e) => OmsPromotionCodes(code: e.code ?? '')).toList() ?? []);
      }
      OrderPrice? price = state.orderPrices.firstWhereOrNull((element) => element.sku == item.sku);
      bool allowWholesalePrice = state.promotions.isEmpty == true;
      bool existWholesalePrice = state.orderPrices.any((element) => element.existWholesalePrice());
      return item.copyWith(
        price: allowWholesalePrice && existWholesalePrice ? price?.newPrice : price?.originalPrice,
        promotions: codes,
        promotionPrice: promotionPrice <= 0 ? null : promotionPrice,
        productPriceId: state.promotions.isNotEmpty ? null : price?.productPriceId,
        productPriceItemId: state.promotions.isNotEmpty ? null : price?.productPriceItemId,
      );
    }).toList();

    final result = await _repository.genProductToken(
      payload: MTradeGenProductTokenPayload(
        type: state.data?.type,
        source: source,
        productInfo: orders,
        loanTerms: state.selectedLoanTenor?.tenor,
        loanTermsConversionFee: state.selectedLoanTenor?.conversionFee,
        loanPurpose: scheme?.loanPurpose,
        prepayPercent: state.selectedDownPaymentPercent,
        interestRate: scheme?.interestRate,
        requireInsurance: state.scheme?.requireInsurance,
        insurance: state.newInsurancePercent,
        schemeID: state.selectedLoanSchemeID,
        schemeName: scheme?.schemeName,
        orders: orders,
        extraData: state.data?.type == PayLaterType.mpl.value
            ? ExtraData(
                owner: state.vehicleType?.code,
                frontLicenseImg: state.imageDocumentFrontUrl,
                backLicenseImg: state.imageDocumentBackUrl,
              )
            : null,
        provinceCode: _payload.provinceCode,
        districtCode: _payload.districtCode,
        wardCode: _payload.wardCode,
        channelCode: 'AGENT_APP',
      ),
    );

    if (result.status) {
      AppData.instance.generatedProductToken = result.data?.token;
      emit(state.copyWith(
        statusSubmit: BlocStatus.success,
      ));
    } else {
      emit(state.copyWith(
        statusSubmit: BlocStatus.failure,
        errorMessage: result.errorMessage,
      ));
    }
  }

  addPromotions(List<DataProductVariationsModel> data) {
    emit(state.copyWith(
      promotions: data,
    ));
    _updateTotalPromotionPrice();
  }

  updatePromotions(List<DataProductVariationsModel> data) {
    addPromotions(data);
    validateScheme();
  }

  _updateTotalPromotionPrice() {
    double result = 0;
    for (var item in state.promotions) {
      item.codes?.forEach((element) {
        result += element.promotion?.getPromotionPriceByQuantity(1, sku: item.sku ?? "") ?? 0;
      });
    }
    emit(state.copyWith(
      totalPromotionPrice: result,
    ));
    _updateTotalPriceAfterPromotions();
  }

  _updateTotalPriceAfterPromotions() {
    double totalPrice = state.products.map((e) => (e.price ?? 0) * (e.quantity ?? 0)).fold(0, (pre, cur) => pre + cur);
    bool allowWholesalePrice = state.promotions.isEmpty == true;
    bool existWholesalePrice = state.orderPrices.any((element) => element.existWholesalePrice());
    if (allowWholesalePrice && existWholesalePrice) {
      totalPrice = state.products
          .map((e) {
            OrderPrice? orderPrice = state.orderPrices.firstWhereOrNull((element) => element.sku == e.sku);
            if (orderPrice?.existWholesalePrice() == true) {
              return (orderPrice?.newPrice ?? 0) * (e.quantity ?? 1);
            }
            return (e.price ?? 0) * (e.quantity ?? 1);
          })
          .toList()
          .fold(0.0, (pre, cur) => pre + cur);
    }
    emit(state.copyWith(
      totalPrice: totalPrice,
      totalPriceAfterPromotions: totalPrice - (state.totalPromotionPrice),
    ));
  }

  @override
  Future<void> close() {
    loanSchemeController.dispose();
    downPaymentAmountController.dispose();
    loanTenorController.dispose();
    return super.close();
  }
}
