import 'dart:convert';

import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_module/common/extension/list_extension.dart';
import 'package:flutter_module/common/utils/format_util.dart';
import 'package:flutter_module/common/utils/log_util.dart';
import 'package:flutter_module/common/utils/text_util.dart';
import 'package:flutter_module/models/mtrade/filter/filter_object.dart';
import 'package:flutter_module/models/mtrade/filter/filter_object.dart';
import 'package:flutter_module/models/general_object.dart';
import 'package:flutter_module/models/mtrade/filter/parent_filter_object.dart';
import '../../../../common/bloc_status.dart';
import '../../../../models/mtrade/filter/mtrade_filter_group_model.dart';

import '../../repository/mtrade_product_repository.dart';
import 'package:collection/collection.dart';

part 'mtrade_filter_state.dart';

class MTradeFilterCubit extends Cubit<MTradeFilterState> {
  MTradeFilterCubit({
    required this.debugLabel,
  }) : super(const MTradeFilterState());

  bool _closed = false;

  final String debugLabel;
  final MTradeProductRepository _repository = MTradeProductRepository();

  fetchData({bool showLoading = true}) async {
    if (showLoading) {
      emit(state.copyWith(
        status: BlocStatus.loading,
      ));
    }

    final result = await _repository.getListFilter();

    if (result.status) {
      emit(state.copyWith(
        status: BlocStatus.success,
        data: result.data,
      ));
      selectDefaultFilter();
    } else {
      emit(state.copyWith(
        status: BlocStatus.failure,
      ));
    }
  }

  fillData(MTradeFilterState other) {
    emit(state.merge(other));
  }

  fillList(MTradeFilterState other) {
    emit(state.copyWith(
      status: other.status,
      data: other.data,
    ));
  }

  _select({
    required int? index,
    required String keyword,
    required String code,
    required String name,
    required MTradeFilterGroupModel group,
    bool enableSelectSupGroup = false,
    String? parentCode,
  }) {
    Map<String, List<FilterObject>> json = {...state.selectedFilters}..putIfAbsent(keyword, () => []);
    List<FilterObject> data = [...?json[keyword]];

    if (data.map((e) => e.code).toList().contains(code)) {
      data.removeWhere((e) => e.code == code);
    } else {
      final item = FilterObject(
        code: code,
        name: name.trim() == "Tất cả" ? "Tất cả sản phẩm" : name,
        index: index,
        parentCode: parentCode,
        hasSubGroup:
            !enableSelectSupGroup ? null : group.list?.firstWhereOrNull((e) => e.code == code)?.subGroup != null,
      );
      data = (group.multiSelect == true) ? [...data, item] : [item];
    }

    json[keyword] = [...data];

    emit(state.copyWith(
      selectedFilters: json,
    ));

    if (enableSelectSupGroup) {
      _showSubGroup(
        keyword,
        code,
        parentGroup: data.map((e) => e.code).toList().contains(code) ? group : null,
      );
    }
  }

  _showSubGroup(
    String parentKeyword,
    String parentCode, {
    MTradeFilterGroupModel? parentGroup,
  }) {
    final json = {...state.selectedFilters}..remove(state.selectedSubGroup?[parentKeyword]?.keyword);
    if (parentGroup == null) {
      final forceResetSelectedSubGroup = state.selectedSubGroup?.containsKey(parentKeyword) == true;
      emit(state.copyWith(
        selectedFilters: json,
        forceResetSelectedSubGroup: forceResetSelectedSubGroup,
      ));
    } else {
      final group = parentGroup.list?.firstWhereOrNull((e) => e.code == parentCode && e.subGroup != null)?.subGroup;
      final data =
          state.selectedSubGroup?.isNotEmpty == true && !(state.selectedSubGroup?.containsKey(parentKeyword) == true)
              ? null
              : group == null
                  ? null
                  : {parentKeyword: group};
      emit(state.copyWith(
        selectedFilters: json,
        selectedSubGroup: data,
      ));
    }
  }

  selectGroup({
    required int index,
    required String keyword,
    required String code,
    required String name,
  }) {
    final group = state.data.firstWhereOrNull((e) => e.keyword == keyword);
    if (group == null) {
      return;
    }
    _select(
      index: index,
      keyword: keyword,
      code: code,
      name: name,
      group: group,
      enableSelectSupGroup: true,
    );
  }

  selectSubGroup({
    required int? index,
    required String keyword,
    required String code,
    required String name,
    required String parentKeyword,
  }) {
    final group = state.selectedSubGroup?[parentKeyword];
    if (group == null) {
      return;
    }
    _select(
      index: index,
      keyword: keyword,
      code: code,
      name: name,
      group: group,
      parentCode: parentKeyword,
      enableSelectSupGroup: false,
    );
  }

  clearFilter() {
    emit(state.copyWith(
      clearPriceInput: true,
      selectedSubGroup: const {},
      selectedFilters: const {},
    ));
    selectDefaultFilter();
  }

  selectDefaultFilter() {
    final item = state.data.valueAt(0);
    if (item == null) {
      return;
    }
    final keyword = item.keyword ?? "";
    final code = item.list.valueAt(0)?.code ?? "";
    final name = item.list.valueAt(0)?.name ?? "";

    _select(
      index: 0,
      keyword: keyword,
      code: code,
      name: name,
      group: item,
      enableSelectSupGroup: true,
    );
  }

  selectPrice({
    required int? index,
    required String keyword,
    required String name,
    required List<String> prices,
  }) {
    emit(state.copyWith(
      isInputtingPrice: false,
    ));
    final group = state.data.firstWhereOrNull((e) => e.keyword == keyword);
    Map<String, List<FilterObject>> json = {...state.selectedFilters}..putIfAbsent(keyword, () => []);
    List<FilterObject> data = [...?json[keyword]];

    List<FilterObject> exist = data.where((e) => listEquals(e.listCode, prices)).toList();

    if (json.containsKey(keyword) && exist.isNotEmpty) {
      json.remove(keyword);
    } else {
      final item = FilterObject(name: name, listCode: prices, index: index);
      data = (group?.multiSelect == true) ? [...data, item] : [item];
      json[keyword] = [...data];
    }

    emit(state.copyWith(
      selectedFilters: json,
    ));
  }

  updatePriceInput({
    required int index,
    required String keyword,
    required String value,
  }) {
    final group = state.data.firstWhereOrNull((e) => e.keyword == keyword);
    Map<String, List<FilterObject>> json = {...state.selectedFilters};

    List<FilterObject> data = [...?json[keyword]];

    if (data.valueAt(0)?.listCode?.length != group?.inputs?.length && !state.isInputtingPrice) {
      data = [
        FilterObject(
          listCode: List.filled(group?.inputs?.length ?? 0, ""),
        ),
      ];
    }

    final tmp = data[0].copyWith(
      listCode: [...?data[0].listCode],
    );

    tmp.listCode![index] = value;

    final name = group?.list?.firstWhereOrNull((e) => listEquals([...?e.price], tmp.listCode))?.name;

    if (name != null) {
      tmp.name = name;
    } else {
      var minPrice = TextUtils.parseInt(tmp.listCode.valueAt(0));
      var maxPrice = TextUtils.parseInt(tmp.listCode.valueAt(1));

      if (minPrice == null && maxPrice != null) {
        tmp.name = "Dưới ${FormatUtil.doubleFormat(maxPrice / 1000000)}";
      } else if (minPrice != null && maxPrice == null) {
        tmp.name = "Trên ${FormatUtil.doubleFormat(minPrice / 1000000)}";
      } else if (minPrice != null && maxPrice != null) {
        tmp.name = tmp.listCode!.map((e) {
          double amount = TextUtils.parseDouble(e) ?? 0;
          return FormatUtil.doubleFormat(amount / 1000000);
        }).join("-");
      }
      tmp.name = "${tmp.name}tr";
    }

    data[0] = tmp;
    json[keyword] = data;

    emit(state.copyWith(
      selectedFilters: json,
      isInputtingPrice: true,
    ));
  }

  clearPriceInput() {
    emit(state.copyWith(
      clearPriceInput: true,
    ));
  }

  submit({
    required Function() onSuccess,
    required Function(String) onFailure,
  }) {
    final option = state.selectedFilters["price"]?.valueAt(0);
    if (option != null) {
      var defaultMinPrice = 100000;
      var defaultMinFormatPrice = FormatUtil.currencyFormat(defaultMinPrice, showUnit: false);
      var prices = option.listCode ?? [];

      var minPrice = TextUtils.parseInt(prices.valueAt(0));
      var maxPrice = TextUtils.parseInt(prices.valueAt(1));

      if (minPrice != null && maxPrice != null) {
        if (prices.any((e) => (TextUtils.parseInt(e) ?? 0) < defaultMinPrice)) {
          onFailure("Giá tiền tối thiểu là $defaultMinFormatPrice");
          return;
        }
        if (maxPrice < minPrice) {
          onFailure("Giá tiền tối thiểu phải nhỏ hơn giá tiền tối đa");
          return;
        }
      }

      final tmp = prices.every((e) {
        final value = TextUtils.parseInt(e);
        return value == null || value >= defaultMinPrice;
      });
      if (!tmp) {
        onFailure("Giá tiền tối thiểu là $defaultMinFormatPrice");
        return;
      }
    }
    getFilterPath();
    onSuccess();
  }

  Map<String, List<String>> convertFilters() {
    final tmp = state.selectedFilters.map(
      (key, value) => MapEntry(
        key,
        key == "price" ? value.valueAt(0)?.listCode ?? [] : value.map((e) => e.code ?? "").toList(),
      ),
    );
    return tmp;
  }

  getFilterPath() {
    List<String?> keywords = state.data.map((e) => e.keyword).toList();

    List<ParentFilterObject> parentGroups = [];
    List<ParentFilterObject> subGroups = [];

    state.selectedFilters.forEach((key, value) {
      ParentFilterObject item = ParentFilterObject(code: key, filters: value);
      if (keywords.contains(key)) {
        parentGroups.add(item);
      } else {
        subGroups.add(item);
      }
    });

    parentGroups.sort((first, second) {
      int index1 = keywords.indexOf(first.code);
      int index2 = keywords.indexOf(second.code);
      return index1.compareTo(index2);
    });

    for (var e in parentGroups) {
      e.filters.sort((first, second) {
        return (first.index ?? 0).compareTo((second.index ?? 0));
      });
    }

    for (var e in subGroups) {
      e.filters.sort((first, second) {
        return (first.index ?? 0).compareTo((second.index ?? 0));
      });
    }

    String subGroupPath = subGroups.valueAt(0)?.getName() ?? "";
    String parentGroupPath = parentGroups
        .map((e) {
          String temp = e.getName();
          return temp;
        })
        .where((e) => TextUtils.isNotEmpty(e))
        .join(" - ")
        .replaceAll("{sub}", subGroupPath.isEmpty ? "" : " /// $subGroupPath");

    final jsonParent = parentGroups.asMap().map((key, value) {
      return MapEntry(
        value.code ?? "",
        value.filters,
      );
    });

    AppLog.d("MTradeFilterCubit", parentGroupPath);
    AppLog.d("MTradeFilterCubit", jsonEncode(jsonParent));

    emit(state.copyWith(
      path: parentGroupPath,
    ));
  }

  clearData() {
    emit(const MTradeFilterState());
  }

  @override
  void emit(MTradeFilterState state) {
    if (!_closed) {
      super.emit(state);
    }
  }

  @override
  Future<void> close() {
    _closed = true;
    return super.close();
  }
}
