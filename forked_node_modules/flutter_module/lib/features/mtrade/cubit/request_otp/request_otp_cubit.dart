import 'dart:async';

import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter/material.dart';
import 'package:flutter_module/app_data.dart';
import 'package:flutter_module/common/bloc_status.dart';
import 'package:flutter_module/common/constants.dart';
import 'package:flutter_module/common/enum/error_code_type.dart';
import 'package:flutter_module/common/enum/otp_type.dart';
import 'package:flutter_module/features/mtrade/repository/mtrade_product_repository.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_request_otp_payload.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_verify_otp_payload.dart';

part 'request_otp_state.dart';

class RequestOtpCubit extends Cubit<RequestOtpState> {
  RequestOtpCubit() : super(const RequestOtpState());

  final MTradeProductRepository _repository = MTradeProductRepository();
  final TextEditingController otpController = TextEditingController();
  Timer? timer;

  requestOTP({
    required String mobilePhone,
    String? type,
    bool? isRetry,
  }) async {
    emit(state.copyWith(
      requestStatus: BlocStatus.loading,
      verifyStatus: BlocStatus.initial,
    ));

    AppData.instance.lastOTPType = type ?? OTPType.voice.name;

    final result = await _repository.requestOTP(
      payload: MTradeRequestOTPPayload(
        mobilePhone: mobilePhone,
        type: type,
        isRetry: isRetry,
      ),
    );

    if (result.status) {
      emit(state.copyWith(
        requestStatus: BlocStatus.success,
        countDown: AppConstants.otpCountdown,
        logOtpID: result.data?.logOtpID,
      ));
      _startTimer();
    } else {
      emit(state.copyWith(
        requestStatus: BlocStatus.failure,
      ));
    }
  }

  verifyOTP({
    required String mobilePhone,
  }) async {
    emit(state.copyWith(
      verifyStatus: BlocStatus.loading,
    ));

    final result = await _repository.verifyOTP(
      payload: MTradeVerifyOTPPayload(
        mobilePhone: mobilePhone,
        otpCode: otpController.text,
      ),
    );

    if (result.status) {
      emit(state.copyWith(
        verifyStatus: BlocStatus.success,
      ));
    } else {
      final errorCode = result.errorCode;
      final errorMessage = result.errorMessage;
      final errorFields = {...state.errorFields};

      if (errorCode == ErrorCodeType.wrongOtp.value) {
        errorFields[AppConstants.otpKey] = errorMessage ?? '';
        emit(state.copyWith(
          verifyStatus: BlocStatus.initial,
          errorFields: errorFields,
        ));
      } else if (errorCode == ErrorCodeType.otpNotExist.value) {
        errorFields[AppConstants.otpKey] = errorMessage ?? '';
        _cancelTimer();
        emit(state.copyWith(
          countDown: 0,
          verifyStatus: BlocStatus.initial,
          errorFields: errorFields,
        ));
      } else {
        errorFields[AppConstants.otpKey] = errorMessage ?? '';
        emit(state.copyWith(
          verifyStatus: BlocStatus.failure,
          errorFields: errorFields,
        ));
      }
    }
  }

  requestEmailOTP({
    required String email,
  }) async {
    emit(state.copyWith(
      requestStatus: BlocStatus.loading,
      verifyStatus: BlocStatus.initial,
    ));

    final result = await _repository.requestEmailOTP(
      email: email,
    );

    if (result.status) {
      emit(state.copyWith(
        requestStatus: BlocStatus.success,
        countDown: AppConstants.otpCountdown,
      ));
      _startTimer();
    } else {
      emit(state.copyWith(
        requestStatus: BlocStatus.failure,
      ));
    }
  }

  verifyEmailOTP({
    required String email,
  }) async {
    emit(state.copyWith(
      verifyStatus: BlocStatus.loading,
    ));

    final result = await _repository.verifyEmailOTP(
      email: email,
      otpCode: otpController.text,
    );

    if (result.status) {
      emit(state.copyWith(
        verifyStatus: BlocStatus.success,
      ));
    } else {
      final errorCode = result.errorCode;
      final errorMessage = result.errorMessage;
      final errorFields = {...state.errorFields};

      if (errorCode == ErrorCodeType.wrongOtp.value) {
        errorFields[AppConstants.otpKey] = errorMessage ?? '';
        emit(state.copyWith(
          verifyStatus: BlocStatus.initial,
          errorFields: errorFields,
        ));
      } else {
        errorFields[AppConstants.otpKey] = errorMessage ?? '';
        emit(state.copyWith(
          verifyStatus: BlocStatus.failure,
          errorFields: errorFields,
        ));
      }
    }
  }

  otpChange(String text) {
    final errorFields = {...state.errorFields};
    errorFields.removeWhere((key, value) => key == AppConstants.otpKey);
    emit(state.copyWith(
      verifyStatus: BlocStatus.initial,
      errorFields: errorFields,
    ));
  }

  _startTimer() {
    if (timer != null) {
      return;
    }
    timer = Timer.periodic(const Duration(seconds: 1), (Timer t) {
      if (state.countDown == 1) {
        t.cancel();
        timer?.cancel();
        timer = null;
      }
      emit(state.copyWith(countDown: (state.countDown ?? 0) - 1));
    });
  }

  _cancelTimer() {
    timer?.cancel();
    timer = null;
  }

  @override
  Future<void> close() {
    _cancelTimer();
    return super.close();
  }
}
