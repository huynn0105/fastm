import 'package:bloc/bloc.dart';
import 'package:collection/collection.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter_module/app_data.dart';
import 'package:flutter_module/common/constants.dart';
import 'package:flutter_module/common/enum/mtrade/risk_level.dart';
import 'package:flutter_module/common/extension/list_extension.dart';
import 'package:flutter_module/common/utils/text_util.dart';
import 'package:flutter_module/services/api/mtrade/payload/check_product_stock_payload.dart';

import '../../../../common/bloc_status.dart';
import '../../../../common/enum/mtrade/payment_type.dart';
import '../../../../models/base_model.dart';
import '../../../../models/mtrade/cart/mtrade_cart_product_model.dart';
import '../../../../models/mtrade/check_project_code/check_project_code_model.dart';
import '../../../../models/mtrade/order/mtrade_order_price_model.dart';
import '../../../../models/mtrade/promotion/data_product_variations_model.dart';
import '../../../../services/api/mtrade/payload/mtrade_cart_payload.dart';
import '../../../../services/api/mtrade/payload/mtrade_order_price_by_sku_payload.dart';
import '../../../../services/api/mtrade/payload/mtrade_pay_now_order_payload.dart';
import '../../../../services/api/mtrade/payload/mtrade_pre_screen_payload.dart';
import '../../repository/mtrade_product_repository.dart';

part 'mtrade_cart_state.dart';

class MTradeCartCubit extends Cubit<MTradeCartState> {
  MTradeCartCubit() : super(const MTradeCartState());

  final MTradeProductRepository _repository = MTradeProductRepository();

  int _page = 1;

  fetchData({bool showLoading = true, bool loadmore = false}) async {
    if (showLoading) {
      emit(state.copyWith(
        status: BlocStatus.loading,
      ));
    }

    _page = loadmore ? _page + 1 : 1;

    final result = await _repository.getListCart(page: _page);

    if (result.status) {
      var data = result.data ?? [];
      if (loadmore) {
        data = [...state.products, ...data];
      }
      var selectedProductIDs = data
          .where((e) {
            var invalid = (e.productInvalid ?? false);
            var outOfStock = (e.productOutOfStock ?? false);
            return state.selectedProductIDs.contains(e.id) && !invalid && !outOfStock;
          })
          .map((e) => e.id ?? "")
          .toList();

      ///
      emit(state.copyWith(
        status: BlocStatus.success,
        products: data,
        selectedProductIDs: loadmore ? null : selectedProductIDs,
        errorFields: loadmore ? null : const {},
      ));
      if (selectedProductIDs.isNotEmpty) {
        _updateEnablePaymentType();
        _updatePrice();
      }
    } else {
      emit(state.copyWith(
        status: BlocStatus.failure,
      ));
    }
  }

  Future refreshData() async {
    await fetchData(showLoading: false);
  }

  loadmoreData() async {
    final length = state.products.length;
    await fetchData(showLoading: false, loadmore: true);
    return length != state.products.length;
  }

  selectProduct(
    String id, {
    Function()? onSelected,
    Function()? onUnselected,
  }) {
    List<String> ids = [...state.selectedProductIDs];
    bool isUnselected = true;

    if (ids.contains(id)) {
      ids.remove(id);
      isUnselected = true;
    } else {
      ids.add(id);
      isUnselected = false;
    }

    emit(state.copyWith(
      selectedProductIDs: ids,
    ));

    if (isUnselected) {
      onUnselected?.call();
    } else {
      onSelected?.call();
    }

    _updateEnablePaymentType();
    _updatePrice();
  }

  _updateEnablePaymentType() {
    final payNow = state.selectedProductIDs.isEmpty
        ? false
        : state.products.where((e) => state.selectedProductIDs.contains(e.id ?? "")).toList().every(
            (e) {
              bool type = e.payNow == 1;
              return type;
            },
          );

    bool enabledPayLater = AppData.instance.configs?.product?.enabledMPLPayLater ?? false;

    if (!enabledPayLater) {
      emit(state.copyWith(
        enabledPayNow: payNow,
        errorFields: {},
      ));
      return;
    }

    // Có hỗ trợ phương thức thanh toán trả chậm.
    bool ruleOnlyPayLaterType = false;
    // Có tối đa 1 mặt hàng High Risk.
    bool ruleOnlyOneHighRisk = false;
    // Mỗi sản phẩm có tối đa 1 mặt hàng (SKU).
    bool ruleOnlyOneProductPerCategory = false;
    // Mỗi sản phẩm có tối đa 1 mặt hàng (SKU).
    bool ruleOnlyOneSkuPerProduct = false;
    // Mỗi mặt hàng (SKU) có số lượng tối đa là 1.
    bool ruleOnlyOneQuantityPerSku = false;

    Map<String, String> errorFields = {...state.errorFields};

    if (state.selectedProductIDs.isNotEmpty) {
      final data = state.products.where((e) => state.selectedProductIDs.contains(e.id ?? "")).toList();

      ruleOnlyPayLaterType = data.every((e) => e.payLater == 1);

      ruleOnlyOneHighRisk = data.where((e) => e.riskLevel == RiskLevel.high.code).length <= 1;

      Map<String, List<MTradeCartProductModel>> tempProductsByCategory = groupBy(data, (e) {
        return e.productCategory ?? "";
      });
      ruleOnlyOneProductPerCategory = tempProductsByCategory.values.every((e) => e.length == 1);

      Map<String, List<MTradeCartProductModel>> tempSkuPerProducts = groupBy(data, (e) {
        return e.productCode ?? "";
      });
      ruleOnlyOneSkuPerProduct = tempSkuPerProducts.values.every((e) => e.length == 1);

      ruleOnlyOneQuantityPerSku = data.every((e) => e.quantity == 1);

      //
      if (!ruleOnlyOneQuantityPerSku) {
        errorFields[AppConstants.ruleOnlyOneQuantityPerSku] = "- Mỗi sản phẩm chỉ hỗ trợ trả chậm với số lượng là 1";
      } else {
        errorFields.remove(AppConstants.ruleOnlyOneQuantityPerSku);
      }
      bool supported =
          ruleOnlyPayLaterType && ruleOnlyOneHighRisk && ruleOnlyOneProductPerCategory && ruleOnlyOneSkuPerProduct;
      if (!supported) {
        errorFields[AppConstants.ruleUnsupported] = "- Sản phẩm được chọn không hỗ trợ trả chậm cùng lúc";
      } else {
        errorFields.remove(AppConstants.ruleUnsupported);
      }

      /// Log
      // final mapper = tempProductsByCategory.map((key, value) {
      //   final map = MapEntry(key, groupBy(value, (e) => e.productCode ?? ""));
      //   return map;
      // });
      // AppLog.d("aaa-1", "\n${jsonEncode(mapper)}");
      // AppLog.d("aaa-2", jsonEncode(errorFields));
    } else {
      errorFields = {};
    }

    bool payLater = ruleOnlyPayLaterType &&
        ruleOnlyOneHighRisk &&
        ruleOnlyOneProductPerCategory &&
        ruleOnlyOneSkuPerProduct &&
        ruleOnlyOneQuantityPerSku;

    emit(state.copyWith(
      enabledPayNow: payNow,
      enabledPayLater: payLater,
      errorFields: errorFields,
    ));
  }

  _updatePrice() {
    if (state.selectedProductIDs.isEmpty) {
      emit(state.copyWith(
        totalPrice: 0,
        totalQuantity: 0,
      ));
      _updateTotalPromotionPrice();
      return;
    }

    double totalPrice = 0;
    int totalQuantity = 0;
    final data = state.products.where((e) => state.selectedProductIDs.contains(e.id ?? "")).toList();

    for (var e in data) {
      totalQuantity += (e.quantity ?? 0);
      totalPrice += ((e.quantity ?? 0) * (e.price ?? 0));
    }

    emit(state.copyWith(
      totalPrice: totalPrice,
      totalQuantity: totalQuantity,
    ));
    _updateTotalPromotionPrice();
  }

  _deleteLocalProduct(int index, String id) {
    List<MTradeCartProductModel> products = [...state.products];
    List<String> selectedProductIDs = [...state.selectedProductIDs];

    products.removeAt(index);
    selectedProductIDs.remove(id);

    emit(state.copyWith(
      products: products,
      selectedProductIDs: selectedProductIDs,
    ));
    _updateEnablePaymentType();
    _updatePrice();
  }

  deleteProduct(int index, String id) async {
    emit(state.copyWith(
      deleteStatus: BlocStatus.loading,
    ));

    final product = state.products[index];

    final result = await _repository.deleteCartItem(
      payload: MTradeCartPayload(
        productID: TextUtils.parseInt(product.productID ?? ""),
        sku: product.sku,
        quantity: product.quantity,
      ),
    );

    if (result.status) {
      emit(state.copyWith(
        deleteStatus: BlocStatus.success,
      ));
      _deleteLocalProduct(index, id);
    } else {
      emit(state.copyWith(
        deleteStatus: BlocStatus.failure,
      ));
    }
  }

  clearSelectedProduct() {
    emit(state.copyWith(
      selectedProductIDs: const [],
      totalPrice: 0,
    ));
  }

  updateQuantity(int index, int quantity) {
    final products = [...state.products];
    products[index] = products[index].copyWith(
      quantity: quantity,
    );
    emit(state.copyWith(
      products: products,
    ));
    _updateEnablePaymentType();
    _updatePrice();
  }

  Future<bool> _checkProjectPayNow() async {
    emit(state.copyWith(
      checkProjectPayNowStatus: BlocStatus.loading,
    ));

    final result = await _repository.checkProjectCode();

    final status = result.data?.checkPayNow() ?? false;
    if (result.status) {
      if (status) {
        emit(state.copyWith(
          checkProjectPayNowStatus: BlocStatus.success,
          projectCode: result.data?.payNow,
        ));
      } else {
        emit(state.copyWith(
          checkProjectPayNowStatus: BlocStatus.failure,
          projectCode: result.data?.payNow,
        ));
      }
      return status;
    }
    return result.status;
  }

  Future<bool> _checkProjectPayLater() async {
    emit(state.copyWith(
      checkProjectPayLaterStatus: BlocStatus.loading,
    ));

    final result = await _repository.checkProjectCode();

    final status = result.data?.checkPayLater() ?? false;
    if (result.status) {
      if (status) {
        emit(state.copyWith(
          checkProjectPayLaterStatus: BlocStatus.success,
          projectCode: result.data?.payLater,
        ));
      } else {
        emit(state.copyWith(
          checkProjectPayLaterStatus: BlocStatus.failure,
          projectCode: result.data?.payLater,
        ));
      }
      return status;
    }
    return result.status;
  }

  Future<bool> _checkProductSchemePayLater() async {
    emit(state.copyWith(
      checkProductSchemePayLater: BlocStatus.loading,
    ));

    final products = getSelectedProducts();
    double total = await _getTotalWithPriceOrder(products: products);
    final result = await _repository.getPreScreenData(
      payload: MTradePreScreenDataPayload(
        orders: products.map((e) => MTradeCartPayload.fromJson(e.toJsonPreScreenPayload())).toList(),
        provinceCode: AppData.instance.deliverySupportProvinceCode,
        districtCode: AppData.instance.deliverySupportDistrictCode,
        wardCode: AppData.instance.deliverySupportWardCode,
        newPrice: total,
      ),
    );

    if (result.status) {
      AppData.instance.preScreenData = result.data;
      emit(state.copyWith(
        checkProductSchemePayLater: BlocStatus.success,
      ));
    } else {
      emit(state.copyWith(
        checkProductSchemePayLater: BlocStatus.failure,
        errorMessage: result.errorMessage,
      ));
    }
    return result.status;
  }

  Future<bool> _checkProductStock() async {
    emit(state.copyWith(
      checkProductStockStatus: BlocStatus.loading,
    ));

    final products = getSelectedProducts();
    final result = await _repository.checkProductStock(
      payload: CheckProductStockPayload(
        listSku: products.map((e) => e.sku ?? "").toList(),
        provinceCode: AppData.instance.deliverySupportProvinceCode,
        districtCode: AppData.instance.deliverySupportDistrictCode,
        wardCode: AppData.instance.deliverySupportWardCode,
      ),
    );

    if (result.status) {
      emit(state.copyWith(
        checkProductStockStatus: BlocStatus.success,
      ));
    } else {
      emit(state.copyWith(
        checkProductStockStatus: BlocStatus.failure,
        errorMessage: result.errorMessage,
      ));
    }
    return result.status;
  }

  List<MTradeCartProductModel> getSelectedProducts() {
    return state.products.where((e) => state.selectedProductIDs.contains(e.id)).toList();
  }

  Future<double> _getTotalWithPriceOrder({required List<MTradeCartProductModel> products}) async {
    if (products.where((element) => element.sku != null).isEmpty) return 0;
    BaseModel<MTradeOrderPriceModel> result = await _repository.getOrderPriceBySKU(
        payload: MTradeOrderPriceBySkuPayload(
          order: products.map((e) {
            return Order(sku: e.sku, quantity: e.quantity);
          }).toList(),
          channel: 'AGENT_APP',
          paymentMethod: MTradePaymentType.later.code,
          provinceCode: AppData.instance.deliverySupportProvinceCode,
          districtCode: AppData.instance.deliverySupportDistrictCode,
          wardCode: AppData.instance.deliverySupportWardCode,
        ));
    return _updateTotalPriceAfterPromotions(products: products, orderPrices: result.data?.listPrice ?? []);
  }

  double _updateTotalPriceAfterPromotions({
    required List<MTradeCartProductModel> products,
    required List<OrderPrice> orderPrices,
  }) {
    double totalPrice = products.map((e) => (e.price ?? 0) * (e.quantity ?? 0)).fold(0, (pre, cur) => pre + cur);
    bool existWholesalePrice = orderPrices.any((element) => element.existWholesalePrice());
    if (existWholesalePrice) {
      totalPrice = products
          .map((e) {
            OrderPrice? orderPrice = orderPrices.firstWhereOrNull((element) => element.sku == e.sku);
            if (orderPrice?.existWholesalePrice() == true) {
              return (orderPrice?.newPrice ?? 0) * (e.quantity ?? 1);
            }
            return (e.price ?? 0) * (e.quantity ?? 1);
          })
          .toList()
          .fold(0.0, (pre, cur) => pre + cur);
    }
    return totalPrice;
  }

  payNow({
    required Function(List<MTradeCartProductModel> products) onSuccess,
  }) async {
    if (!(await _checkProjectPayNow())) {
      return;
    }
    if (!(await _checkProductStock())) {
      return;
    }
    onSuccess(getSelectedProducts());
  }

  payLater({
    required Function(List<MTradeCartProductModel> data) onSuccess,
  }) async {
    if (!(await _checkProjectPayLater())) {
      return;
    }
    if (!(await _checkProductStock())) {
      return;
    }
    if (!(await _checkProductSchemePayLater())) {
      return;
    }
    onSuccess(getSelectedProducts());
  }

  updatePromotions(List<DataProductVariationsModel> data) {
    emit(state.copyWith(
      promotions: data,
    ));
    _updateTotalPromotionPrice();
  }

  _updateTotalPromotionPrice() {
    double result = 0;

    for (var item in state.promotions) {
      item.codes?.forEach((element) {
        result += element.promotion?.getPromotionPriceByQuantity(1, sku: item.sku ?? "") ?? 0;
      });
    }
    // for (var item in getSelectedProducts()) {
    //   final promotions = state.promotions.where((e) => e.selection?.map((e) => e.sku).contains(item.sku) == true);
    //   for (var promo in promotions) {
    //     final price = promo.getPromotionPriceByQuantity(item.quantity, sku: item.sku ?? "");
    //     result += price;
    //   }
    // }
    emit(state.copyWith(
      totalPromotionPrice: result,
    ));
  }

  updateSkus() {
    final List<MTradeCartProductModel> selectedProducts =
        state.products.where((e) => state.selectedProductIDs.contains(e.id)).toList();
    final List<OrderItems> orderItems =
        selectedProducts.map((e) => OrderItems(sku: e.sku, quantity: e.quantity)).toList();
    emit(state.copyWith(
      selectedItems: orderItems,
    ));
  }

  clearData() {
    emit(const MTradeCartState());
  }
}
