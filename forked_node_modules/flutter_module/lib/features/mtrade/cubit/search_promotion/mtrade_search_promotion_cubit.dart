import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter_module/common/bloc_status.dart';
import 'package:flutter_module/features/mtrade/repository/mtrade_product_repository.dart';
import 'package:flutter_module/models/mtrade/promotion/mtrade_promotion_model.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_search_promotion_payload.dart';

import '../../../../common/global_function.dart';
import '../../../../models/mtrade/promotion/data_product_variations_model.dart';
import '../../../../services/api/mtrade/payload/mtrade_promotion_product_payload.dart';

part 'mtrade_search_promotion_state.dart';

class MTradeSearchPromotionCubit extends Cubit<MTradeSearchPromotionState> {
  MTradeSearchPromotionCubit() : super(const MTradeSearchPromotionState());
  final MTradeProductRepository _repository = MTradeProductRepository();

  MTradeSearchPromotionPayload _payload = MTradeSearchPromotionPayload();

  searchPromotion({
    bool showLoading = true,
    Function()? onSuccess,
  }) async {
    if (showLoading) {
      emit(state.copyWith(
        searchStatus: BlocStatus.loading,
      ));
    }
    final result = await _repository.searchPromotion(
      payload: _payload,
    );

    if (result.status) {
      final List<DataProductVariationsModel> data = result.data ?? [];
      List<PromotionCode> selectedPromotions = GlobalFunction.flatPromotionCode(data);
      final promotions = state.promotions.map((promo) {
        promo.selectedCount = selectedPromotions
            .where((element) {
              return element.promotion?.getPromotionConditionId() == promo.getPromotionConditionId();
            })
            .toList()
            .length;
        return promo;
      }).toList();

      List<DataProductVariationsModel> selectedValidPromotions = data.where((e) {
        return e.codes?.isNotEmpty == true;
      }).toList();

      final double totalDiscount = _calculateTotalDiscount(selectedValidPromotions);

      onSuccess?.call();

      emit(state.copyWith(
        searchStatus: BlocStatus.success,
        promotions: promotions,
        selectedProduct: result.data,
        totalDiscount: totalDiscount,
      ));
    } else {
      emit(state.copyWith(
        searchStatus: BlocStatus.failure,
        errorMessage: result.errorMessage,
      ));
    }
  }

  updatePayload({
    String? code,
    List<String>? codes,
    List<DataProductVariationsModel>? productionVariations,
    String? provinceCode,
    String? districtCode,
    String? wardCode,
    String? paymentMethod,
  }) {
    _payload = _payload.copyWith(
      code: code,
      codes: codes,
      productionVariations: productionVariations,
      provinceCode: provinceCode,
      districtCode: districtCode,
      wardCode: wardCode,
      paymentMethod: paymentMethod,
    );
  }

  clearErrorMessage() {
    emit(state.copyWith(
      errorMessage: '',
    ));
  }

  // selectPromotion(
  //   MTradePromotionModel item, {
  //   bool forceSelect = false,
  //   List<String> skus = const [],
  // }) {
  //   List<String> listPromotionCodes = [...state.selectedPromotionCodes];
  //   List<MTradePromotionModel> listPromotion = [...state.promotions];
  //   final isExist = listPromotionCodes.contains(item.code);
  //
  //   if (isExist) {
  //     if (!forceSelect) {
  //       listPromotionCodes = listPromotionCodes.where((e) => e != item.code).toList();
  //     }
  //   } else {
  //     listPromotionCodes.add(item.code ?? '');
  //   }
  //
  //   bool? isApplyMulti = listPromotionCodes.isNotEmpty && item.isApplyMulti();
  //
  //   listPromotion = listPromotion
  //       .map(
  //         (e) => e.copyWith(
  //           disabled: listPromotionCodes.isNotEmpty && e.isApplyMulti() != isApplyMulti,
  //         ),
  //       )
  //       .toList();
  //
  //   final double totalDiscount = listPromotion.where((e) => listPromotionCodes.contains(e.code)).fold(
  //         0,
  //         (total, e) => total + e.getDiscount(skus),
  //       );
  //
  //   emit(state.copyWith(
  //     promotions: listPromotion,
  //     selectedPromotionCodes: listPromotionCodes,
  //     totalDiscount: totalDiscount,
  //     isApplyMulti: isApplyMulti,
  //   ));
  // }

  initPromotions(
    List<DataProductVariationsModel> initPromotions, {
    required List<String> skus,
    required List<String> invalidTicketCodes,
    required String? provinceCode,
    required String? districtCode,
    required String? wardCode,
  }) async {
    emit(state.copyWith(status: BlocStatus.loading));

    List<PromotionCode> selectedPromotions = GlobalFunction.flatPromotionCode(initPromotions);
    final result = await _repository.getPromotionProduct(
      payload: MTradePromotionProductPayload(
        skus: skus,
        provinceCode: provinceCode,
        districtCode: districtCode,
        wardCode: wardCode,
      ),
    );
    final data = result.data ?? [];
    final promotions = data.map((promo) {
      promo.selectedCount = selectedPromotions
          .where((selected) {
            return selected.promotion?.getPromotionConditionId() == promo.getPromotionConditionId();
          })
          .toList()
          .length;
      return promo;
    }).toList();

    final validPromotions = promotions.where((e) => !e.isDisabled(skus)).toList();

    final validPromotionsCode = validPromotions.map((e) => e.getPromotionConditionId()).toList();

    List<DataProductVariationsModel> selectedValidPromotions = initPromotions.where((e) {
      if (e.codes?.isEmpty == true) return false;
      return validPromotionsCode.contains(e.codes?.first.promotion?.getPromotionConditionId());
    }).toList();

    final double totalDiscount = _calculateTotalDiscount(selectedValidPromotions);

    // final isApplyMulti = validPromotions.getFirst()?.isApplyMulti();

    emit(state.copyWith(
      status: BlocStatus.success,
      promotions: promotions,
      selectedProduct: initPromotions,
      totalDiscount: totalDiscount,
      // isApplyMulti: isApplyMulti,
    ));
  }

  double _calculateTotalDiscount(List<DataProductVariationsModel> data) {
    return data.fold<double>(0, (double total, e) {
      double temp = 0;
      e.codes?.forEach((element) {
        double discount = element.promotion?.getDiscount([e.sku!]) ?? 0;
        temp += discount;
      });
      return total + temp;
    });
  }

  removePromotion({
    String? voucherCode,
    List<String> skus = const [],
  }) async {
    final initPromotions = state.selectedProduct.map((e) {
      return e.copyWith(
        codes: e.codes?.where((e) => e.code != voucherCode).toList(),
      );
    }).toList();

    initPromotions.removeWhere((element) => element.codes?.isEmpty == true);

    final selectedPromotions = GlobalFunction.flatPromotionCode(state.selectedProduct);

    final promotions = state.promotions.map((promo) {
      promo.selectedCount = selectedPromotions
          .where((selected) {
            return selected.promotion?.getPromotionConditionId() == promo.getPromotionConditionId() &&
                selected.code != voucherCode;
          })
          .toList()
          .length;
      return promo;
    }).toList();

    final validPromotions = promotions.where((e) => !e.isDisabled(skus)).toList();

    final validPromotionsCode = validPromotions.map((e) => e.getPromotionConditionId()).toList();

    List<DataProductVariationsModel> selectedValidPromotions = initPromotions.where((e) {
      if (e.codes?.isEmpty == true) return false;
      return validPromotionsCode.contains(e.codes?.first.promotion?.getPromotionConditionId());
    }).toList();

    final double totalDiscount = _calculateTotalDiscount(selectedValidPromotions);

    emit(state.copyWith(
      status: BlocStatus.success,
      promotions: promotions,
      selectedProduct: initPromotions,
      totalDiscount: totalDiscount,
    ));
  }
}
