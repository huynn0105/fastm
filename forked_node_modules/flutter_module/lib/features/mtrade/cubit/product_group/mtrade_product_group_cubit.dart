import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter_module/common/bloc_status.dart';
import 'package:flutter_module/common/extension/list_extension.dart';
import 'package:flutter_module/models/base_model.dart';
import 'package:flutter_module/models/mtrade/product_group/mtrade_special_group_model.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_category_payload.dart';

import '../../../../app_data.dart';
import '../../../../common/widgets/nested_scrollview.dart';
import '../../../../models/mtrade/product/mtrade_product_model.dart';
import '../../../../models/mtrade/product_group/mtrade_product_group_model.dart';
import '../../../../services/api/mtrade/payload/mtrade_product_payload.dart';
import '../../repository/mtrade_product_repository.dart';

part 'mtrade_product_group_state.dart';

class MTradeProductGroupCubit extends Cubit<MTradeProductGroupState> {
  MTradeProductGroupCubit() : super(const MTradeProductGroupState());

  final MTradeProductRepository _repository = MTradeProductRepository();
  MTradeProductPayload _payload = MTradeProductPayload();
  bool _loadMoreProcess = false;

  late final LoadMoreListSource<MTradeProductModel> productsSource = LoadMoreListSource<MTradeProductModel>(
    onLoadMore: loadmoreProduct,
  );

  fetchData({bool showLoading = true, bool byDeliveryChange = false}) async {
    await fetchGroups(showLoading: showLoading);
    if (showLoading && !byDeliveryChange) {
      String productGroup = state.selectedProductGroup.isNotEmpty
          ? state.selectedProductGroup
          : AppData.instance.selectedProductGroup ?? "";
      if (productGroup.isNotEmpty) {
        selectGroup(productGroup);
      }
      MTradeSpecialGroupModel? specialGroup =
          state.selectedSpecialGroup ?? AppData.instance.selectedSpecialGroup;
      specialGroup ??= state.specialGroups.valueAt(0);

      selectSpecialGroup(specialGroup);
    }
    await fetchProducts(showLoading: showLoading);
  }

  fetchGroups({bool showLoading = true}) async {
    if (showLoading) {
      emit(state.copyWith(
        groupStatus: BlocStatus.loading,
      ));
    }

    final complexResults = await Future.wait([
      _repository.getListProductGroup(
          payload: MTradeCategoryPayload(
        provinceCode: AppData.instance.deliverySupportProvinceCode,
        districtCode: AppData.instance.deliverySupportDistrictCode,
        wardCode: AppData.instance.deliverySupportWardCode,
      )),
      _repository.getListSpecialCategory(),
    ]);

    final BaseModel<MTradeProductGroupModel> groupResult = complexResults.first as BaseModel<MTradeProductGroupModel>;
    final BaseModel<List<MTradeSpecialGroupModel>> specialGroupResult =
        complexResults.last as BaseModel<List<MTradeSpecialGroupModel>>;

    if (groupResult.status && specialGroupResult.status) {
      emit(state.copyWith(
        groupStatus: BlocStatus.success,
        groups: groupResult.data?.list,
        specialGroups: specialGroupResult.data,
      ));
    } else {
      emit(state.copyWith(
        groupStatus: BlocStatus.failure,
      ));
    }
  }

  fetchProducts({
    bool showLoading = true,
    bool loadmore = false,
  }) async {
    if (showLoading) {
      emit(state.copyWith(
        productStatus: BlocStatus.loading,
      ));
    }

    updatePayload(page: loadmore ? (_payload.page ?? 1) + 1 : 1);

    final result = await _repository.getFilterProducts(
      payload: _payload,
    );

    if (result.status) {
      var data = result.data ?? [];
      if (loadmore) {
        data = [...state.products, ...data];
      } else {
        productsSource.reset();
      }
      productsSource.clear();
      productsSource.addAll(data);
      emit(state.copyWith(
        productStatus: BlocStatus.success,
        products: data,
        hasMore: (result.data?.length ?? 0) > 0,
      ));
    } else {
      emit(state.copyWith(
        productStatus: BlocStatus.failure,
      ));
    }
  }

  selectGroup(String code) {
    String productCategory = '';
    if (state.selectedProductGroup != code) {
      productCategory = code;
    }
    updatePayload(productCode: productCategory);
    emit(state.copyWith(
      selectedProductGroup: productCategory,
    ));
  }

  selectSpecialGroup(MTradeSpecialGroupModel? value) {
    MTradeSpecialGroupModel? specialCategory;
    if (state.selectedSpecialGroup?.code != value?.code) {
      specialCategory = value;
    }
    updatePayload(specialCategory: specialCategory);
    emit(state.copyWith(
      selectedSpecialGroup: specialCategory,
    ));
  }

  updatePayload({
    String? productCode,
    String? provinceCode,
    String? districtCode,
    String? wardCode,
    MTradeSpecialGroupModel? specialCategory,
    int? page,
  }) {
    _payload = _payload.copyWith(
      productGroup: productCode == null ? null : (productCode.isNotEmpty ? [productCode] : []),
      specialCategory: specialCategory,
      provinceCode: provinceCode,
      districtCode: districtCode,
      wardCode: wardCode,
      page: page,
    );
  }

  Future refreshData() async {
    await fetchData(showLoading: false);
  }

  Future<bool> loadmoreProduct() async {
    if (_loadMoreProcess) return true;
    _loadMoreProcess = true;
    final length = state.products.length;
    await fetchProducts(showLoading: false, loadmore: true);
    _loadMoreProcess = false;
    return length != state.products.length;
  }

  selectProvince() {
    updatePayload(
      provinceCode: AppData.instance.deliverySupportProvinceCode,
      districtCode: AppData.instance.deliverySupportDistrictCode,
      wardCode: AppData.instance.deliverySupportWardCode,
    );
  }
}
