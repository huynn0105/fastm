import 'package:firebase_database/firebase_database.dart';
import 'package:flutter_module/app_data.dart';
import 'package:flutter_module/common/enum/chat/thread_group_type.dart';
import 'package:flutter_module/common/enum/chat/thread_message_type.dart';
import 'package:flutter_module/common/enum/chat/thread_type.dart';
import 'package:flutter_module/models/chat/message/author_model.dart';
import 'package:flutter_module/models/chat/message/message_model.dart';
import 'package:flutter_module/models/chat/thread/chat_thread_model.dart';
import 'package:flutter_module/models/chat/user/firebase_user_model.dart';
import 'package:flutter_module/models/user/user_info_model.dart';
import 'package:flutter_module/services/api/chat/payload/create_thread/create_group_thread_payload.dart';
import 'package:flutter_module/services/api/chat/payload/create_thread/create_single_thread_payload.dart';
import 'package:flutter_module/services/api/chat/payload/thread_messages/add_message_to_thread_payload.dart';
import 'package:flutter_module/services/api/chat/payload/thread_messages/get_messages_in_thread_payload.dart';
import 'package:flutter_module/services/api/chat/payload/thread_messages/message_payload.dart';
import 'package:flutter_module/services/api/chat/payload/thread_messages/search_message_payload.dart';
import 'package:flutter_module/services/api/chat/payload/thread_messages/update_message_payload.dart';
import 'package:flutter_module/services/api/chat/payload/thread_messages/update_read_time_in_thread_pay_load.dart';
import 'package:flutter_module/services/api/chat/payload/thread_setting/update_background_image_payload.dart';
import 'package:flutter_module/services/firebase/firebase_database/firebase_database_exception.dart';
import 'package:flutter_module/services/firebase/firebase_database/firebase_database_util.dart';
import 'package:flutter_module/services/base/base_response.dart';
import 'package:flutter_module/services/firebase/firebase_service.dart';

import 'firebase_database_api.dart';

abstract class FirebaseDatabaseProtocol implements FirebaseService {
  final FirebaseDatabase db = FirebaseDatabase.instance;

  // String get _name_ => 'FirebaseDatabaseProtocol';

  // void setPersistenceEnabled() => db.setPersistenceEnabled(true);

  DatabaseReference ref(String key) => db.ref(key);

  DatabaseReference get voipRef => ref('voip');

  DatabaseReference get chatRef => ref('chat');

  DatabaseReference get connectedRef => ref('.info/connected');

  DatabaseReference get notificationUserThreadRef => ref('notification/user_thread');

  DatabaseReference get usersRef => chatRef.child('users');

  DatabaseReference get usersThreadsRef => chatRef.child('users_threads');

  DatabaseReference get usersPresenceRef => chatRef.child('users_presence');

  DatabaseReference get usersBlockRef => chatRef.child('users_block');

  DatabaseReference get usersBlockThreadRef => chatRef.child('users_block_thread');

  DatabaseReference get usersBlockByRef => chatRef.child('users_block_by');

  DatabaseReference get usersContactsRef => chatRef.child('users_contacts');

  DatabaseReference get phoneNumbersUserRef => chatRef.child('phonenumbers_user');

  DatabaseReference get threadsRef => chatRef.child('threads');

  DatabaseReference get threadsPublicRef => chatRef.child('threads_public');

  DatabaseReference get threadsMessagesRef => chatRef.child('threads_messages');

  DatabaseReference get threadsTypingRef => chatRef.child('threads_typing');

  DatabaseReference get userTokensRef => voipRef.child('user_tokens');

  @override
  dispose() {}
}

class FirebaseDatabaseService extends FirebaseDatabaseProtocol with FirebaseDatabaseApi {
  FirebaseDatabaseService._();

  static final FirebaseDatabaseService instance = FirebaseDatabaseService._();

  @override
  Future<BaseResponse> getThreadIDsOfUser(
    String userID, {
    int? fromUpdateTime,
  }) {
    return onBaseResponseHandler(
      handler: () async {
        final fbUserID = FirebaseDatabaseUtil.getFirebaseUserID(userID: userID);
        final query = usersThreadsRef.child('$fbUserID/threads');

        DataSnapshot snapshot;
        DataSnapshot? favoriteSnapshot;
        if (fromUpdateTime is int) {
          snapshot = await query.orderByChild('updateTime').endAt(fromUpdateTime).limitToLast(999).get();
          favoriteSnapshot = await query.orderByChild('isFavorite').equalTo(true).get();
        } else {
          snapshot = await query.orderByChild('updateTime').limitToLast(999).get();
        }
        final values = FirebaseDatabaseUtil.convertObjectToMap(snapshot.value).values.toList();
        final favoriteValue = FirebaseDatabaseUtil.convertObjectToMap(favoriteSnapshot?.value).values.toList();

        values.addAll(favoriteValue);

        final children = snapshot.children.toList();
        final data = children.map((e) => e.key).toList().reversed.toList();

        // for (var i = 1; i <= values.length; i++) {
        //   data.add(children[values.length - i].key);
        // }

        return data.whereType<String>().toList();
      },
    );
  }

  @override
  Future<BaseResponse> getThread(String threadID) {
    return onBaseResponseHandler(
      handler: () async {
        final thread = await threadsRef.child(threadID).get();
        return FirebaseDatabaseUtil.convertObjectToMap(thread.value);
      },
    );
  }

  @override
  Future<BaseResponse> getThreadsFromThreadIDs(List<String> threadIDs) {
    return onBaseResponseHandler(
      handler: () async {
        final List threadsArray = [];
        final List<Future> tasks = [];
        for (var i = 0; i < threadIDs.length; i += 1) {
          final threadID = threadIDs[i];
          tasks.add(
            getThread(threadID).then((value) {
              final thread = ChatThreadModel.fromJson(value.data);
              if (value.status == true && FirebaseDatabaseUtil.isThreadValid(thread)) {
                threadsArray.add(value.data);
              }
            }),
          );
        }
        await Future.wait(tasks);
        return threadsArray;
      },
    );
  }

  @override
  Future<BaseResponse> getThreadsOfUser(String userID, {int? fromUpdateTime}) async {
    final threadIDs = await getThreadIDsOfUser(userID, fromUpdateTime: fromUpdateTime);
    if (threadIDs.status == false) {
      return threadIDs;
    }
    final threads = await getThreadsFromThreadIDs(threadIDs.data);
    return threads;
  }

  @override
  Future<BaseResponse> getMessagesInThread({
    required GetMessagesInThreadPayload payload,
  }) async {
    return onBaseResponseHandler(
      handler: () async {
        final messageRef = threadsMessagesRef.child('${payload.threadID}/messages');
        late Query query;
        if (payload.fromCreateTime != null) {
          query = messageRef.orderByChild('createTime').endAt(payload.fromCreateTime).limitToLast(payload.maxCount);
        } else {
          query = messageRef.orderByChild('createTime').limitToLast(payload.maxCount);
        }
        final snapshot = (await query.once()).snapshot;
        final children = snapshot.children.map((e) => FirebaseDatabaseUtil.convertObjectToMap(e.value)).toList();
        return children.reversed.toList();
      },
    );
  }

  @override
  Future<BaseResponse> getExistedMessageInThread({
    required MessagePayload payload,
  }) async {
    return onBaseResponseHandler(
      handler: () async {
        try {
          final messageRef = threadsMessagesRef.child('${payload.threadID}/messages/${payload.messageID}');
          final snapshot = (await messageRef.once()).snapshot;
          if (snapshot.value == null) {
            throw const FirebaseDatabaseException(
              message: 'getExistedMessageInThread',
              code: '',
            );
          }
          return FirebaseDatabaseUtil.convertObjectToMap(snapshot.value);
        } catch (e, stackTrace) {
          throw FirebaseDatabaseException(
            message: 'getExistedMessageInThread: $e',
            code: '',
            stackTrace: stackTrace,
          );
        }
      },
    );
  }

  @override
  Future<BaseResponse> searchMessage({
    required SearchMessagePayload payload,
  }) {
    return onBaseResponseHandler(
      handler: () async {
        try {
          final message = await getExistedMessageInThread(
            payload: MessagePayload(
              threadID: payload.threadID,
              messageID: payload.messageID,
            ),
          );
          final messageCreateTime = message.data?['createTime'];
          if (messageCreateTime == null) {
            throw const FirebaseDatabaseException(
              message: 'MessageID not found',
            );
          }
          final ref = threadsMessagesRef.child('${payload.threadID}/messages');
          // /// Search
          final searchQuery = ref.orderByChild('createTime').startAt(messageCreateTime - 1).endAt(payload.toCreateTime);
          final searchSnapshot = (await searchQuery.once()).snapshot;
          final searchChildren =
              searchSnapshot.children.map((e) => FirebaseDatabaseUtil.convertObjectToMap(e.value)).toList();

          // /// Buffer
          // // final bufferQuery =
          // //     messageRef.orderByChild('createTime').endAt(payload.toCreateTime).limitToLast(payload.maxCount);
          // // final bufferSnapshot = (await bufferQuery.once()).snapshot;
          // // final bufferChildren =
          // //     bufferSnapshot.children.map((e) => FirebaseDatabaseUtil.convertObjectToMap(e.value)).toList();
          //
          // /// Combine to searched message is centered in list
          return [...searchChildren].reversed.toList();
        } catch (e, stackTrace) {
          throw FirebaseDatabaseException(
            message: e.toString(),
            code: 'searchMessage',
            stackTrace: stackTrace,
          );
        }
      },
    );
  }

  @override
  Future<BaseResponse> addMessageToThread({
    required AddMessageToThreadPayload payload,
  }) {
    return onBaseResponseHandler(
      handler: () async {
        final DatabaseReference threadMessagesRef = threadsMessagesRef.child('${payload.threadID}/messages');
        final messageRef = threadMessagesRef.push();
        final messageID = messageRef.key;

        ///
        try {
          // undelete thread if it's deleted by someone
          final threadRes = await getThread(payload.threadID ?? '');
          if (threadRes.data != null) {
            final thread = ChatThreadModel.fromJson(threadRes.data);
            if (thread.isDeletedBySomeone()) {
              await unDeleteThreadChat(threadID: payload.threadID ?? '');
            }
          }

          final data = {
            ...?payload.message?.toFirebaseJson(),
            'uid': messageID,
            'createTime': ServerValue.timestamp,
            'updateTime': ServerValue.timestamp,
            'isDeleted': false,
            'isRecalled': false,
            'threadID': payload.threadID,
            'type_createTime': '${payload.message?.type}_${DateTime.now().millisecondsSinceEpoch}',
          };
          await messageRef.set(data);
          return messageID;
        } catch (e, stackTrace) {
          throw FirebaseDatabaseException(
            message: 'Cannot add new message to thread',
            code: '',
            stackTrace: stackTrace,
          );
        }
      },
    );
  }

  @override
  Future<BaseResponse> addLocalMessageToThread({
    required AddMessageToThreadPayload payload,
  }) {
    return onBaseResponseHandler(
      handler: () async {
        final DatabaseReference threadMessagesRef = threadsMessagesRef.child('${payload.threadID}/messages');
        final messageRef = threadMessagesRef.child('${payload.message?.uid}');

        ///
        try {
          final data = {
            ...?payload.message?.toFirebaseJson(),
          };
          await messageRef.set(data);
          return payload.message?.uid ?? '';
        } catch (e, stackTrace) {
          throw FirebaseDatabaseException(
            message: 'Cannot add new message to thread',
            code: '',
            stackTrace: stackTrace,
          );
        }
      },
    );
  }

  @override
  Future<BaseResponse> pushLocalMessage({
    required AddMessageToThreadPayload payload,
  }) {
    return onBaseResponseHandler(
      handler: () async {
        final DatabaseReference threadMessagesRef = threadsMessagesRef.child('${payload.threadID}/messages');
        final messageRef = threadMessagesRef.push();
        final messageID = messageRef.key;

        final now = DateTime.now().millisecondsSinceEpoch;

        ///
        try {
          final data = {
            ...?payload.message?.toFirebaseJson(),
            'uid': messageID,
            'createTime': now,
            'updateTime': now,
            'isDeleted': false,
            'isRecalled': false,
            'type_createTime': '${payload.message?.type}_$now',
          };
          return data;
        } catch (e, stackTrace) {
          throw FirebaseDatabaseException(
            message: 'Cannot add push message',
            code: '',
            stackTrace: stackTrace,
          );
        }
      },
    );
  }

  @override
  Future<BaseResponse> updateMessage({
    required UpdateMessagePayload payload,
  }) {
    return onBaseResponseHandler(
      handler: () async {
        try {
          final messageRef = threadsMessagesRef.child('${payload.threadID}/messages/${payload.messageID}');
          await messageRef.update({
            ...payload.toJson(),
            if (payload.forceUpdateTime) 'updateTime': ServerValue.timestamp,
          });
          return true;
        } catch (e, stackTrace) {
          throw FirebaseDatabaseException(
            message: 'Cannot update message to thread',
            code: '',
            stackTrace: stackTrace,
          );
        }
      },
    );
  }

  @override
  Future<BaseResponse> updateBackgroundImage({
    required UpdateBackgroundImagePayload payload,
  }) {
    return onBaseResponseHandler(
      handler: () async {
        try {
          final threadRef = threadsRef.child('${payload.threadID}');
          await threadRef.update(payload.toJson());
          return true;
        } catch (e, stackTrace) {
          throw FirebaseDatabaseException(
            message: 'Cannot update background image to thread',
            code: '',
            stackTrace: stackTrace,
          );
        }
      },
    );
  }

  @override
  Future<BaseResponse> toggleUserNotificationOnInThread({required String threadID, required bool isOn}) {
    return onBaseResponseHandler(
      handler: () async {
        try {
          final threadNotificationRef = threadsRef.child('$threadID/isNotificationOns');
          await threadNotificationRef.update({
            FirebaseDatabaseUtil.getFirebaseUserID(): isOn,
          });
          return true;
        } catch (e, stackTrace) {
          throw FirebaseDatabaseException(
            message: 'Cannot update user notification in thread',
            code: '',
            stackTrace: stackTrace,
          );
        }
      },
    );
  }

  @override
  Future<BaseResponse> toggleUserFavoriteInThread({required String threadID, required bool isFavorite}) {
    return onBaseResponseHandler(
      handler: () async {
        try {
          final threadFavoriteRef = threadsRef.child('$threadID/isFavorites');
          final userThreadRef = usersThreadsRef.child('${FirebaseDatabaseUtil.getFirebaseUserID()}/threads/$threadID');
          await threadFavoriteRef.update({
            FirebaseDatabaseUtil.getFirebaseUserID(): isFavorite,
          });
          await userThreadRef.update({
            "isFavorite": isFavorite,
          });
          return true;
        } catch (e, stackTrace) {
          throw FirebaseDatabaseException(
            message: 'Cannot update user favorite in thread',
            code: '',
            stackTrace: stackTrace,
          );
        }
      },
    );
  }

  @override
  Future<BaseResponse> deleteChatThread({required String threadID}) {
    return onBaseResponseHandler(
      handler: () async {
        try {
          final deleteUserRef = threadsRef.child('$threadID/isDeletedByUsers');
          await deleteUserRef.update({
            FirebaseDatabaseUtil.getFirebaseUserID(): true,
          });
          return true;
        } catch (e, stackTrace) {
          throw FirebaseDatabaseException(
            message: 'Cannot delete chat thread',
            code: '',
            stackTrace: stackTrace,
          );
        }
      },
    );
  }

  @override
  Future<BaseResponse> getMessagesInThreadWithType({
    required String threadID,
    required ThreadMessageType type,
    int? maxMessages = 256,
  }) {
    return onBaseResponseHandler(
      handler: () async {
        try {
          final ref = threadsMessagesRef.child('$threadID/messages');
          final query = ref.orderByChild('type').equalTo(type.name).limitToLast(maxMessages ?? 256);
          final snapshot = (await query.once()).snapshot;
          final children = snapshot.children.map((e) => FirebaseDatabaseUtil.convertObjectToMap(e.value)).toList();
          return children.reversed.toList();
        } catch (e, stackTrace) {
          throw FirebaseDatabaseException(
            message: 'Cannot get image messages in thread',
            code: '',
            stackTrace: stackTrace,
          );
        }
      },
    );
  }

  @override
  Future<BaseResponse> createThreadGroup({required CreateGroupThreadPayload payload}) {
    return onBaseResponseHandler(
      handler: () async {
        try {
          final members = {};
          final membersDetails = {};

          for (var user in payload.users) {
            final fbUserID = FirebaseDatabaseUtil.getFirebaseUserID(userID: user.uid);
            members[fbUserID] = {"uid": user.uid};
            membersDetails[fbUserID] = user.toJson();
          }

          //~ Create thread group
          final threadRef = threadsRef.push();
          final threadID = threadRef.key ?? "";
          await threadRef.set({
            "uid": threadID,
            "type": ThreadType.group.name,
            "users": members,
            "usersDetails": membersDetails,
            "adminID": AppData.instance.userID,
            "title": payload.title,
            "photoImage": payload.photoImage,
            "createTime": ServerValue.timestamp,
            "updateTime": ServerValue.timestamp,
            "isDeleted": false,
          });

          //~ Add thread to user
          final List<Future> promises = [];
          for (var user in payload.users) {
            final userThreadRef =
                usersThreadsRef.child('${FirebaseDatabaseUtil.getFirebaseUserID(userID: user.uid)}/threads');

            promises.add(userThreadRef.update({
              threadID: {
                "createTime": ServerValue.timestamp,
                "updateTime": ServerValue.timestamp,
              }
            }));
          }
          await Future.wait(promises);

          final snapshot = (await threadRef.once()).snapshot;

          return FirebaseDatabaseUtil.convertObjectToMap(snapshot.value);
        } catch (e) {
          throw const FirebaseDatabaseException(
            message: 'Cannot thread group',
            code: '',
          );
        }
      },
    );
  }

  @override
  Future<BaseResponse> createSingleThread({
    required CreateSingleThreadPayload payload,
  }) {
    return onBaseResponseHandler(
      handler: () async {
        final generatedThreadID = FirebaseDatabaseUtil.generateSingleThreadID(
          userID1: payload.user1?.uid,
          userID2: payload.user2?.uid,
        );
        if (generatedThreadID == null) {
          throw const FirebaseDatabaseException(
            message: 'createSingleThread',
            code: 'ERROR_INVALID_THREAD_ID',
          );
        }

        /// Check existed single thread
        var thread = await getThread(generatedThreadID);
        if (thread.data != null && thread.data is Map) {
          if (thread.data.isNotEmpty) {
            return thread.data;
          }
        }

        /// Create new single message
        var users = [payload.user1, payload.user2];
        var members = {};
        var membersDetails = {};

        for (var user in users) {
          final fbUserID = FirebaseDatabaseUtil.getFirebaseUserID(userID: user?.uid);
          members[fbUserID] = {'uid': user?.uid};
          membersDetails[fbUserID] = user?.toJson();
        }

        await threadsRef.child(generatedThreadID).set({
          'uid': generatedThreadID,
          'users': members,
          'usersDetails': membersDetails,
          'type': ThreadGroupType.single.name,
          'createTime': ServerValue.timestamp,
          'updateTime': ServerValue.timestamp,
          'isDeleted': false,
        });

        // Add thread to user
        final List<Future> promises = [];
        for (var user in users) {
          final userThreadRef = usersThreadsRef.child(
            '${FirebaseDatabaseUtil.getFirebaseUserID(userID: user?.uid ?? '')}/threads',
          );
          promises.add(
            userThreadRef.update(
              {
                generatedThreadID: {
                  "createTime": ServerValue.timestamp,
                  "updateTime": ServerValue.timestamp,
                }
              },
            ),
          );
        }

        await Future.wait(promises);

        thread = await getThread(generatedThreadID);
        if (thread.data != null && thread.data is Map) {
          if (thread.data.isNotEmpty) {
            return thread.data;
          }
        }
        throw const FirebaseDatabaseException(
          message: 'Cannot create new single thread',
        );
      },
    );
  }

  @override
  Future<BaseResponse> addUsersToGroupThread({required String threadID, required List<ThreadUserDetail> users}) {
    return onBaseResponseHandler(
      handler: () async {
        try {
          // Add user to group thread
          final threadRef = threadsRef.child(threadID);
          final threadUserRef = threadRef.child("users");
          final threadUserDetailRef = threadRef.child("usersDetails");
          final List<Future> promises = [];
          final usersData = FirebaseDatabaseUtil.convertObjectToMap((await threadUserRef.once()).snapshot.value);
          final usersDetail =
              FirebaseDatabaseUtil.convertObjectToMap((await threadUserDetailRef.once()).snapshot.value);

          for (var user in users) {
            final fbUserID = FirebaseDatabaseUtil.getFirebaseUserID(userID: user.uid);
            usersData[fbUserID] = {"uid": user.uid};
            usersDetail[fbUserID] = user.toJson();
            final userThread = {
              threadID: {
                "createTime": ServerValue.timestamp,
                "updateTime": ServerValue.timestamp,
              }
            };

            promises.add(usersThreadsRef.child("$fbUserID/threads").update(userThread));
          }
          promises.add(threadRef.update({
            "users": usersData,
            "usersDetails": usersDetail,
          }));
          await Future.wait(promises);

          // Add a notice message remove by admin
          final AuthorModel? author = AppData.instance.author;
          final userNames = users.map((user) => user.fullName).join(', ');
          final text = "${author?.fullName} đã thêm $userNames vào cuộc trò chuyện này";
          final htmlText =
              "<p><strong>${author?.fullName}</strong> đã thêm <strong>$userNames</strong> vào cuộc trò chuyện này</p>";
          final message = MessageModel.newNoticeMessage(text: text, htmlText: htmlText).copyWith(threadID: threadID);
          await addMessageToThread(payload: AddMessageToThreadPayload(threadID: threadID, message: message));

          return true;
        } catch (e) {
          throw const FirebaseDatabaseException(
            message: 'Cannot thread group',
            code: '',
          );
        }
      },
    );
  }

  @override
  Future<BaseResponse> leaveChatThread({required String threadID}) {
    return onBaseResponseHandler(
      handler: () async {
        try {
          final resultThread = await getThread(threadID);
          final thread = ChatThreadModel.fromJson(resultThread.data);
          final threadRef = threadsRef.child(threadID);

          if (thread.adminID == AppData.instance.userID) {
            String newAdminID = '';
            for (ThreadUserDetail user in (thread.users ?? [])) {
              if (user.uid != AppData.instance.userID) {
                newAdminID = user.uid ?? '';
                break;
              }
            }

            await threadRef.update({
              "adminID": newAdminID,
            });
          }

          final List<Future> promises = [];

          final fbUserID = FirebaseDatabaseUtil.getFirebaseUserID();
          final threadUserRef = threadRef.child("users").child(fbUserID);
          final threadUserDetailRef = threadRef.child("usersDetails").child(fbUserID);
          final userThreadsRef = usersThreadsRef.child(fbUserID).child('threads');

          // remove user from thread
          promises.add(threadUserRef.remove());
          promises.add(threadUserDetailRef.remove());
          // remove threadID from user
          promises.add(userThreadsRef.update({threadID: null}));

          await Future.wait(promises);

          return true;
        } catch (e, stackTrace) {
          throw FirebaseDatabaseException(
            message: 'Cannot leave chat thread',
            code: '',
            stackTrace: stackTrace,
          );
        }
      },
    );
  }

  @override
  Future<BaseResponse> updateTitleGroupThread({required String threadID, required String title}) {
    return onBaseResponseHandler(
      handler: () async {
        try {
          final threadRef = threadsRef.child(threadID);
          await threadRef.update({
            'title': title,
          });

          return true;
        } catch (e, stackTrace) {
          throw FirebaseDatabaseException(
            message: 'Cannot update title group thread',
            code: '',
            stackTrace: stackTrace,
          );
        }
      },
    );
  }

  @override
  Future<BaseResponse> unDeleteThreadChat({required String threadID}) {
    return onBaseResponseHandler(
      handler: () async {
        try {
          final threadRef = threadsRef.child(threadID);
          final isDeletedThreadByUser = threadRef.child('isDeletedByUsers');

          await isDeletedThreadByUser.remove();

          return true;
        } catch (e, stackTrace) {
          throw FirebaseDatabaseException(
            message: 'Cannot update title group thread',
            code: '',
            stackTrace: stackTrace,
          );
        }
      },
    );
  }

  @override
  Future<BaseResponse> updateReadTimeToNowInThread({
    required UpdateReadTimeInThreadPayload payload,
  }) {
    return onBaseResponseHandler(
      handler: () async {
        try {
          final threadRef = threadsRef.child(payload.threadID ?? '');
          final userID = FirebaseDatabaseUtil.getFirebaseUserID(userID: payload.userID ?? '');

          await threadRef.update({
            'updateTime': ServerValue.timestamp,
            'readTimes/$userID': ServerValue.timestamp,
          });

          return true;
        } catch (e, stackTrace) {
          throw FirebaseDatabaseException(
            message: 'Error: updateReadTimeToNowInThread',
            code: '',
            stackTrace: stackTrace,
          );
        }
      },
    );
  }

  @override
  Future<BaseResponse> block({required String userID}) {
    return onBaseResponseHandler(
      handler: () async {
        try {
          final myFbUserID = FirebaseDatabaseUtil.getFirebaseUserID();
          final fbUserID = FirebaseDatabaseUtil.getFirebaseUserID(userID: userID);
          final userBlockRef = usersBlockRef.child(myFbUserID);
          await userBlockRef.update({
            fbUserID: true,
          });

          return true;
        } catch (e, stackTrace) {
          throw FirebaseDatabaseException(
            message: 'Error: updateReadTimeToNowInThread',
            code: '',
            stackTrace: stackTrace,
          );
        }
      },
    );
  }

  @override
  Future<BaseResponse> unblock({required String userID}) {
    return onBaseResponseHandler(
      handler: () async {
        try {
          final myFbUserID = FirebaseDatabaseUtil.getFirebaseUserID();
          final fbUserID = FirebaseDatabaseUtil.getFirebaseUserID(userID: userID);
          final userBlockRef = usersBlockRef.child(myFbUserID);

          await userBlockRef.child(fbUserID).remove();

          return true;
        } catch (e, stackTrace) {
          throw FirebaseDatabaseException(
            message: 'Error: unblock',
            code: '',
            stackTrace: stackTrace,
          );
        }
      },
    );
  }

  @override
  Future<BaseResponse> checkBeBlocked({
    required String threadID,
    required String userID,
  }) {
    return onBaseResponseHandler(
      handler: () async {
        try {
          final fbUserID = FirebaseDatabaseUtil.getFirebaseUserID();
          final snapshot = await usersBlockByRef.child(fbUserID).child(threadID).once();
          if (snapshot.snapshot.value is bool) {
            return snapshot.snapshot.value;
          }
          final result = FirebaseDatabaseUtil.convertObjectToMap(snapshot.snapshot.value);
          return result[threadID] == true;
        } catch (e, stackTrace) {
          throw FirebaseDatabaseException(
            message: 'Error: checkBeBlock',
            code: '',
            stackTrace: stackTrace,
          );
        }
      },
    );
  }

  @override
  Future<BaseResponse> getTotalUnreadInThread({required String threadID, required int readTime}) {
    return onBaseResponseHandler(
      handler: () async {
        try {
          final threadMessageRef = threadsMessagesRef.child("$threadID/messages");
          final snapshot = threadMessageRef.orderByChild("createTime").startAt(readTime).limitToLast(10);

          return (await snapshot.once()).snapshot.children.length;
        } catch (e, stackTrace) {
          throw FirebaseDatabaseException(
            message: 'Error: checkBeBlock',
            code: '',
            stackTrace: stackTrace,
          );
        }
      },
    );
  }

  @override
  Future<BaseResponse> getUserInfo({
    required String userID,
  }) {
    return onBaseResponseHandler(
      handler: () async {
        try {
          final fbUserID = FirebaseDatabaseUtil.getFirebaseUserID(userID: userID);
          final snapshot = await usersRef.child(fbUserID).get();
          final result = FirebaseDatabaseUtil.convertObjectToMap(snapshot.value);
          return result;
        } catch (e, stackTrace) {
          throw FirebaseDatabaseException(
            message: 'Error: getUserInfo',
            code: '',
            stackTrace: stackTrace,
          );
        }
      },
    );
  }

  @override
  Future<BaseResponse> updateUser({
    required String userID,
    required UserInfoModel user,
  }) {
    return onBaseResponseHandler(
      handler: () async {
        try {
          final fbUser = FirebaseUserModel.fromUserInfo(user);
          final fbUserID = FirebaseDatabaseUtil.getFirebaseUserID(userID: userID);
          final fbPhone = FirebaseDatabaseUtil.getFirebasePhone(phone: fbUser.standardPhoneNumber);
          final userRef = usersRef.child(fbUserID);
          final phoneRef = phoneNumbersUserRef.child(fbPhone).child(fbUserID);
          await userRef.update(fbUser.toJson());
          await phoneRef.update(fbUser.toFirebasePhoneJson());
          return true;
        } catch (e, stackTrace) {
          throw FirebaseDatabaseException(
            message: 'Error: updateUser',
            code: '',
            stackTrace: stackTrace,
          );
        }
      },
    );
  }
}
