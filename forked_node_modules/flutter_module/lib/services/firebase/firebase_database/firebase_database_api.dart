import 'package:flutter_module/common/enum/chat/thread_message_type.dart';
import 'package:flutter_module/common/utils/log_util.dart';
import 'package:flutter_module/models/chat/thread/chat_thread_model.dart';
import 'package:flutter_module/models/chat/user/firebase_user_model.dart';
import 'package:flutter_module/models/user/user_info_model.dart';
import 'package:flutter_module/services/api/chat/payload/create_thread/create_single_thread_payload.dart';
import 'package:flutter_module/services/api/chat/payload/create_thread/create_group_thread_payload.dart';
import 'package:flutter_module/services/api/chat/payload/thread_messages/add_message_to_thread_payload.dart';
import 'package:flutter_module/services/api/chat/payload/thread_messages/get_messages_in_thread_payload.dart';
import 'package:flutter_module/services/api/chat/payload/thread_messages/message_payload.dart';
import 'package:flutter_module/services/api/chat/payload/thread_messages/search_message_payload.dart';
import 'package:flutter_module/services/api/chat/payload/thread_messages/update_message_payload.dart';
import 'package:flutter_module/services/api/chat/payload/thread_messages/update_read_time_in_thread_pay_load.dart';
import 'package:flutter_module/services/api/chat/payload/thread_setting/update_background_image_payload.dart';
import 'package:flutter_module/services/base/base_response.dart';

abstract mixin class FirebaseDatabaseApi {
  Future<BaseResponse> onBaseResponseHandler({
    required Future<dynamic> Function() handler,
  }) async {
    try {
      final data = await handler();
      // AppLog.d('FirebaseDatabaseApi', jsonEncode(data));
      return BaseResponse(
        status: data != null,
        errorMessage: null,
        data: data,
      );
    } catch (e, stackTrace) {
      AppLog.e('FirebaseDatabaseApi', '${e.toString()}\n${stackTrace.toString()}');
      return BaseResponse(
        status: false,
        errorMessage: "$e",
        data: null,
      );
    }
  }

  /// API
  Future<BaseResponse> getThreadIDsOfUser(String userID);

  Future<BaseResponse> getThread(String threadID);

  Future<BaseResponse> getThreadsFromThreadIDs(List<String> threadIDs);

  Future<BaseResponse> getThreadsOfUser(String userID);

  /// Get messages in thread
  /// - where message.createTime < fromCreateTime (or now if fromCreateTime = null)
  /// - order desc by createTime, 1st message is the newest
  Future<BaseResponse> getMessagesInThread({
    required GetMessagesInThreadPayload payload,
  });

  Future<BaseResponse> getExistedMessageInThread({
    required MessagePayload payload,
  });

  Future<BaseResponse> searchMessage({
    required SearchMessagePayload payload,
  });

  /// Add a message into a thread
  /// -> Caller must check whether thread exists or not
  /// @param {string} [threadID]
  /// @param {Message} [wrapper]
  /// @returns a Promise contains messageID or null
  Future<BaseResponse> addMessageToThread({
    required AddMessageToThreadPayload payload,
  });

  Future<BaseResponse> addLocalMessageToThread({
    required AddMessageToThreadPayload payload,
  });

  /// Push message in a thread
  /// Only sender is received
  Future<BaseResponse> pushLocalMessage({
    required AddMessageToThreadPayload payload,
  });

  /// Update message in a thread
  Future<BaseResponse> updateMessage({
    required UpdateMessagePayload payload,
  });

  Future<BaseResponse> updateBackgroundImage({
    required UpdateBackgroundImagePayload payload,
  });

  Future<BaseResponse> toggleUserNotificationOnInThread({
    required String threadID,
    required bool isOn,
  });

  Future<BaseResponse> toggleUserFavoriteInThread({
    required String threadID,
    required bool isFavorite,
  });

  Future<BaseResponse> deleteChatThread({
    required String threadID,
  });

  Future<BaseResponse> getMessagesInThreadWithType({
    required String threadID,
    required ThreadMessageType type,
    int maxMessages = 256,
  });

  Future<BaseResponse> createThreadGroup({
    required CreateGroupThreadPayload payload,
  });

  Future<BaseResponse> createSingleThread({
    required CreateSingleThreadPayload payload,
  });

  Future<BaseResponse> addUsersToGroupThread({
    required String threadID,
    required List<ThreadUserDetail> users,
  });

  Future<BaseResponse> leaveChatThread({
    required String threadID,
  });

  Future<BaseResponse> updateTitleGroupThread({
    required String threadID,
    required String title,
  });

  Future<BaseResponse> unDeleteThreadChat({
    required String threadID,
  });

  /// mUpdateThreadUpdateTimeToNow
  Future<BaseResponse> updateReadTimeToNowInThread({
    required UpdateReadTimeInThreadPayload payload,
  });

  Future<BaseResponse> block({
    required String userID,
  });

  Future<BaseResponse> unblock({
    required String userID,
  });

  /// [checkBeBlocked]
  /// https://gitlab.com/digipaysolution/subfirebase/-/blob/34bb3cc39760e82006d6109ece9c496732361790/firebase/network/FirebaseDatabase.js#L1263
  Future<BaseResponse> checkBeBlocked({
    required String threadID,
    required String userID,
  });

  Future<BaseResponse> getTotalUnreadInThread({
    required String threadID,
    required int readTime,
  });

  Future<BaseResponse> getUserInfo({
    required String userID,
  });

  Future<BaseResponse> updateUser({
    required String userID,
    required UserInfoModel user,
  });
}
