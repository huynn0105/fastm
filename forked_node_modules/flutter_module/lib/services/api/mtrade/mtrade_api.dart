import 'package:flutter_module/models/general_object.dart';
import 'package:flutter_module/models/mtrade/bonus/mtrade_indirect_bonus_model.dart';
import 'package:flutter_module/models/mtrade/check_project_code/check_project_code_model.dart';
import 'package:flutter_module/models/mtrade/collaborator/mtrade_collaborator_model.dart';
import 'package:flutter_module/models/mtrade/link_brochure/mtrade_link_brochure_model.dart';
import 'package:flutter_module/models/mtrade/my_review/mtrade_filter_my_review_model.dart';
import 'package:flutter_module/models/mtrade/my_review/mtrade_my_review_model.dart';
import 'package:flutter_module/models/mtrade/order/mtrade_order_detail_model.dart';
import 'package:flutter_module/models/mtrade/order/mtrade_order_model.dart';
import 'package:flutter_module/models/mtrade/order/mtrade_order_payment_method_model.dart';
import 'package:flutter_module/models/mtrade/order/mtrade_pay_now_order_model.dart';
import 'package:flutter_module/models/mtrade/pay_later/mtrade_gen_mpl_token_model.dart';
import 'package:flutter_module/models/mtrade/pay_later/mtrade_gen_product_token_model.dart';
import 'package:flutter_module/models/mtrade/pay_later/mtrade_pay_later_info_model.dart';
import 'package:flutter_module/models/mtrade/pay_later/mtrade_pre_screen_data.dart';
import 'package:flutter_module/models/mtrade/personal_link_setup/mtrade_personal_link_setup_model.dart';
import 'package:flutter_module/models/mtrade/personal_website_setup/mtrade_contact_method_model.dart';
import 'package:flutter_module/models/mtrade/personal_website_setup/mtrade_personal_website_setup_model.dart';
import 'package:flutter_module/models/mtrade/personal_website_statistic/mtrade_personal_website_statistic_model.dart';
import 'package:flutter_module/models/mtrade/promotion/data_product_variations_model.dart';
import 'package:flutter_module/models/mtrade/promotion/mtrade_promotion_model.dart';
import 'package:flutter_module/models/mtrade/request_otp/request_otp_model.dart';
import 'package:flutter_module/models/mtrade/review/mtrade_select_user_review_model.dart';
import 'package:flutter_module/models/mtrade/review/mtrade_status_review_model.dart';
import 'package:flutter_module/models/mtrade/tools/mtrade_tools_model.dart';
import 'package:flutter_module/services/api/mfast_file_service.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_category_payload.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_check_promotion_payload.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_collaborator_payload.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_consent_payload.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_event_personal_website_statistic_payload.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_gen_product_token_payload.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_get_pay_later_info_payload.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_mpl_location_payload.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_my_review_payload.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_order_detail_payload.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_order_payload.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_order_payment_method_payload.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_order_price_by_sku_payload.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_pay_now_order_payload.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_personal_link_setup_payload.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_personal_website_setup_payload.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_personal_website_statistic_payload.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_pre_screen_payload.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_request_otp_payload.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_request_paylater_confirm_payload.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_request_paylater_otp_payload.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_review_user_payload.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_search_order_payload.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_search_promotion_payload.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_send_brochure_payload.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_suggested_product_payload.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_tracking_agent_payload.dart';
import 'package:flutter_module/services/api/mtrade/payload/mtrade_verify_otp_payload.dart';

import '../../../models/base_model.dart';
import '../../../models/master_data/master_data_model.dart';
import '../../../models/master_data/time_frame_model.dart';
import '../../../models/mtrade/banner/mtrade_banner_model.dart';
import '../../../models/mtrade/bonus/mtrade_bonus_model.dart';
import '../../../models/mtrade/campaign/campaign_model.dart';
import '../../../models/mtrade/cart/mtrade_cart_product_model.dart';
import '../../../models/mtrade/config/mtrade_config_model.dart';
import '../../../models/mtrade/filter/mtrade_filter_group_model.dart';
import '../../../models/mtrade/order/mtrade_order_price_model.dart';
import '../../../models/mtrade/order/mtrade_searched_order_model.dart';
import '../../../models/mtrade/product/mtrade_brochure_product_model.dart';
import '../../../models/mtrade/product/mtrade_product_model.dart';
import '../../../models/mtrade/product_detail/mtrade_product_detail_model.dart';
import '../../../models/mtrade/product_detail/mtrade_sku_detail_model.dart';
import '../../../models/mtrade/product_detail/product_location_support_model.dart';
import '../../../models/mtrade/product_group/mtrade_product_group_model.dart';
import '../../../models/mtrade/product_group/mtrade_special_group_model.dart';
import '../../base/base_response.dart';
import '../api_service.dart';
import 'mtrade_endpoint.dart';
import 'payload/check_product_stock_payload.dart';
import 'payload/get_payment_method_url_payload.dart';
import 'payload/mtrade_bonus_payload.dart';
import 'payload/mtrade_brochure_product_payload.dart';
import 'payload/mtrade_cart_payload.dart';
import 'payload/mtrade_check_product_support_location_payload.dart';
import 'payload/mtrade_gen_mpl_token_payload.dart';
import 'payload/mtrade_personal_website_payload.dart';
import 'payload/mtrade_product_detail_payload.dart';
import 'payload/mtrade_product_payload.dart';
import 'payload/mtrade_promotion_product_payload.dart';
import 'payload/mtrade_sku_payload.dart';

abstract class MTradeApi {
  Future<BaseModel<MTradeProductGroupModel>> getListProductGroup({required MTradeCategoryPayload payload});

  Future<BaseModel<List<MTradeSpecialGroupModel>>> getListSpecialCategory();

  Future<BaseModel<List<MTradeBannerModel>>> getListBanner();

  Future<BaseModel<List<MTradeFilterGroupModel>>> getListFilter();

  Future<BaseModel<List<MTradeProductModel>>> getFilterProducts({
    required MTradeProductPayload payload,
  });

  Future<BaseModel<MTradeProductDetailModel>> getProductDetail({
    required MTradeProductDetailPayload payload,
  });

  Future<BaseModel<List<String>>> getFilterSuggestion({
    required String productName,
  });

  Future<BaseModel<List<MTradeCartProductModel>>> getListCart({
    required int page,
  });

  Future<BaseModel<bool>> createCartItem({
    required MTradeCartPayload payload,
  });

  Future<BaseModel<bool>> deleteCartItem({
    required MTradeCartPayload payload,
  });

  Future<BaseModel<List<MasterDataModel>>> getDeliveryLocation({
    required String type,
    required String code,
  });

  Future<BaseModel<List<MasterDataModel>>> getFastDeliveryLocation({
    required List<String>? productGroup,
  });

  Future<BaseModel<MTradeSkuDetailModel>> getSkuDetailByOption({
    required MTradeSkuPayload payload,
  });

  Future<BaseModel<MTradeOrderPriceModel>> getOrderPriceBySKU({
    required MTradeOrderPriceBySkuPayload payload,
  });

  Future<BaseModel<MTradePayNowOrderModel>> submitPayNowOrder({
    required MTradePayNowOrderPayload payload,
  });

  Future<BaseModel<MTradeBonusModel>> getMTradeBonus({
    required MTradeBonusPayload payload,
  });

  Future<BaseModel<List<MTradeIndirectBonusModel>>> getIndirectBonus({
    required MTradeBonusPayload payload,
  });

  Future<BaseModel<MTradeCollaboratorModel>> getDetailCollaborator({
    required MTradeCollaboratorPayload payload,
  });

  Future<BaseModel<MTradeOrderModel>> getListOrderProcessState({
    required MTradeOrderPayload payload,
  });

  Future<BaseModel<List<MTradeBrochureProductModel>>> getBrochureProduct({
    required MTradeBrochureProductPayload payload,
  });

  Future<BaseModel<MTradeCheckProjectCodeModel>> checkProjectCode();

  Future<BaseModel<MTradeConfigModel>> getConfigs();

  Future<BaseModel<ProductLocationSupportModel>> checkProductLocationSupport({
    required MtradeCheckProductSupportLocationPayload payload,
  });

  Future<BaseModel<bool>> sendBrochure({
    required MTradeSendBrochurePayload payload,
  });

  Future<BaseModel<MTradeOrderPaymentMethodModel>> getListOrderPaymentMethod({
    required MTradeOrderPaymentMethodPayload payload,
  });

  Future<BaseModel<MTradeOrderDetailModel>> getOrderDetail({
    required MTradeOrderDetailPayload payload,
  });

  Future<BaseModel<MTradePreScreenDataModel>> getPreScreenData({
    required MTradePreScreenDataPayload payload,
  });

  Future<BaseModel<MTradeGenProductTokenModel>> genProductToken({
    required MTradeGenProductTokenPayload payload,
  });

  Future<BaseModel<MTradeGenMplTokenModel>> genMplToken({
    required MTradeGenMplTokenPayload payload,
  });

  Future<BaseModel<List<GeneralObject>>> getMplLocation({
    required MTradeMplLocationPayload payload,
  });

  Future<BaseModel<List<MTradeProductModel>>> getSuggestedProducts({
    required MTradeSuggestedProductPayload payload,
  });

  Future<BaseModel<MTradeSearchOrderModel>> searchOrder({
    required MTradeSearchOrderPayload payload,
  });

  Future<BaseModel<MTradeToolsModel>> getTools();

  Future<BaseModel<MTradePersonalWebsiteSetupModel>> getPersonalWebsiteSetup({
    required MTradePersonalWebsiteDataPayload payload,
  });

  Future<BaseModel<MTradePersonalWebsiteSetupModel>> savePersonalWebsiteSetup({
    required MTradePersonalWebsiteSetupPayload payload,
  });

  Future<BaseModel<MTradeContactMethodModel>> getLandingPageContactMethods();

  Future<BaseModel<RequestOTPModel>> requestPayLaterOtp({
    required MTradeRequestPayLaterOtpPayload payload,
  });

  Future<BaseModel<String>> requestPayLaterConfirm({
    required MTradeRequestPayLaterConfirmPayload payload,
  });

  Future<BaseModel<bool>> checkProductStock({
    required CheckProductStockPayload payload,
  });

  Future<BaseModel<bool>> trackingAgent({
    required MTradeTrackingAgentPayload payload,
  });

  Future<BaseModel<MTradeMyReviewModel>> getListMyReview({
    required MTradeMyReviewPayload payload,
  });

  Future<BaseModel<MTradeFilterMyReviewModel>> getFilterMyReview();

  Future<BaseModel<MTradePersonalLinkSetupModel>> getPersonalLinkSetup();

  Future<BaseModel<bool>> updatePersonalLinkSetup({
    required MTradePersonalLinkSetupPayload payload,
  });

  Future<BaseModel<List<MTradeSelectUserReviewModel>>> getListSelectUserReview({
    required String appID,
  });

  Future<BaseModel<MTradeStatusReviewModel>> getStatusReview();

  Future<BaseModel<bool>> reviewUser({
    required MTradeReviewUserPayload payload,
  });

  Future<BaseModel<MTradeLinkBrochureModel>> getDataLinkBrochure({
    required String ID,
  });

  Future<BaseModel<bool>> sendDataLinkBrochureToEmail({
    required String ID,
    required String email,
  });

  Future<BaseModel<List<DataProductVariationsModel>>> searchPromotion({
    required MTradeSearchPromotionPayload payload,
  });

  Future<BaseModel<List<MTradePromotionModel>>> getPromotionProduct({
    required MTradePromotionProductPayload payload,
  });

  Future<BaseModel<List<DataProductVariationsModel>>> checkPromotion({
    required MTradeCheckPromotionPayload payload,
  });

  Future<BaseModel<MTradePayLaterInfoModel>> getPayLaterInfo({
    required MTradeGetPayLaterInfoPayload payload,
  });

  Future<BaseModel<bool>> sendEventPersonalWebsiteStatistic({
    required MTradeEventPersonalWebsiteStatisticPayload payload,
  });

  Future<BaseModel<MTradePersonalWebsiteStatisticModel>> getPersonalWebsiteStatistic({
    required MTradePersonalWebsiteStatisticPayload payload,
  });

  Future<BaseModel<String>> requestPayLaterDAAMTrade({
    required MTradeRequestPayLaterConfirmPayload payload,
  });

  Future<BaseModel<RequestOTPModel>> requestOTP({
    required MTradeRequestOTPPayload payload,
  });

  Future<BaseModel<bool>> verifyOTP({
    required MTradeVerifyOTPPayload payload,
  });

  Future<BaseModel<bool>> saveConsent({
    required MTradeConsentPayload payload,
  });

  Future<BaseModel<bool>> requestEmailOTP({
    required String email,
  });

  Future<BaseModel<bool>> verifyEmailOTP({
    required String email,
    required String otpCode,
  });

  Future<BaseModel<List<MTradeFilterGroupModel>>> getOrderFilters();

  Future<BaseModel<String>> getPaymentMethodUrl(GetPaymentMethodUrlPayload payload);

  Future<BaseModel<List<TimeFrameModel>>> getDeliveryTimeFrame();

  Future<BaseModel<CampaignModel>> getCampaignEvent();
}

class MTradeApiImpl implements MTradeApi {
  @override
  Future<BaseModel<MTradeProductGroupModel>> getListProductGroup({required MTradeCategoryPayload payload}) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getListProductGroup(payload: payload),
    );
    if (apiResponse.status == true) {
      return BaseModel<MTradeProductGroupModel>(
        status: true,
        data: MTradeProductGroupModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<MTradeProductGroupModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<List<MTradeSpecialGroupModel>>> getListSpecialCategory() async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getListSpecialCategory(),
    );
    if (apiResponse.status == true) {
      final data = apiResponse.data as List?;
      return BaseModel<List<MTradeSpecialGroupModel>>(
        status: true,
        data: data?.map((e) => MTradeSpecialGroupModel.fromJson(e)).toList(),
      );
    } else {
      return BaseModel<List<MTradeSpecialGroupModel>>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<List<MTradeBannerModel>>> getListBanner() async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getListBanner(),
    );
    if (apiResponse.status == true) {
      final data = apiResponse.data as List?;
      return BaseModel<List<MTradeBannerModel>>(
        status: true,
        data: data?.map((e) => MTradeBannerModel.fromJson(e)).toList(),
      );
    } else {
      return BaseModel<List<MTradeBannerModel>>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<List<MTradeProductModel>>> getFilterProducts({
    required MTradeProductPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getFilterProducts(
        payload: payload,
      ),
    );
    if (apiResponse.status == true) {
      final data = apiResponse.data as List?;
      return BaseModel<List<MTradeProductModel>>(
        status: true,
        data: data?.map((e) => MTradeProductModel.fromJson(e)).toList(),
      );
    } else {
      return BaseModel<List<MTradeProductModel>>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<MTradeProductDetailModel>> getProductDetail({required MTradeProductDetailPayload payload}) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getProductDetail(
        payload: payload,
      ),
    );
    if (apiResponse.status == true) {
      return BaseModel<MTradeProductDetailModel>(
        status: true,
        data: MTradeProductDetailModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<MTradeProductDetailModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<List<String>>> getFilterSuggestion({required String productName}) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getFilterSuggestion(
        productName: productName,
      ),
    );
    if (apiResponse.status == true) {
      return BaseModel<List<String>>(
        status: true,
        data: apiResponse.data?.cast<String>(),
      );
    } else {
      return BaseModel<List<String>>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<List<MTradeFilterGroupModel>>> getListFilter() async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getListFilter(),
    );
    if (apiResponse.status == true) {
      final data = apiResponse.data as List?;
      return BaseModel<List<MTradeFilterGroupModel>>(
        status: true,
        data: data?.map((e) => MTradeFilterGroupModel.fromJson(e)).toList(),
      );
    } else {
      return BaseModel<List<MTradeFilterGroupModel>>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<List<MTradeCartProductModel>>> getListCart({
    required int page,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getListCart(
        page: page,
      ),
    );
    if (apiResponse.status == true) {
      final data = apiResponse.data as List?;
      return BaseModel<List<MTradeCartProductModel>>(
        status: true,
        data: data?.map((e) => MTradeCartProductModel.fromJson(e)).toList(),
      );
    } else {
      return BaseModel<List<MTradeCartProductModel>>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<bool>> createCartItem({
    required MTradeCartPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().createCartItem(
        payload: payload,
      ),
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorTitle: apiResponse.errorTitle,
        errorMessage: apiResponse.errorMessage,
        errorCode: apiResponse.errorCode,
      );
    }
  }

  @override
  Future<BaseModel<bool>> deleteCartItem({
    required MTradeCartPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().deleteCartItem(
        payload: payload,
      ),
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<List<MasterDataModel>>> getDeliveryLocation({
    required String type,
    required String code,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getDeliveryLocation(
        type: type,
        code: code,
      ),
    );
    if (apiResponse.status == true) {
      final data = apiResponse.data as List?;
      return BaseModel<List<MasterDataModel>>(
        status: true,
        data: data?.map((e) => MasterDataModel.fromJson(e)).toList(),
      );
    } else {
      return BaseModel<List<MasterDataModel>>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<List<MasterDataModel>>> getFastDeliveryLocation({
    required List<String>? productGroup,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getFastDeliveryLocation(
        productGroup: productGroup,
      ),
    );
    if (apiResponse.status == true) {
      final data = apiResponse.data as List?;
      return BaseModel<List<MasterDataModel>>(
        status: true,
        data: data?.map((e) => MasterDataModel.fromJson(e)).toList(),
      );
    } else {
      return BaseModel<List<MasterDataModel>>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<MTradeSkuDetailModel>> getSkuDetailByOption({
    required MTradeSkuPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getSkuDetailByOption(
        payload: payload,
      ),
    );
    if (apiResponse.status == true) {
      return BaseModel<MTradeSkuDetailModel>(
        status: true,
        data: MTradeSkuDetailModel.fromJsonCheck(apiResponse.data),
      );
    } else {
      return BaseModel<MTradeSkuDetailModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<MTradeOrderPriceModel>> getOrderPriceBySKU({
    required MTradeOrderPriceBySkuPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getOrderPriceBySKU(
        payload: payload,
      ),
    );
    if (apiResponse.status == true) {
      return BaseModel<MTradeOrderPriceModel>(
        status: true,
        data: MTradeOrderPriceModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<MTradeOrderPriceModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<MTradePayNowOrderModel>> submitPayNowOrder({
    required MTradePayNowOrderPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().submitPayNowOrder(
        payload: payload,
      ),
    );
    if (apiResponse.status == true) {
      return BaseModel<MTradePayNowOrderModel>(
        status: true,
        data: MTradePayNowOrderModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<MTradePayNowOrderModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
        errorCode: apiResponse.errorCode,
        errorTitle: apiResponse.errorTitle,
        data: MTradePayNowOrderModel.fromJson(apiResponse.data),
      );
    }
  }

  @override
  Future<BaseModel<MTradeBonusModel>> getMTradeBonus({
    required MTradeBonusPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getMTradeBonus(
        payload: payload,
      ),
    );
    if (apiResponse.status == true) {
      return BaseModel<MTradeBonusModel>(
        status: true,
        data: MTradeBonusModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<MTradeBonusModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<List<MTradeIndirectBonusModel>>> getIndirectBonus({
    required MTradeBonusPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getIndirectBonus(
        payload: payload,
      ),
    );
    if (apiResponse.status == true) {
      final data = apiResponse.data["indirect_bonus"] as List?;
      return BaseModel<List<MTradeIndirectBonusModel>>(
        status: true,
        data: data?.map((e) => MTradeIndirectBonusModel.fromJson(e)).toList(),
      );
    } else {
      return BaseModel<List<MTradeIndirectBonusModel>>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<MTradeCollaboratorModel>> getDetailCollaborator({
    required MTradeCollaboratorPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getDetailCollaborator(
        payload: payload,
      ),
    );
    if (apiResponse.status == true) {
      return BaseModel<MTradeCollaboratorModel>(
        status: true,
        data: MTradeCollaboratorModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<MTradeCollaboratorModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<MTradeOrderModel>> getListOrderProcessState({
    required MTradeOrderPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getListOrderProcessState(
        payload: payload,
      ),
    );
    if (apiResponse.status == true) {
      return BaseModel<MTradeOrderModel>(
        status: true,
        data: MTradeOrderModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<MTradeOrderModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<List<MTradeBrochureProductModel>>> getBrochureProduct({
    required MTradeBrochureProductPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getBrochureProduct(
        payload: payload,
      ),
    );
    if (apiResponse.status == true) {
      final data = apiResponse.data?['results'] as List?;
      return BaseModel<List<MTradeBrochureProductModel>>(
        status: true,
        data: data?.map((e) => MTradeBrochureProductModel.fromJson(e)).toList(),
      );
    } else {
      return BaseModel<List<MTradeBrochureProductModel>>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<MTradeCheckProjectCodeModel>> checkProjectCode() async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().checkProjectCode(),
    );
    if (apiResponse.status == true) {
      return BaseModel<MTradeCheckProjectCodeModel>(
        status: true,
        data: MTradeCheckProjectCodeModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<MTradeCheckProjectCodeModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<MTradeConfigModel>> getConfigs() async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getConfigs(),
    );
    if (apiResponse.status == true) {
      return BaseModel<MTradeConfigModel>(
        status: true,
        data: MTradeConfigModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<MTradeConfigModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<ProductLocationSupportModel>> checkProductLocationSupport({
    required MtradeCheckProductSupportLocationPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().checkProductLocationSupport(
        payload: payload,
      ),
    );
    if (apiResponse.status == true) {
      return BaseModel<ProductLocationSupportModel>(
        status: true,
        data: ProductLocationSupportModel.fromJson(apiResponse.data),
        errorMessage: apiResponse.errorMessage,
      );
    } else {
      return BaseModel<ProductLocationSupportModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<bool>> sendBrochure({
    required MTradeSendBrochurePayload payload,
  }) async {
    if (payload.file == null) {
      return BaseModel<bool>(status: false, errorMessage: 'Hình ảnh không hợp lệ');
    }

    BaseResponse apiResponse = await MFastFileService.instance.sendBrochure(
      MTradeEndpoint().sendBrochure(
        payload: payload,
      ),
      payload.email,
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<MTradeOrderPaymentMethodModel>> getListOrderPaymentMethod({
    required MTradeOrderPaymentMethodPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getListOrderPaymentMethod(
        payload: payload,
      ),
    );
    if (apiResponse.status == true) {
      return BaseModel<MTradeOrderPaymentMethodModel>(
        status: true,
        data: MTradeOrderPaymentMethodModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<MTradeOrderPaymentMethodModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<MTradePreScreenDataModel>> getPreScreenData({
    required MTradePreScreenDataPayload payload,
  }) async {
    // await Future.delayed(const Duration(seconds: 2));
    // final data = mockPreScreenData["data"];
    // return BaseModel<MTradePreScreenDataModel>(
    //   status: true,
    //   data: MTradePreScreenDataModel.fromJson(data),
    // );
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getPreScreenData(payload: payload),
    );
    if (apiResponse.status == true) {
      return BaseModel<MTradePreScreenDataModel>(
        status: true,
        data: MTradePreScreenDataModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<MTradePreScreenDataModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<MTradeOrderDetailModel>> getOrderDetail({
    required MTradeOrderDetailPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getOrderDetail(
        payload: payload,
      ),
    );
    if (apiResponse.status == true) {
      return BaseModel<MTradeOrderDetailModel>(
        status: true,
        data: MTradeOrderDetailModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<MTradeOrderDetailModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<MTradeGenProductTokenModel>> genProductToken({
    required MTradeGenProductTokenPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().genProductToken(payload: payload),
    );
    if (apiResponse.status == true) {
      return BaseModel<MTradeGenProductTokenModel>(
        status: true,
        data: MTradeGenProductTokenModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<MTradeGenProductTokenModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<MTradeGenMplTokenModel>> genMplToken({
    required MTradeGenMplTokenPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().genMplToken(payload: payload),
    );
    if (apiResponse.status == true) {
      return BaseModel<MTradeGenMplTokenModel>(
        status: true,
        data: MTradeGenMplTokenModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<MTradeGenMplTokenModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<List<GeneralObject>>> getMplLocation({
    required MTradeMplLocationPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getMplLocation(payload: payload),
    );
    if (apiResponse.status == true) {
      final data = apiResponse.data as List?;
      return BaseModel<List<GeneralObject>>(
        status: true,
        data: data?.map((e) => GeneralObject.fromJson(e)).toList(),
      );
    } else {
      return BaseModel<List<GeneralObject>>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<List<MTradeProductModel>>> getSuggestedProducts({
    required MTradeSuggestedProductPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getSuggestedProducts(payload: payload),
    );
    if (apiResponse.status == true) {
      final data = apiResponse.data as List?;
      return BaseModel<List<MTradeProductModel>>(
        status: true,
        data: data?.map((e) => MTradeProductModel.fromJsonSuggestedProduct(e)).toList(),
      );
    } else {
      return BaseModel<List<MTradeProductModel>>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<MTradeSearchOrderModel>> searchOrder({
    required MTradeSearchOrderPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().searchOrder(payload: payload),
    );
    if (apiResponse.status == true) {
      return BaseModel<MTradeSearchOrderModel>(
        status: true,
        data: MTradeSearchOrderModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<MTradeSearchOrderModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<MTradeToolsModel>> getTools() async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getTools(),
    );
    if (apiResponse.status == true) {
      return BaseModel<MTradeToolsModel>(
        status: true,
        data: MTradeToolsModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<MTradeToolsModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<MTradePersonalWebsiteSetupModel>> getPersonalWebsiteSetup({
    required MTradePersonalWebsiteDataPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getPersonalWebsiteSetup(
        payload: payload,
      ),
    );
    if (apiResponse.status == true) {
      return BaseModel<MTradePersonalWebsiteSetupModel>(
        status: true,
        data: MTradePersonalWebsiteSetupModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<MTradePersonalWebsiteSetupModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<MTradePersonalWebsiteSetupModel>> savePersonalWebsiteSetup({
    required MTradePersonalWebsiteSetupPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().savePersonalWebsiteSetup(payload: payload),
    );
    if (apiResponse.status == true) {
      return BaseModel<MTradePersonalWebsiteSetupModel>(
        status: true,
        data: MTradePersonalWebsiteSetupModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<MTradePersonalWebsiteSetupModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<MTradeContactMethodModel>> getLandingPageContactMethods() async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getLandingPageContactMethods(),
    );
    if (apiResponse.status == true) {
      return BaseModel<MTradeContactMethodModel>(
        status: true,
        data: MTradeContactMethodModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<MTradeContactMethodModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<RequestOTPModel>> requestPayLaterOtp({
    required MTradeRequestPayLaterOtpPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().requestPayLaterOtp(payload: payload),
    );
    if (apiResponse.status == true) {
      return BaseModel<RequestOTPModel>(
        status: true,
        data: RequestOTPModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<RequestOTPModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<String>> requestPayLaterConfirm({
    required MTradeRequestPayLaterConfirmPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().requestPayLaterConfirm(payload: payload),
    );
    if (apiResponse.status == true) {
      return BaseModel<String>(
        status: true,
        data: apiResponse.data?['redirectLink'],
      );
    } else {
      return BaseModel<String>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<bool>> checkProductStock({
    required CheckProductStockPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().checkProductStock(payload: payload),
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
        data: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<bool>> trackingAgent({required MTradeTrackingAgentPayload payload}) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().trackingAgent(payload: payload),
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
        data: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<MTradeMyReviewModel>> getListMyReview({required MTradeMyReviewPayload payload}) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getListMyReview(payload: payload),
    );
    if (apiResponse.status == true) {
      return BaseModel<MTradeMyReviewModel>(
        status: true,
        data: MTradeMyReviewModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<MTradeMyReviewModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<MTradeFilterMyReviewModel>> getFilterMyReview() async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getFilterMyReview(),
    );
    if (apiResponse.status == true) {
      return BaseModel<MTradeFilterMyReviewModel>(
        status: true,
        data: MTradeFilterMyReviewModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<MTradeFilterMyReviewModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<MTradePersonalLinkSetupModel>> getPersonalLinkSetup() async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getPersonalLinkSetup(),
    );
    if (apiResponse.status == true) {
      return BaseModel<MTradePersonalLinkSetupModel>(
        status: true,
        data: MTradePersonalLinkSetupModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<MTradePersonalLinkSetupModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<bool>> updatePersonalLinkSetup({
    required MTradePersonalLinkSetupPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().updatePersonalLinkSetup(payload: payload),
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<List<MTradeSelectUserReviewModel>>> getListSelectUserReview({
    required String appID,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getListSelectUserReview(appID: appID),
    );
    if (apiResponse.status == true) {
      final data = apiResponse.data['users'] as List?;
      return BaseModel<List<MTradeSelectUserReviewModel>>(
        status: true,
        data: data?.map((e) => MTradeSelectUserReviewModel.fromJson(e)).toList(),
      );
    } else {
      return BaseModel<List<MTradeSelectUserReviewModel>>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<MTradeStatusReviewModel>> getStatusReview() async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getStatusReview(),
    );
    if (apiResponse.status == true) {
      return BaseModel<MTradeStatusReviewModel>(
        status: true,
        data: MTradeStatusReviewModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<MTradeStatusReviewModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<bool>> reviewUser({required MTradeReviewUserPayload payload}) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().reviewUser(payload: payload),
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<MTradeLinkBrochureModel>> getDataLinkBrochure({required String ID}) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getDataLinkBrochure(ID: ID),
    );
    if (apiResponse.status == true) {
      return BaseModel<MTradeLinkBrochureModel>(
        status: true,
        data: MTradeLinkBrochureModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<MTradeLinkBrochureModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<bool>> sendDataLinkBrochureToEmail({required String ID, required String email}) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().sendDataLinkBrochureToEmail(ID: ID, email: email),
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<List<DataProductVariationsModel>>> searchPromotion(
      {required MTradeSearchPromotionPayload payload}) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().searchPromotion(payload: payload),
    );
    if (apiResponse.status == true) {
      return BaseModel<List<DataProductVariationsModel>>(
        status: true,
        data: (apiResponse.data["data_product_variattions"] as List?)
            ?.map((e) => DataProductVariationsModel.fromJson(e))
            .toList(),
        errorMessage: apiResponse.errorMessage,
      );
    } else {
      return BaseModel<List<DataProductVariationsModel>>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<List<MTradePromotionModel>>> getPromotionProduct({
    required MTradePromotionProductPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getPromotionProduct(payload: payload),
    );
    if (apiResponse.status == true) {
      final data = apiResponse.data as List?;
      return BaseModel<List<MTradePromotionModel>>(
        status: true,
        data: data?.map((e) => MTradePromotionModel.fromJson(e)).toList(),
      );
    } else {
      return BaseModel<List<MTradePromotionModel>>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<List<DataProductVariationsModel>>> checkPromotion({
    required MTradeCheckPromotionPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().checkPromotion(payload: payload),
    );
    if (apiResponse.status == true) {
      return BaseModel<List<DataProductVariationsModel>>(
        status: true,
        data: (apiResponse.data["data_product_variattions"] as List?)
            ?.map((e) => DataProductVariationsModel.fromJson(e))
            .toList(),
        errorMessage: apiResponse.errorMessage,
      );
    } else {
      return BaseModel<List<DataProductVariationsModel>>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
    // if (apiResponse.status == true) {
    //   if (apiResponse.errorCode != null || apiResponse.errorMessage != null) {
    //     return BaseModel<List<MTradePromotionModel>>(
    //       status: false,
    //       errorMessage: apiResponse.errorMessage,
    //       errorCode: apiResponse.errorCode,
    //       errorData: (apiResponse.data["list_code_invalid"] as List?)?.cast<String>(),
    //     );
    //   }
    //   return BaseModel<List<MTradePromotionModel>>(
    //     status: true,
    //     data: (apiResponse.data["promotions"] as List?)?.map((e) => MTradePromotionModel.fromJson(e)).toList(),
    //     errorMessage: apiResponse.errorMessage,
    //     errorCode: apiResponse.errorCode,
    //     errorData: (apiResponse.data["list_code_invalid"] as List?)?.cast<String>(),
    //   );
    // } else {
    //   return BaseModel<List<MTradePromotionModel>>(
    //     status: false,
    //     errorMessage: apiResponse.errorMessage,
    //     errorCode: apiResponse.errorCode,
    //     errorData: (apiResponse.data["list_code_invalid"] as List?)?.cast<String>(),
    //   );
    // }
  }

  @override
  Future<BaseModel<MTradePayLaterInfoModel>> getPayLaterInfo({
    required MTradeGetPayLaterInfoPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getPayLaterInfo(payload: payload),
    );
    if (apiResponse.status == true) {
      return BaseModel<MTradePayLaterInfoModel>(
        status: true,
        data: MTradePayLaterInfoModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<MTradePayLaterInfoModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<bool>> sendEventPersonalWebsiteStatistic({
    required MTradeEventPersonalWebsiteStatisticPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().sendEventPersonalWebsiteStatistic(payload: payload),
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorTitle: apiResponse.errorTitle,
        errorMessage: apiResponse.errorMessage,
        errorCode: apiResponse.errorCode,
      );
    }
  }

  @override
  Future<BaseModel<MTradePersonalWebsiteStatisticModel>> getPersonalWebsiteStatistic({
    required MTradePersonalWebsiteStatisticPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getPersonalWebsiteStatistic(payload: payload),
    );
    if (apiResponse.status == true) {
      return BaseModel<MTradePersonalWebsiteStatisticModel>(
        status: true,
        data: MTradePersonalWebsiteStatisticModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<MTradePersonalWebsiteStatisticModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<String>> requestPayLaterDAAMTrade({required MTradeRequestPayLaterConfirmPayload payload}) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().requestPayLaterDAAMTrade(payload: payload),
    );
    if (apiResponse.status == true) {
      return BaseModel<String>(
        status: true,
        data: apiResponse.data?['redirectLink'],
      );
    } else {
      return BaseModel<String>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<RequestOTPModel>> requestOTP({required MTradeRequestOTPPayload payload}) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().requestOTP(payload: payload),
    );
    if (apiResponse.status == true) {
      return BaseModel<RequestOTPModel>(
        status: true,
        data: RequestOTPModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<RequestOTPModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<bool>> verifyOTP({required MTradeVerifyOTPPayload payload}) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().verifyOTP(payload: payload),
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorMessage: apiResponse.errorMessage,
        errorCode: apiResponse.errorCode,
      );
    }
  }

  @override
  Future<BaseModel<bool>> saveConsent({required MTradeConsentPayload payload}) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().saveConsent(payload: payload),
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<bool>> requestEmailOTP({required String email}) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().requestEmailOTP(email: email),
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<bool>> verifyEmailOTP({required String email, required String otpCode}) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().verifyEmailOTP(email: email, otpCode: otpCode),
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<List<MTradeFilterGroupModel>>> getOrderFilters() async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getOrderFilters(),
    );
    if (apiResponse.status == true) {
      final data = apiResponse.data as List?;
      return BaseModel<List<MTradeFilterGroupModel>>(
        status: true,
        data: data?.map((e) => MTradeFilterGroupModel.fromJson(e)).toList(),
      );
    } else {
      return BaseModel<List<MTradeFilterGroupModel>>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<String>> getPaymentMethodUrl(GetPaymentMethodUrlPayload payload) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getPaymentMethodUrl(payload),
    );
    if (apiResponse.status == true) {
      return BaseModel<String>(
        status: true,
        data: apiResponse.data?['url'],
      );
    } else {
      return BaseModel<String>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<List<TimeFrameModel>>> getDeliveryTimeFrame() async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getDeliveryTimeFrame(),
    );
    if (apiResponse.status == true) {
      final data = apiResponse.data as List?;
      return BaseModel<List<TimeFrameModel>>(
        status: true,
        data: data?.map((e) => TimeFrameModel.fromJson(e)).toList(),
      );
    } else {
      return BaseModel<List<TimeFrameModel>>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<CampaignModel>> getCampaignEvent() async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MTradeEndpoint().getCampaignEvent(),
    );
    if (apiResponse.status == true) {
      Map? data = apiResponse.data;
      if (data?.keys.contains('data') == true) {// -> json[data] null -> json = {status: value, data: value}
        return BaseModel<CampaignModel>(
          status: true,
        );
      }
      return BaseModel<CampaignModel>(
        status: true,
        data: CampaignModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<CampaignModel>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }
}
