import 'dart:convert';
import 'dart:io';

import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_image_compress/flutter_image_compress.dart';
import 'package:flutter_module/app_data.dart';
import 'package:flutter_module/common/utils/datetime_util.dart';
import 'package:path_provider/path_provider.dart';

import '../../../common/utils/log_util.dart';
import '../../env_data.dart';
import '../base/base_endpoint.dart';
import '../base/base_response.dart';

abstract class FileServiceProtocol {
  Future<BaseResponse> uploadImageFromBase64(EndpointType endpoint);

  Future<BaseResponse> uploadImageFromFile(FileEndpointType endpoint);

  Future<BaseResponse> uploadFile(FileEndpointType endpoint);

  Future<BaseResponse> uploadMultiFile(MultiFileEndpointType endpoint);
}

class FileService extends FileServiceProtocol {
  FileService._();

  static const String _tag = 'FileService';
  static final FileService instance = FileService._();

  Dio? dio;

  Dio init() {
    if (dio == null) {
      dio = Dio();
      dio!.options.connectTimeout = const Duration(seconds: 45);
      dio!.options.receiveTimeout = const Duration(seconds: 45);
      dio!.options.baseUrl = EnvData.instance.losUrl;
    }
    return dio!;
  }

  @override
  Future<BaseResponse> uploadImageFromBase64(
    EndpointType endpoint, {
    ProgressCallback? onReceiveProgress,
    ProgressCallback? onSendProgress,
  }) async {
    final dio = init();
    try {
      // Response response = await dio.post(
      //   'storage/uploadFile',
      //   options: Options(headers: header),
      //   data: formData,
      // );
      final header = <String, dynamic>{};

      header['api_key'] = EnvData.instance.losApiKey;

      Response response = await dio.post(
        endpoint.path!,
        options: Options(headers: header),
        data: endpoint.parameters,
        onReceiveProgress: onReceiveProgress,
        onSendProgress: onSendProgress,
      );
      AppLog.d(_tag, 'upload response: $response');
      return response.data?['filename'];
    } catch (error) {
      AppLog.d(_tag, "------------------upload-start-error-response-------------------");
      AppLog.d(_tag, 'response: ${error is DioError ? error.response?.statusMessage : error.toString()}');
      AppLog.d(_tag, "----------------upload-end-error-response------------------");
      return BaseResponse(
        errorMessage: 'Không thể kết nối đến hệ thống!',
      );
    }
  }

  @override
  Future<BaseResponse> uploadImageFromFile(
    FileEndpointType endpoint, {
    ProgressCallback? onReceiveProgress,
    ProgressCallback? onSendProgress,
  }) async {
    final dio = init();
    File file = endpoint.file;
    XFile? result;
    var decodedImage = await decodeImageFromList(file.readAsBytesSync());
    if (decodedImage.width > 1080 || decodedImage.height > 1920) {
      final tempDir = await getTemporaryDirectory();
      final targetPath = "${tempDir.absolute.path}/${DateTime.now().millisecondsSinceEpoch}.jpg";
      result = await FlutterImageCompress.compressAndGetFile(
        file.absolute.path,
        targetPath,
        minHeight: 1920,
        minWidth: 1080,
      );
    } else {
      result = XFile(file.path);
    }

    // AppLog.d('start', DateTimeUtil.getString(DateTime.now(), format: DateTimeFormat.yyyy_MM_dd_HH_mm_ss));
    FormData formData = FormData();
    formData.files.add(MapEntry(
      "file",
      await MultipartFile.fromFile(
        kIsWeb ? file.path : result!.path,
        // contentType: MediaType('image', _getFileExtension(file.path)),
        filename: "img_${DateTime.now().millisecondsSinceEpoch}.${_getFileExtension(file.path)}",
      ),
    ));
    formData.fields.add(const MapEntry("mediaType", "IMAGE"));

    final header = <String, dynamic>{};
    header['api_key'] = EnvData.instance.losApiKey;

    try {
      Response response = await dio.post(
        endpoint.path!,
        options: Options(headers: header),
        data: formData,
        onReceiveProgress: onReceiveProgress,
        onSendProgress: onSendProgress,
      );
      final json = response.data is Map<String, dynamic> ? response.data : response.data[0];
      AppLog.d(_tag, 'response: ${jsonEncode(json)}');
      // AppLog.d('end', DateTimeUtil.getString(DateTime.now(), format: DateTimeFormat.yyyy_MM_dd_HH_mm_ss));
      if (json != null) {
        int statusCode = response.statusCode!;
        if (statusCode >= 200 && statusCode < 300) {
          return BaseResponse.fromJsonSuccess(json);
        } else {
          return BaseResponse.fromJsonFail(json);
        }
      }
      return BaseResponse(
        status: false,
        errorMessage: "Không thể kết nối tới hệ thống!",
      );
    } catch (e) {
      return BaseResponse(
        status: false,
        errorMessage: "Không thể kết nối tới hệ thống!",
      );
    }
  }

  String _getFileExtension(String fileName) {
    try {
      return fileName.split('.').last;
    } catch (e) {
      return '';
    }
  }

  @override
  Future<BaseResponse> uploadFile(
    FileEndpointType endpoint, {
    ProgressCallback? onReceiveProgress,
    ProgressCallback? onSendProgress,
  }) async {
    final Dio dio = init();
    final File file = endpoint.file;
    final int now = DateTime.now().millisecondsSinceEpoch;

    FormData formData = FormData();
    formData.fields.add(const MapEntry("mediaType", "IMAGE"));
    formData.files.add(
      MapEntry(
        "file",
        await MultipartFile.fromFile(
          file.path,
          filename: "file_$now.${_getFileExtension(file.path)}",
        ),
      ),
    );

    final header = <String, dynamic>{};
    header['api_key'] = EnvData.instance.losApiKey;

    try {
      Response response = await dio.post(
        endpoint.path!,
        options: Options(headers: header),
        data: formData,
        onReceiveProgress: onReceiveProgress,
        onSendProgress: onSendProgress,
      );
      final json = response.data is Map<String, dynamic> ? response.data : response.data[0];
      AppLog.d(_tag, 'response: ${jsonEncode(json)}');
      if (json != null) {
        int statusCode = response.statusCode!;
        if (statusCode >= 200 && statusCode < 300) {
          return BaseResponse.fromJsonSuccess(json);
        } else {
          return BaseResponse.fromJsonFail(json);
        }
      }
      return BaseResponse(
        status: false,
        errorMessage: "Không thể kết nối tới hệ thống!",
      );
    } catch (e) {
      return BaseResponse(
        status: false,
        errorMessage: "Không thể kết nối tới hệ thống!",
      );
    }
  }

  @override
  Future<BaseResponse> uploadMultiFile(
    MultiFileEndpointType endpoint, {
    ProgressCallback? onReceiveProgress,
    ProgressCallback? onSendProgress,
  }) async {
    final Dio dio = init();

    FormData formData = FormData();
    formData.fields.add(const MapEntry("mediaType", "IMAGE"));
    for (File e in endpoint.files) {
      final int now = DateTime.now().millisecondsSinceEpoch;
      formData.files.add(
        MapEntry(
          "file",
          await MultipartFile.fromFile(
            e.path,
            filename: "file_$now.${_getFileExtension(e.path)}",
          ),
        ),
      );
    }

    final header = <String, dynamic>{};
    header['api_key'] = EnvData.instance.losApiKey;

    try {
      Response response = await dio.post(
        endpoint.path!,
        options: Options(headers: header),
        data: formData,
        onReceiveProgress: onReceiveProgress,
        onSendProgress: onSendProgress,
      );

      final json = response.data is Map<String, dynamic>
          ? response.data
          : response.data is List<dynamic>
              ? {'data': response.data}
              : response.data[0];

      AppLog.d(_tag, 'response: ${jsonEncode(json)}');

      if (json != null) {
        int statusCode = response.statusCode!;
        if (statusCode >= 200 && statusCode < 300) {
          return BaseResponse.fromJsonSuccess(json);
        } else {
          return BaseResponse.fromJsonFail(json);
        }
      }
      AppLog.d(_tag, 'error: NO DATA');
      return BaseResponse(
        status: false,
        errorMessage: "Không thể kết nối tới hệ thống!",
      );
    } catch (e) {
      AppLog.d(_tag, 'error throw: $e');
      return BaseResponse(
        status: false,
        errorMessage: "Không thể kết nối tới hệ thống!",
      );
    }
  }
}
