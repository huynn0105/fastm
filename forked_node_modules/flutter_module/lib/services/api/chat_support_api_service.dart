import 'dart:convert';

import 'package:dio/dio.dart';
import 'package:flutter_module/app_data.dart';
import 'package:flutter_module/common/utils/log_util.dart';
import 'package:flutter_module/common/utils/network_util.dart';
import 'package:flutter_module/common/utils/text_util.dart';
import 'package:flutter_module/env_data.dart';
import 'package:flutter_module/services/api/interceptor/auth_interceptor.dart';
import 'package:flutter_module/services/base/base_endpoint.dart';
import 'package:flutter_module/services/base/base_response.dart';
import 'package:flutter_module/services/base/method_request.dart';

abstract class ChatAPIServiceProtocol {
  Future<BaseResponse> requestData(EndpointType endpoint);
}

class ChatAPIService extends ChatAPIServiceProtocol {
  final _tag = "ChatAPIService";

  ChatAPIService._();

  static final ChatAPIService instance = ChatAPIService._();

  Dio? dio;

  Dio init() {
    if (dio == null) {
      dio = Dio();
      // dio!.options.connectTimeout = 25000;
      // dio!.options.receiveTimeout = 25000;
    dio!.options.baseUrl = EnvData.instance.chatSupportUrl;
      dio!.interceptors.add(
        AuthInterceptors(
          onUnauthorized: () {},
        ),
      );
    }
    return dio!;
  }

  @override
  Future<BaseResponse> requestData(EndpointType endpoint) async {
    Dio dio = init();
    final isNetworkAvailable = await NetworkUtil.instance.checkConnection();
    if (!isNetworkAvailable) {
      return BaseResponse(
          status: false, errorMessage: "Network is not available");
    }

    final header = <String, dynamic>{};

    // TODO: Temp ignored
    // header['Authorization'] = EnvConfig.instance.mplToken;

    if (AppData.instance.accessToken?.isNotEmpty == true) {
      endpoint.parameters?['accessToken'] = AppData.instance.accessToken;
    }
    if (AppData.instance.landingPageID?.isNotEmpty == true) {
      endpoint.parameters?['pageID'] = AppData.instance.landingPageID;
    }
    endpoint.parameters = {
      ...?endpoint.parameters,
      ...AppData.instance.defaultParam.toJsonWithoutToken(),
    };

    Response response;
    if (endpoint.httpMethod == HttpMethod.get) {
      try {
        response = await dio.request(
          endpoint.path!,
          queryParameters: endpoint.parameters,
          options: Options(
            headers: header,
            contentType: Headers.jsonContentType,
            method: endpoint.httpMethod!.getValue(),
            validateStatus: (status) {
              if (status == null) {
                return false;
              }
              return status < 500;
            },
          ),
        );
      } catch (error) {
        AppLog.d(_tag,
            "----------------------start-error-response-------------------");
        AppLog.d(_tag, 'method: ${endpoint.httpMethod?.getValue()}');
        AppLog.d(_tag, 'path: ${endpoint.path}');
        AppLog.d(_tag, 'param: ${jsonEncode(endpoint.parameters)}');
        AppLog.d(_tag, 'response: $error');
        AppLog.d(_tag,
            "----------------------end-error-response-------------------");
        return BaseResponse(
          status: false,
        );
      }
    } else {
      try {
        response = await dio.request(
          endpoint.path!,
          data: endpoint.parameters,
          options: Options(
            headers: header,
            contentType: Headers.jsonContentType,
            method: endpoint.httpMethod!.getValue(),
            sendTimeout: const Duration(milliseconds: 60000),
            validateStatus: (status) {
              if (status == null) {
                return false;
              }
              return status < 500;
            },
          ),
        );
      } catch (error) {
        AppLog.d(_tag,
            "----------------------start-error-response-------------------");
        AppLog.d(_tag, 'method: ${endpoint.httpMethod?.getValue()}');
        AppLog.d(_tag, 'path: ${endpoint.path}');
        AppLog.d(_tag, 'param: ${jsonEncode(endpoint.parameters)}');
        AppLog.d(_tag,
            'response: ${error is DioError ? error.response?.statusMessage : error.toString()}');
        AppLog.d(_tag,
            "----------------------end-error-response-------------------");
        return BaseResponse(
          status: false,
        );
      }
    }
    final json = (response.data is Map<String, dynamic>)
        ? response.data
        : TextUtils.decode(response.data.toString());
    AppLog.d(_tag, "----------------------start-response-------------------");
    AppLog.d(_tag, 'method: ${endpoint.httpMethod?.getValue()}');
    AppLog.d(_tag, 'path: ${endpoint.path}');
    AppLog.d(_tag, 'param: ${jsonEncode(endpoint.parameters)}');
    AppLog.d(_tag, 'response: ${jsonEncode(json)}');
    AppLog.d(_tag, "----------------------end-response-------------------");
    if (json != null && json is Map<String, dynamic>) {
      if (json['status'] == true) {
        return BaseResponse.fromJsonSuccess(json);
      } else {
        return BaseResponse.fromJsonFail(json);
      }
    }
    return BaseResponse(
      status: false,
    );
  }
}
