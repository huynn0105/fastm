import 'package:flutter_module/common/enum/chat/thread_message_type.dart';
import 'package:flutter_module/common/utils/datetime_util.dart';
import 'package:flutter_module/models/base_model.dart';
import 'package:flutter_module/models/chat/contact/blocked_user_model.dart';
import 'package:flutter_module/models/chat/contact/chat_contact_model.dart';
import 'package:flutter_module/models/chat/contact/chat_request_contact_model.dart';
import 'package:flutter_module/models/chat/contact/chat_search_contact_model.dart';
import 'package:flutter_module/models/chat/file/media_model.dart';
import 'package:flutter_module/models/chat/message/message_model.dart';
import 'package:flutter_module/models/chat/rating/user_rating_model.dart';
import 'package:flutter_module/models/chat/support_request/chat_support_request_model.dart';
import 'package:flutter_module/models/chat/thread/chat_thread_model.dart';
import 'package:flutter_module/models/mtrade/my_review/mentor_rating_model.dart';
import 'package:flutter_module/models/user/user_info_model.dart';
import 'package:flutter_module/services/api/api_service.dart';
import 'package:flutter_module/services/api/chat/chat_endpoint.dart';
import 'package:flutter_module/services/api/chat/payload/create_thread/create_group_thread_payload.dart';
import 'package:flutter_module/services/api/chat/payload/create_thread/create_single_thread_payload.dart';
import 'package:flutter_module/services/api/chat/payload/rating/user_review_payload.dart';
import 'package:flutter_module/services/api/chat/payload/thread_messages/add_message_to_thread_payload.dart';
import 'package:flutter_module/services/api/chat/payload/file_upload_payload.dart';
import 'package:flutter_module/services/api/chat/payload/thread_messages/get_messages_in_thread_payload.dart';
import 'package:flutter_module/services/api/chat/payload/thread_messages/message_payload.dart';
import 'package:flutter_module/services/api/chat/payload/thread_messages/search_message_payload.dart';
import 'package:flutter_module/services/api/chat/payload/thread_messages/update_message_payload.dart';
import 'package:flutter_module/services/api/chat/payload/thread_messages/update_read_time_in_thread_pay_load.dart';
import 'package:flutter_module/services/api/chat/payload/thread_setting/update_background_image_payload.dart';
import 'package:flutter_module/services/api/chat_support_api_service.dart';
import 'package:flutter_module/services/api/file_service.dart';
import 'package:flutter_module/services/api/firebase_function_api_service.dart';
import 'package:flutter_module/services/base/base_response.dart';
import 'package:flutter_module/services/firebase/firebase_database/firebase_database_service.dart';
import 'package:flutter_module/services/local/user_chat_data_helper.dart';

import '../../../common/utils/log_util.dart';
import '../../../models/chat/message/author_model.dart';
import '../../../models/chat/message/user_on_message_model.dart';

abstract class ChatApi {
  Future<BaseModel<ChatSupportRequestModel>> getListSupportRequest({
    required String userID,
    required String type,
    int page = 1,
  });

  Future<BaseModel<MediaModel>> uploadFile({
    required FileUploadPayload payload,
  });

  Future<BaseModel<List<MediaModel>>> uploadMultiFile({
    required FileUploadPayload payload,
  });

  Future<BaseModel<List<MediaModel>>> mUploadMultiFile({
    required FileUploadPayload payload,
  });

  Future<BaseModel<List<ChatThreadModel>>> getThreadsOfUser(String userID, {int? fromUpdateTime});

  Future<BaseModel<List<MessageModel>>> getMessagesInThread({
    required GetMessagesInThreadPayload payload,
  });

  Future<BaseModel<MessageModel>> getExistedMessageInThread({
    required MessagePayload payload,
  });

  Future<BaseModel<List<MessageModel>>> searchMessage({
    required SearchMessagePayload payload,
  });

  Future<BaseModel<String>> addMessageToThread({
    required AddMessageToThreadPayload payload,
  });

  Future<BaseModel<String>> addLocalMessageToThread({
    required AddMessageToThreadPayload payload,
  });

  Future<BaseModel<bool>> updateMessage({
    required UpdateMessagePayload payload,
  });

  Future<BaseModel<MessageModel>> pushLocalMessage({
    required AddMessageToThreadPayload payload,
  });

  Future<BaseModel<List<ChatContactModel>>> getContactsOnline();

  Future<BaseModel<List<ChatSearchContactModel>>> searchContact({
    required String keyword,
  });

  Future<BaseModel<bool>> sendRequestAddContact({
    required String nickname,
    required String phoneNumber,
  });

  Future<BaseModel<Map<String, List<ChatRequestContactModel>>>> getInvitationAndSendingRequest();

  Future<BaseModel<bool>> cancelRequestContact({required String phoneNumber});

  Future<BaseModel<bool>> acceptRequestContact({
    required String invitationID,
    required String acceptedUserID,
  });

  Future<BaseModel<bool>> rejectRequestContact({
    required String senderID,
  });

  Future<BaseModel<List<ChatContactModel>>> getContacts();

  Future<BaseModel<bool>> updateBackgroundImage({
    required UpdateBackgroundImagePayload payload,
  });

  Future<BaseModel<bool>> toggleUserNotificationOnInThread({
    required String threadID,
    required bool isOn,
  });

  Future<BaseModel<bool>> toggleUserFavoriteInThread({
    required String threadID,
    required bool isFavorite,
  });

  Future<BaseModel<bool>> deleteChatThread({
    required String threadID,
  });

  Future<BaseModel<List<MessageModel>>> getImageMessagesInThread({
    required String threadID,
    int? maxMessages,
  });

  Future<BaseModel<List<MessageModel>>> getVideoMessagesInThread({
    required String threadID,
    int? maxMessages,
  });

  Future<BaseModel<ChatThreadModel>> createThreadGroup({
    required CreateGroupThreadPayload payload,
  });

  Future<BaseModel<ChatThreadModel>> createSingleThread({
    required CreateSingleThreadPayload payload,
  });

  Future<BaseModel<bool>> addUsersToGroupThread({
    required String threadID,
    required List<ThreadUserDetail> users,
  });

  Future<BaseModel<bool>> leaveChatThread({
    required String threadID,
  });

  Future<BaseModel<List<ChatThreadModel>>> getThreadsFromThreadIDs({
    required List<String> threadIDs,
  });

  Future<BaseModel<bool>> updateTitleGroupThread({
    required String threadID,
    required String title,
  });

  Future<BaseModel<bool>> updateReadTimeToNowInThread({
    required UpdateReadTimeInThreadPayload payload,
  });

  Future<BaseModel<bool>> updateUserReadTimeInThread({
    required UpdateReadTimeInThreadPayload payload,
  });

  Future<BaseModel<bool>> block({
    required String userID,
  });

  Future<BaseModel<bool>> unblock({
    required String userID,
  });

  Future<BaseModel<bool>> checkBeBlocked({
    required String threadID,
    required String userID,
  });

  Future<BaseModel<int>> getTotalUnreadInThread({
    required String threadID,
    required int readTime,
  });

  Future<BaseModel<UserOnMessageModel>> getUserChat({
    required String userID,
  });

  Future<BaseModel<MentorRatingModel>> getReviews({
    required UserReviewPayload payload,
  });

  Future<BaseModel<UserRatingModel>> getUserRating({
    required String userID,
  });

  Future<BaseModel<List<BlockedUserModel>>> getBlockedUsers();

  Future<BaseModel<bool>> updateUser({
    required String userID,
    required UserInfoModel user,
  });
}

class ChatApiImpl implements ChatApi {
  @override
  Future<BaseModel<ChatSupportRequestModel>> getListSupportRequest({
    required String userID,
    required String type,
    int page = 1,
  }) async {
    BaseResponse apiResponse = await ChatAPIService.instance.requestData(
      ChatEndpoint().getListSupportRequest(
        userID: userID,
        type: type,
        page: page,
      ),
    );
    if (apiResponse.status == true) {
      return BaseModel<ChatSupportRequestModel>(
        status: true,
        data: ChatSupportRequestModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<ChatSupportRequestModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<MediaModel>> uploadFile({
    required FileUploadPayload payload,
  }) async {
    BaseResponse apiResponse = await FileService.instance.uploadFile(
      ChatEndpoint().uploadFile(payload: payload),
      onSendProgress: payload.onSendProgress,
    );
    if (apiResponse.status == true) {
      return BaseModel<MediaModel>(
        status: true,
        data: MediaModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<MediaModel>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<List<MediaModel>>> uploadMultiFile({
    required FileUploadPayload payload,
  }) async {
    BaseResponse apiResponse = await FileService.instance.uploadMultiFile(
      ChatEndpoint().uploadMultiFile(payload: payload),
      onSendProgress: payload.onSendProgress,
    );
    if (apiResponse.status == true) {
      final data = apiResponse.data as List?;
      return BaseModel<List<MediaModel>>(
        status: true,
        data: data?.map((e) => MediaModel.fromJson(e)).toList(),
      );
    } else {
      return BaseModel<List<MediaModel>>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<List<MediaModel>>> mUploadMultiFile({
    required FileUploadPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.uploadMultiFile(
      ChatEndpoint().mUploadMultiFile(payload: payload),
      onSendProgress: payload.onSendProgress,
    );
    if (apiResponse.status == true) {
      final data = apiResponse.data as List?;
      return BaseModel<List<MediaModel>>(
        status: true,
        data: data?.map((e) => MediaModel.fromJson(e)).toList(),
      );
    } else {
      return BaseModel<List<MediaModel>>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<List<ChatThreadModel>>> getThreadsOfUser(String userID, {int? fromUpdateTime}) async {
    BaseResponse apiResponse = await FirebaseDatabaseService.instance.getThreadsOfUser(
      userID,
      fromUpdateTime: fromUpdateTime,
    );
    if (apiResponse.status == true) {
      final data = apiResponse.data as List;
      return BaseModel<List<ChatThreadModel>>(
        status: true,
        data: data.map((e) => ChatThreadModel.fromJson(e)).toList(),
      );
    } else {
      return BaseModel<List<ChatThreadModel>>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<List<MessageModel>>> getMessagesInThread({
    required GetMessagesInThreadPayload payload,
  }) async {
    BaseResponse apiResponse = await FirebaseDatabaseService.instance.getMessagesInThread(
      payload: payload,
    );
    if (apiResponse.status == true) {
      final response = apiResponse.data as List?;
      final data = response?.map((e) => MessageModel.fromJson(e)).toList();
      final users = data?.map((e) => e.author).toList() ?? [];
      for (int i = 0; i < users.length; i++) {
        if (users[i]?.id == null) break;
        BaseModel<UserOnMessageModel> user = await getUserChat(
          userID: users[i]?.id ?? '',
        );
        AppLog.d('endddddddddUser', DateTimeUtil.getString(DateTime.now(), format: DateTimeFormat.yyyy_MM_dd_HH_mm_ss));
        if (user.data != null) {
          users[i]?.avatar = user.data?.avatar;
          users[i]?.fullName = user.data?.fullName;
        }
      }
      return BaseModel<List<MessageModel>>(
        status: true,
        data: data,
      );
    } else {
      return BaseModel<List<MessageModel>>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<MessageModel>> getExistedMessageInThread({
    required MessagePayload payload,
  }) async {
    BaseResponse apiResponse = await FirebaseDatabaseService.instance.getExistedMessageInThread(
      payload: payload,
    );
    if (apiResponse.status == true) {
      final data = MessageModel.fromJson(apiResponse.data);
      if (data.author?.id != null) {
        BaseModel<UserOnMessageModel> user = await getUserChat(
          userID: data.author?.id ?? '',
        );
        if (user.data != null) {
          data.author?.avatar = user.data?.avatar;
          data.author?.fullName = user.data?.fullName;
        }
      }
      return BaseModel<MessageModel>(
        status: true,
        data: data,
      );
    } else {
      return BaseModel<MessageModel>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<List<MessageModel>>> searchMessage({
    required SearchMessagePayload payload,
  }) async {
    BaseResponse apiResponse = await FirebaseDatabaseService.instance.searchMessage(
      payload: payload,
    );
    if (apiResponse.status == true) {
      final response = apiResponse.data as List?;
      final data = response?.map((e) => MessageModel.fromJson(e)).toList();
      final users = data?.map((e) => e.author).toList() ?? [];
      for (int i = 0; i < users.length; i++) {
        if (users[i]?.id == null) break;
        BaseModel<UserOnMessageModel> user = await getUserChat(
          userID: users[i]?.id ?? '',
        );
        if (user.data != null) {
          users[i]?.avatar = user.data?.avatar;
          users[i]?.fullName = user.data?.fullName;
        }
      }
      return BaseModel<List<MessageModel>>(
        status: true,
        data: data,
      );
    } else {
      return BaseModel<List<MessageModel>>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<String>> addMessageToThread({
    required AddMessageToThreadPayload payload,
  }) async {
    BaseResponse apiResponse = await FirebaseDatabaseService.instance.addMessageToThread(
      payload: payload,
    );
    if (apiResponse.status == true) {
      return BaseModel<String>(
        status: true,
        data: apiResponse.data,
      );
    } else {
      return BaseModel<String>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<String>> addLocalMessageToThread({
    required AddMessageToThreadPayload payload,
  }) async {
    BaseResponse apiResponse = await FirebaseDatabaseService.instance.addLocalMessageToThread(
      payload: payload,
    );
    if (apiResponse.status == true) {
      return BaseModel<String>(
        status: true,
        data: apiResponse.data,
      );
    } else {
      return BaseModel<String>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<MessageModel>> pushLocalMessage({
    required AddMessageToThreadPayload payload,
  }) async {
    BaseResponse apiResponse = await FirebaseDatabaseService.instance.pushLocalMessage(
      payload: payload,
    );
    if (apiResponse.status == true) {
      final data = MessageModel.fromJson(apiResponse.data);
      BaseModel<UserOnMessageModel> user = await getUserChat(
        userID: data.author?.id ?? '',
      );
      if (user.data != null) {
        data.author?.avatar = user.data?.avatar;
        data.author?.fullName = user.data?.fullName;
      }
      return BaseModel<MessageModel>(
        status: true,
        data: data,
      );
    } else {
      return BaseModel<MessageModel>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<bool>> updateMessage({
    required UpdateMessagePayload payload,
  }) async {
    BaseResponse apiResponse = await FirebaseDatabaseService.instance.updateMessage(
      payload: payload,
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
        data: apiResponse.data,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorCode: apiResponse.errorCode,
      );
    }
  }

  @override
  Future<BaseModel<List<ChatContactModel>>> getContactsOnline() async {
    BaseResponse apiResponse = await FirebaseFunctionAPIService.instance.requestData(
      ChatEndpoint().getContactsOnline(),
    );
    if (apiResponse.errorMessage == 'success') {
      final data = apiResponse.data as List?;

      return BaseModel<List<ChatContactModel>>(
        status: true,
        data: data?.map((e) => ChatContactModel.fromJson(e)).toList(),
      );
    } else {
      return BaseModel<List<ChatContactModel>>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<List<ChatSearchContactModel>>> searchContact({required String keyword}) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      ChatEndpoint().searchContact(keyword: keyword),
    );
    if (apiResponse.status == true) {
      final data = (apiResponse.data ?? []) as List;

      return BaseModel<List<ChatSearchContactModel>>(
        status: true,
        data: data.map((e) => ChatSearchContactModel.fromJson(e)).toList(),
      );
    } else {
      return BaseModel<List<ChatSearchContactModel>>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<bool>> sendRequestAddContact({required String nickname, required String phoneNumber}) async {
    BaseResponse apiResponse = await FirebaseFunctionAPIService.instance.requestData(
      ChatEndpoint().sendRequestAddContact(nickname: nickname, phoneNumber: phoneNumber),
    );
    if (apiResponse.errorMessage == 'success') {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<Map<String, List<ChatRequestContactModel>>>> getInvitationAndSendingRequest() async {
    BaseResponse apiResponse = await FirebaseFunctionAPIService.instance.requestData(
      ChatEndpoint().getInvitationAndSendingRequest(),
    );
    if (apiResponse.errorMessage == 'success') {
      final Map<String, List<ChatRequestContactModel>> data = {};
      data['invitations'] =
          (apiResponse.data['invitations'] as List?)?.map((e) => ChatRequestContactModel.fromJson(e)).toList() ?? [];
      data['sendingRequests'] =
          (apiResponse.data['sendingRequests'] as List?)?.map((e) => ChatRequestContactModel.fromJson(e)).toList() ??
              [];

      return BaseModel<Map<String, List<ChatRequestContactModel>>>(
        status: true,
        data: data,
      );
    } else {
      return BaseModel<Map<String, List<ChatRequestContactModel>>>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<bool>> cancelRequestContact({required String phoneNumber}) async {
    BaseResponse apiResponse = await FirebaseFunctionAPIService.instance.requestData(
      ChatEndpoint().cancelRequestContact(phoneNumber: phoneNumber),
    );
    if (apiResponse.errorMessage == 'success') {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<bool>> acceptRequestContact({required String invitationID, required String acceptedUserID}) async {
    BaseResponse apiResponse = await FirebaseFunctionAPIService.instance.requestData(
      ChatEndpoint().acceptRequestContact(invitationID: invitationID, acceptedUserID: acceptedUserID),
    );
    if (apiResponse.errorMessage == 'success') {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<bool>> rejectRequestContact({required String senderID}) async {
    BaseResponse apiResponse = await FirebaseFunctionAPIService.instance.requestData(
      ChatEndpoint().rejectRequestContact(senderID: senderID),
    );
    if (apiResponse.errorMessage == 'success') {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<List<ChatContactModel>>> getContacts() async {
    BaseResponse apiResponse = await FirebaseFunctionAPIService.instance.requestData(
      ChatEndpoint().getContacts(),
    );
    if (apiResponse.errorMessage == 'success') {
      final data = apiResponse.data as List?;

      return BaseModel<List<ChatContactModel>>(
        status: true,
        data: data?.map((e) => ChatContactModel.fromJson(e)).toList(),
      );
    } else {
      return BaseModel<List<ChatContactModel>>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<bool>> updateBackgroundImage({
    required UpdateBackgroundImagePayload payload,
  }) async {
    BaseResponse apiResponse = await FirebaseDatabaseService.instance.updateBackgroundImage(
      payload: payload,
    );

    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
        data: apiResponse.data,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorCode: apiResponse.errorCode,
      );
    }
  }

  @override
  Future<BaseModel<bool>> toggleUserNotificationOnInThread({required String threadID, required bool isOn}) async {
    BaseResponse apiResponse = await FirebaseDatabaseService.instance.toggleUserNotificationOnInThread(
      threadID: threadID,
      isOn: isOn,
    );

    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
        data: apiResponse.data,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorCode: apiResponse.errorCode,
      );
    }
  }

  @override
  Future<BaseModel<bool>> toggleUserFavoriteInThread({required String threadID, required bool isFavorite}) async {
    BaseResponse apiResponse = await FirebaseDatabaseService.instance.toggleUserFavoriteInThread(
      threadID: threadID,
      isFavorite: isFavorite,
    );

    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
        data: apiResponse.data,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorCode: apiResponse.errorCode,
      );
    }
  }

  @override
  Future<BaseModel<bool>> deleteChatThread({required String threadID}) async {
    BaseResponse apiResponse = await FirebaseDatabaseService.instance.deleteChatThread(
      threadID: threadID,
    );

    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
        data: apiResponse.data,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorCode: apiResponse.errorCode,
      );
    }
  }

  @override
  Future<BaseModel<List<MessageModel>>> getImageMessagesInThread({
    required String threadID,
    int? maxMessages,
  }) async {
    BaseResponse apiResponse = await FirebaseDatabaseService.instance.getMessagesInThreadWithType(
      threadID: threadID,
      type: ThreadMessageType.images,
      maxMessages: maxMessages,
    );

    if (apiResponse.status == true) {
      final data = apiResponse.data as List;
      return BaseModel<List<MessageModel>>(
        status: true,
        data: data.map((e) => MessageModel.fromJson(e)).toList(),
      );
    } else {
      return BaseModel<List<MessageModel>>(
        status: false,
        errorCode: apiResponse.errorCode,
      );
    }
  }

  @override
  Future<BaseModel<List<MessageModel>>> getVideoMessagesInThread({
    required String threadID,
    int? maxMessages,
  }) async {
    BaseResponse apiResponse = await FirebaseDatabaseService.instance.getMessagesInThreadWithType(
      threadID: threadID,
      type: ThreadMessageType.videos,
      maxMessages: maxMessages,
    );

    if (apiResponse.status == true) {
      final data = apiResponse.data as List;
      return BaseModel<List<MessageModel>>(
        status: true,
        data: data.map((e) => MessageModel.fromJson(e)).toList(),
      );
    } else {
      return BaseModel<List<MessageModel>>(
        status: false,
        errorCode: apiResponse.errorCode,
      );
    }
  }

  @override
  Future<BaseModel<ChatThreadModel>> createThreadGroup({
    required CreateGroupThreadPayload payload,
  }) async {
    BaseResponse apiResponse = await FirebaseDatabaseService.instance.createThreadGroup(
      payload: payload,
    );

    if (apiResponse.status == true) {
      return BaseModel<ChatThreadModel>(
        status: true,
        data: ChatThreadModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<ChatThreadModel>(
        status: false,
        errorCode: apiResponse.errorCode,
      );
    }
  }

  @override
  Future<BaseModel<ChatThreadModel>> createSingleThread({
    required CreateSingleThreadPayload payload,
  }) async {
    BaseResponse apiResponse = await FirebaseDatabaseService.instance.createSingleThread(
      payload: payload,
    );

    if (apiResponse.status == true) {
      return BaseModel<ChatThreadModel>(
        status: true,
        data: ChatThreadModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<ChatThreadModel>(
        status: false,
        errorCode: apiResponse.errorCode,
      );
    }
  }

  @override
  Future<BaseModel<bool>> addUsersToGroupThread({
    required String threadID,
    required List<ThreadUserDetail> users,
  }) async {
    BaseResponse apiResponse = await FirebaseDatabaseService.instance.addUsersToGroupThread(
      threadID: threadID,
      users: users,
    );

    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorCode: apiResponse.errorCode,
      );
    }
  }

  @override
  Future<BaseModel<bool>> leaveChatThread({required String threadID}) async {
    BaseResponse apiResponse = await FirebaseDatabaseService.instance.leaveChatThread(
      threadID: threadID,
    );

    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorCode: apiResponse.errorCode,
      );
    }
  }

  @override
  Future<BaseModel<List<ChatThreadModel>>> getThreadsFromThreadIDs({
    required List<String> threadIDs,
  }) async {
    BaseResponse apiResponse = await FirebaseDatabaseService.instance.getThreadsFromThreadIDs(threadIDs);

    if (apiResponse.status == true) {
      final response = apiResponse.data as List;
      final data = response.map((e) => ChatThreadModel.fromJson(e)).toList();
      for (int i = 0; i < data.length; i++) {
        if (data[i].lastMessage?.authorID == null) break;
        BaseModel<UserOnMessageModel> user = await getUserChat(
          userID: data[i].lastMessage?.authorID ?? '',
        );
        if (user.data != null) {
          data[i].lastMessage?.authorAvatarImage = user.data?.avatar;
          data[i].lastMessage?.authorFullName = user.data?.fullName;
        }
      }
      return BaseModel<List<ChatThreadModel>>(
        status: true,
        data: data,
      );
    } else {
      return BaseModel<List<ChatThreadModel>>(
        status: false,
        errorCode: apiResponse.errorCode,
      );
    }
  }

  @override
  Future<BaseModel<bool>> updateTitleGroupThread({
    required String threadID,
    required String title,
  }) async {
    BaseResponse apiResponse = await FirebaseDatabaseService.instance.updateTitleGroupThread(
      threadID: threadID,
      title: title,
    );

    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorCode: apiResponse.errorCode,
      );
    }
  }

  @override
  Future<BaseModel<bool>> updateReadTimeToNowInThread({
    required UpdateReadTimeInThreadPayload payload,
  }) async {
    BaseResponse apiResponse = await FirebaseDatabaseService.instance.updateReadTimeToNowInThread(
      payload: payload,
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<bool>> updateUserReadTimeInThread({
    required UpdateReadTimeInThreadPayload payload,
  }) async {
    BaseResponse apiResponse = await FirebaseFunctionAPIService.instance.requestData(
      ChatEndpoint().updateUserReadTimeInThread(payload: payload),
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<bool>> block({required String userID}) async {
    BaseResponse apiResponse = await FirebaseDatabaseService.instance.block(
      userID: userID,
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<bool>> unblock({required String userID}) async {
    BaseResponse apiResponse = await FirebaseDatabaseService.instance.unblock(
      userID: userID,
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<bool>> checkBeBlocked({
    required String threadID,
    required String userID,
  }) async {
    BaseResponse apiResponse = await FirebaseDatabaseService.instance.checkBeBlocked(
      threadID: threadID,
      userID: userID,
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(status: true, data: apiResponse.data == true);
    } else {
      return BaseModel<bool>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<int>> getTotalUnreadInThread({
    required String threadID,
    required int readTime,
  }) async {
    BaseResponse apiResponse = await FirebaseDatabaseService.instance.getTotalUnreadInThread(
      threadID: threadID,
      readTime: readTime,
    );
    if (apiResponse.status == true) {
      return BaseModel<int>(
        status: true,
        data: apiResponse.data,
      );
    } else {
      return BaseModel<int>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<UserOnMessageModel>> getUserChat({
    required String userID,
  }) async {
    final user = UserChatDataHelper.instance.getExistUser(userID);
    if (user != null) {
      return BaseModel<UserOnMessageModel>(
        status: true,
        data: user,
      );
    }
    BaseResponse apiResponse = await FirebaseDatabaseService.instance.getUserInfo(
      userID: userID,
    );
    if (apiResponse.status == true) {
      final data = UserOnMessageModel.fromJson(apiResponse.data);
      UserChatDataHelper.instance.addUser(data);
      return BaseModel<UserOnMessageModel>(
        status: true,
        data: data,
      );
    } else {
      return BaseModel<UserOnMessageModel>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<MentorRatingModel>> getReviews({required UserReviewPayload payload}) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      ChatEndpoint().getReviews(payload: payload),
    );
    if (apiResponse.status == true) {
      return BaseModel<MentorRatingModel>(
        status: true,
        data: MentorRatingModel.fromJson(apiResponse.data?['listRating']),
      );
    } else {
      return BaseModel<MentorRatingModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<UserRatingModel>> getUserRating({required String userID}) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      ChatEndpoint().getUserRating(userID: userID),
    );
    if (apiResponse.status == true) {
      return BaseModel<UserRatingModel>(status: true, data: UserRatingModel.fromJson(apiResponse.data));
    } else {
      return BaseModel<UserRatingModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<List<BlockedUserModel>>> getBlockedUsers() async {
    BaseResponse apiResponse = await FirebaseFunctionAPIService.instance.requestData(
      ChatEndpoint().getBlockedUsers(),
    );

    if (apiResponse.status == true) {
      final data = apiResponse.data as List?;
      return BaseModel<List<BlockedUserModel>>(
        status: true,
        data: data?.map((e) => BlockedUserModel.fromJson(e)).toList(),
      );
    } else {
      return BaseModel<List<BlockedUserModel>>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<bool>> updateUser({
    required String userID,
    required UserInfoModel user,
  }) async {
    BaseResponse apiResponse = await FirebaseDatabaseService.instance.updateUser(
      userID: userID,
      user: user,
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
        data: apiResponse.data == true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }
}
