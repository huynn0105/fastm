import 'dart:io';

import 'package:collection/collection.dart';
import 'package:flutter_module/common/bottom_sheet/wrapper/data_wrapper.dart';
import 'package:flutter_module/common/utils/text_util.dart';
import 'package:flutter_module/models/base_model.dart';
import 'package:flutter_module/models/mfast/bank_account/bidv_bank_account_model.dart';
import 'package:flutter_module/models/mfast/bank_account/general_bank_branch_model.dart';
import 'package:flutter_module/models/mfast/bank_account/general_bank_model.dart';
import 'package:flutter_module/models/mfast/bank_account/suggested_bank_model.dart';
import 'package:flutter_module/models/mfast/notification/mfast_notification_model.dart';
import 'package:flutter_module/models/mfast/notification/mfast_notification_setting_model.dart';
import 'package:flutter_module/models/mfast/bank_account/general_bank_branch_model.dart';
import 'package:flutter_module/models/mfast/bank_account/general_bank_model.dart';
import 'package:flutter_module/models/mfast/bank_account/suggested_bank_model.dart';
import 'package:flutter_module/models/mfast/notification/mfast_notification_model.dart';
import 'package:flutter_module/models/mfast/notification/mfast_notification_setting_model.dart';
import 'package:flutter_module/models/mfast/report/report_category.dart';
import 'package:flutter_module/models/mfast/report/report_submit_model.dart';
import 'package:flutter_module/models/mfast/report/report_submit_response_model.dart';
import 'package:flutter_module/models/mfast/time_checking/statistic_config_model.dart';
import 'package:flutter_module/models/mfast/time_checking/time_checking_config_model.dart';
import 'package:flutter_module/models/mfast/time_checking/time_checking_detail_model.dart';
import 'package:flutter_module/models/mfast/time_checking/time_checking_info_model.dart';
import 'package:flutter_module/models/mfast/time_checking/time_checking_info_wrapper_model.dart';
import 'package:flutter_module/models/mfast/time_checking/time_checking_submit_payload_model.dart';
import 'package:flutter_module/models/mfast/user_meta_data/mfast_user_meta_data_model.dart';
import 'package:flutter_module/models/personal_setting/bank_account_model.dart';
import 'package:flutter_module/services/api/api_service.dart';
import 'package:flutter_module/services/api/mfast/mfast_endpoint.dart';
import 'package:flutter_module/services/api/mfast/payload/mfast_add_bank_account_payload.dart';
import 'package:flutter_module/services/api/mfast/payload/mfast_get_list_province_payload.dart';
import 'package:flutter_module/services/api/mfast/payload/mfast_register_tax_payload.dart';
import 'package:flutter_module/services/api/mfast/payload/time_checking_history_payload.dart';
import 'package:flutter_module/services/api/mfast/payload/time_checking_report_detail_payload.dart';
import 'package:flutter_module/services/api/mfast_file_service.dart';
import 'package:flutter_module/services/api/notification/payload/mfast_notification_payload.dart';
import 'package:flutter_module/services/base/base_response.dart';

abstract class MFastApi {
  Future<BaseModel<MFastUserMetaDataModel>> getUserMetaData();

  Future<BaseModel<bool>> updateMobilePhone({
    required String mobilePhone,
  });

  Future<BaseModel<String>> uploadImage({
    required File file,
  });

  Future<BaseModel<MFastUserMetaDataModel>> updateUserMetaData({
    required MFastUserMetaDataModel payload,
  });

  Future<BaseModel<List<MFastGeneralBankModel>>> getGeneralBanks();

  Future<BaseModel<List<MFastGeneralBankBranchModel>>> getGeneralBankBranches();

  Future<BaseModel<bool>> addBankAccount({
    required MFastAddBankAccountPayload payload,
  });

  Future<BaseModel<List<DataWrapper>>> getDistricts();

  Future<BaseModel<MFastSuggestedBankModel>> getMetaDataBIDV();

  Future<BaseModel<bool>> checkDuplicateEmail({
    required String email,
  });

  Future<BaseModel<bool>> saveLogOCR({
    Map? data,
  });

  Future<BaseModel<List<MFastNotificationModel>>> getNotifications({
    required MFastNotificationPayload payload,
  });

  Future<BaseModel<bool>> readNotification({
    required String notiID,
  });

  Future<BaseModel<bool>> flagNotification({
    required String notiID,
    required bool isFlag,
  });

  Future<BaseModel<bool>> readAllNotifications({
    required String category,
  });

  Future<BaseModel<List<MFastNotificationSettingModel>>> getNotificationSettings();

  Future<BaseModel<bool>> updateNotificationSettings({
    required String categoryID,
    required String status,
  });

  Future<BaseModel<Map<String, int>>> getUnreadNotification();

  Future<BaseModel<List<BankAccountModel>>> getListBankAccount();

  Future<BaseModel<bool>> setDefaultBankAccount(String ID);

  Future<BaseModel<bool>> removeBankAccount(String ID);

  Future<BaseModel<List<DataWrapper>>> getListProvince(
    MFastGetListProvincePayload payload,
  );

  Future<BaseModel<bool>> registerTax(MFastRegisterTaxPayload payload);

  Future<BaseModel<MFastBIDVBankAccountModel>> getBIDVBankAccount();

  Future<BaseModel<TimeCheckingWrapperModel>> getTimeCheckingHistory(TimeCheckingHistoryPayload date);

  Future<BaseModel<bool>> timeCheckingSubmit(TimeCheckingSubmitPayload payload);

  Future<BaseModel<ReportCategory>> getReportCategories(String type);

  Future<BaseModel<ReportSubmitResponseModel>> submitDataReport(ReportSubmitModel payload);

  Future<BaseModel<TimeCheckingReportDetailModel>> getReportDetail(TimeCheckingReportDetailPayload payload);

  Future<BaseModel<TimeCheckingConfigModel?>> getTimeCheckingConfig();

  Future<BaseModel<StatisticConfigModel?>> getStatisticConfig();
}

class MFastApiImpl implements MFastApi {
  @override
  Future<BaseModel<MFastUserMetaDataModel>> getUserMetaData() async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MFastEndpoint().getUserMetaData(),
    );
    if (apiResponse.status == true) {
      return BaseModel<MFastUserMetaDataModel>(
        status: true,
        data: MFastUserMetaDataModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<MFastUserMetaDataModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<bool>> updateMobilePhone({required String mobilePhone}) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MFastEndpoint().updateMobilePhone(mobilePhone: mobilePhone),
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<String>> uploadImage({
    required File file,
  }) async {
    BaseResponse apiResponse = await MFastFileService.instance.uploadImage(
      MFastEndpoint().uploadImage(file: file),
    );
    if (apiResponse.status == true) {
      return BaseModel<String>(
        status: true,
        data: apiResponse.data?["path"] ?? "",
      );
    } else {
      return BaseModel<String>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<MFastUserMetaDataModel>> updateUserMetaData({
    required MFastUserMetaDataModel payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MFastEndpoint().updateUserMetaData(payload: payload),
    );
    if (apiResponse.status == true) {
      return BaseModel<MFastUserMetaDataModel>(
        status: true,
        data: MFastUserMetaDataModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<MFastUserMetaDataModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<List<MFastGeneralBankModel>>> getGeneralBanks() async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MFastEndpoint().getGeneralBanks(),
    );
    if (apiResponse.status == true) {
      final data = apiResponse.data as List?;
      return BaseModel<List<MFastGeneralBankModel>>(
        status: true,
        data: data?.map((e) => MFastGeneralBankModel.fromJson(e)).toList(),
      );
    } else {
      return BaseModel<List<MFastGeneralBankModel>>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<List<MFastGeneralBankBranchModel>>> getGeneralBankBranches() async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MFastEndpoint().getGeneralBankBranches(),
    );
    if (apiResponse.status == true) {
      final data = apiResponse.data as List?;
      return BaseModel<List<MFastGeneralBankBranchModel>>(
        status: true,
        data: data?.map((e) => MFastGeneralBankBranchModel.fromJson(e)).toList(),
      );
    } else {
      return BaseModel<List<MFastGeneralBankBranchModel>>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<bool>> addBankAccount({
    required MFastAddBankAccountPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MFastEndpoint().addBankAccount(payload: payload),
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
        data: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<List<DataWrapper>>> getDistricts() async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MFastEndpoint().getDistricts(),
    );
    if (apiResponse.status == true) {
      final apiData = apiResponse.data;
      List<DataWrapper> data = [];
      if (apiData is Map) {
        data = apiData.entries.map((e) => DataWrapper(id: e.key, value: e.value)).toList();
      }

      return BaseModel<List<DataWrapper>>(
        status: true,
        data: data,
      );
    } else {
      return BaseModel<List<DataWrapper>>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<MFastSuggestedBankModel>> getMetaDataBIDV() async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MFastEndpoint().getMetaDataBIDV(),
    );
    if (apiResponse.status == true) {
      return BaseModel<MFastSuggestedBankModel>(
        status: true,
        data: MFastSuggestedBankModel.fromJson(apiResponse.data['bidv']),
      );
    } else {
      return BaseModel<MFastSuggestedBankModel>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<bool>> checkDuplicateEmail({required String email}) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MFastEndpoint().checkDuplicateEmail(email: email),
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
      );
    }
  }

  @override
  Future<BaseModel<bool>> saveLogOCR({Map? data}) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MFastEndpoint().saveLogOCR(data: data),
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
      );
    }
  }

  @override
  Future<BaseModel<List<MFastNotificationModel>>> getNotifications({
    required MFastNotificationPayload payload,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MFastEndpoint().getNotifications(payload: payload),
    );
    if (apiResponse.status == true) {
      final data = apiResponse.data as List;
      return BaseModel<List<MFastNotificationModel>>(
        status: true,
        data: data.map((e) => MFastNotificationModel.fromJson(e)).toList(),
      );
    } else {
      return BaseModel<List<MFastNotificationModel>>(
        status: false,
      );
    }
  }

  @override
  Future<BaseModel<bool>> flagNotification({required String notiID, required bool isFlag}) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MFastEndpoint().flagNotification(
        notiID: notiID,
        isFlag: isFlag,
      ),
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
      );
    }
  }

  @override
  Future<BaseModel<bool>> readNotification({required String notiID}) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MFastEndpoint().readNotification(
        notiID: notiID,
      ),
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
      );
    }
  }

  @override
  Future<BaseModel<bool>> readAllNotifications({required String category}) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MFastEndpoint().readAllNotifications(
        category: category,
      ),
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
      );
    }
  }

  @override
  Future<BaseModel<List<MFastNotificationSettingModel>>> getNotificationSettings() async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MFastEndpoint().getNotificationSettings(),
    );
    if (apiResponse.status == true) {
      final data = apiResponse.data as List?;
      return BaseModel<List<MFastNotificationSettingModel>>(
        status: true,
        data: data
                ?.map((e) => MFastNotificationSettingModel.fromJson(e))
                .sorted((a, b) => (TextUtils.parseInt(a.iD) ?? 0).compareTo((TextUtils.parseInt(b.iD) ?? 0))) ??
            [],
      );
    } else {
      return BaseModel<List<MFastNotificationSettingModel>>(
        status: false,
      );
    }
  }

  @override
  Future<BaseModel<bool>> updateNotificationSettings({
    required String categoryID,
    required String status,
  }) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MFastEndpoint().updateNotificationSettings(
        categoryID: categoryID,
        status: status,
      ),
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
      );
    }
  }

  @override
  Future<BaseModel<Map<String, int>>> getUnreadNotification() async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MFastEndpoint().getUnreadNotification(),
    );
    if (apiResponse.status == true) {
      return BaseModel<Map<String, int>>(
        status: true,
        data: Map<String, int>.from(apiResponse.data),
      );
    } else {
      return BaseModel<Map<String, int>>(
        status: false,
      );
    }
  }

  @override
  Future<BaseModel<List<BankAccountModel>>> getListBankAccount() async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MFastEndpoint().getListBankAccount(),
    );
    if (apiResponse.status == true) {
      final data = apiResponse.data as List?;
      return BaseModel<List<BankAccountModel>>(
        status: true,
        data: data
            ?.map(
              (e) => BankAccountModel.fromJson(e),
            )
            .toList(),
      );
    } else {
      return BaseModel<List<BankAccountModel>>(
        status: false,
      );
    }
  }

  @override
  Future<BaseModel<bool>> setDefaultBankAccount(String ID) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MFastEndpoint().setDefaultBankAccount(ID),
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
      );
    }
  }

  @override
  Future<BaseModel<bool>> removeBankAccount(String ID) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MFastEndpoint().removeBankAccount(ID),
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
      );
    }
  }

  @override
  Future<BaseModel<List<DataWrapper>>> getListProvince(
    MFastGetListProvincePayload payload,
  ) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MFastEndpoint().getListProvince(payload),
    );
    if (apiResponse.status == true) {
      final data = apiResponse.data as List?;
      return BaseModel<List<DataWrapper>>(
        status: true,
        data: data?.map((e) => DataWrapper.fromJson(e)).toList(),
      );
    } else {
      return BaseModel<List<DataWrapper>>(
        status: false,
      );
    }
  }

  @override
  Future<BaseModel<bool>> registerTax(MFastRegisterTaxPayload payload) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MFastEndpoint().registerTax(payload),
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<MFastBIDVBankAccountModel>> getBIDVBankAccount() async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MFastEndpoint().getBIDVBankAccount(),
    );
    if (apiResponse.status == true) {
      return BaseModel<MFastBIDVBankAccountModel>(
        status: true,
        data: MFastBIDVBankAccountModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<MFastBIDVBankAccountModel>(
        status: false,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<TimeCheckingWrapperModel>> getTimeCheckingHistory(TimeCheckingHistoryPayload payload) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MFastEndpoint().getTimeCheckingHistory(payload),
    );

    if (apiResponse.status == true && apiResponse.data != null) {
      TimeCheckingInfoModel? infoInDay;
      List<TimeCheckingInfoModel>? infoInMonth;

      if (payload.isHistoryInDay) {
        final data = apiResponse.data;
        infoInDay = TimeCheckingInfoModel.fromJson(data);
      } else {
        final data = apiResponse.data as List?;
        infoInMonth = data?.map((e) => TimeCheckingInfoModel.fromJson(e)).toList();
      }

      return BaseModel<TimeCheckingWrapperModel>(
        status: true,
        data: TimeCheckingWrapperModel(
          dataInDay: infoInDay,
          dataInMonth: infoInMonth,
        ),
      );
    } else {
      return BaseModel<TimeCheckingWrapperModel>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<bool>> timeCheckingSubmit(TimeCheckingSubmitPayload payload) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MFastEndpoint().timeCheckingSubmit(payload),
    );
    if (apiResponse.status == true) {
      return BaseModel<bool>(
        status: true,
      );
    } else {
      return BaseModel<bool>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<ReportCategory>> getReportCategories(String type) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MFastEndpoint().getReportCategories(type),
    );

    if (apiResponse.status == true) {
      return BaseModel<ReportCategory>(
        status: true,
        data: ReportCategory.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<ReportCategory>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<ReportSubmitResponseModel>> submitDataReport(ReportSubmitModel payload) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MFastEndpoint().submitDataReport(payload),
    );

    if (apiResponse.status == true) {
      return BaseModel<ReportSubmitResponseModel>(
        status: true,
        data: ReportSubmitResponseModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<ReportSubmitResponseModel>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<TimeCheckingReportDetailModel>> getReportDetail(TimeCheckingReportDetailPayload payload) async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MFastEndpoint().getReportDetail(payload),
    );

    if (apiResponse.status == true) {
      return BaseModel<TimeCheckingReportDetailModel>(
        status: true,
        data: TimeCheckingReportDetailModel.fromJson(apiResponse.data),
      );
    } else {
      return BaseModel<TimeCheckingReportDetailModel>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<TimeCheckingConfigModel?>> getTimeCheckingConfig() async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MFastEndpoint().getTimeCheckingConfig(),
    );
    if (apiResponse.raw['status'] == true) {
      return BaseModel<TimeCheckingConfigModel?>(
        status: true,
        data: apiResponse.raw['data'] != null ? TimeCheckingConfigModel.fromJson(apiResponse.raw['data']) : null,
      );
    } else {
      return BaseModel<TimeCheckingConfigModel?>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }

  @override
  Future<BaseModel<StatisticConfigModel?>> getStatisticConfig() async {
    BaseResponse apiResponse = await APIService.instance.requestData(
      MFastEndpoint().getStatisticConfig(),
    );

    if (apiResponse.status == true) {
      final data = apiResponse.data != null ? StatisticConfigModel.fromJson(apiResponse.data) : null;
      return BaseModel<StatisticConfigModel?>(
        status: true,
        data: data,
      );
    } else {
      return BaseModel<StatisticConfigModel?>(
        status: false,
        errorCode: apiResponse.errorCode,
        errorMessage: apiResponse.errorMessage,
      );
    }
  }
}
